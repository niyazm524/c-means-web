// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"9bxEN":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "5bb40f258eb82e9b";
"use strict";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"iJDgK":[function(require,module,exports) {
// import './start'
var _jquery = require("jquery");
var _materialize = require("materialize-css/dist/js/materialize");
// import './start'
var _controls = require("./controls");
M.AutoInit();

},{"jquery":"bE6My","materialize-css/dist/js/materialize":"fv5p1","./controls":"ggD5y"}],"bE6My":[function(require,module,exports) {
/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */ (function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    };
    else factory(global);
// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function(window1, noGlobal) {
    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";
    var arr1 = [];
    var document1 = window1.document;
    var getProto = Object.getPrototypeOf;
    var slice1 = arr1.slice;
    var concat = arr1.concat;
    var push1 = arr1.push;
    var indexOf1 = arr1.indexOf;
    var class2type = {
    };
    var toString = class2type.toString;
    var hasOwn1 = class2type.hasOwnProperty;
    var fnToString = hasOwn1.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support1 = {
    };
    function DOMEval(code, doc) {
        doc = doc || document1;
        var script = doc.createElement("script");
        script.text = code;
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module
    var version = "3.2.1", // Define a local copy of jQuery
    jQuery = function(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    }, // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    rtrim1 = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
            return slice1.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            // Return all the elements in a clean array
            if (num == null) return slice1.call(this);
            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            // Return the newly-formed element set
            return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice1.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [
                this[j]
            ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push1,
        sort: arr1.sort,
        splice: arr1.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {
        }, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // Skip the boolean and the target
            target = arguments[i] || {
            };
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) target = {
        };
        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }
        for(; i < length; i++){
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) // Extend the base object
            for(name in options){
                src = target[name];
                copy = options[name];
                // Prevent never-ending loop
                if (target === copy) continue;
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    } else clone = src && jQuery.isPlainObject(src) ? src : {
                    };
                    // Never move original objects, clone them
                    target[name] = jQuery.extend(deep, clone, copy);
                // Don't bring in undefined values
                } else if (copy !== undefined) target[name] = copy;
            }
        }
        // Return the modified object
        return target;
    };
    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {
        },
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            // As of jQuery 3.0, isNumeric is limited to
            // strings and numbers (primitives or objects)
            // that can be coerced to finite numbers (gh-2662)
            var type = jQuery.type(obj);
            return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            !isNaN(obj - parseFloat(obj));
        },
        isPlainObject: function(obj) {
            var proto, Ctor;
            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") return false;
            proto = getProto(obj);
            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) return true;
            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn1.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
            /* eslint-disable no-unused-vars */ // See https://github.com/eslint/eslint/issues/6125
            var name;
            for(name in obj)return false;
            return true;
        },
        type: function(obj) {
            if (obj == null) return obj + "";
            // Support: Android <=2.3 only (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        // Evaluates a script in a global context
        globalEval: function(code) {
            DOMEval(code);
        },
        // Convert dashed to camelCase; used by the css and data modules
        // Support: IE <=9 - 11, Edge 12 - 13
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for(; i < length; i++){
                    if (callback.call(obj[i], i, obj[i]) === false) break;
                }
            } else for(i in obj){
                if (callback.call(obj[i], i, obj[i]) === false) break;
            }
            return obj;
        },
        // Support: Android <=4.0 only
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim1, "");
        },
        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) jQuery.merge(ret, typeof arr === "string" ? [
                    arr
                ] : arr);
                else push1.call(ret, arr);
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf1.call(arr, elem, i);
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for(; j < len; j++)first[i++] = second[j];
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            // Go through the array, only saving the items
            // that pass the validator function
            for(; i < length; i++){
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) matches.push(elems[i]);
            }
            return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for(; i < length; i++){
                    value = callback(elems[i], i, arg);
                    if (value != null) ret.push(value);
                }
            // Go through every key on the object,
            } else for(i in elems){
                value = callback(elems[i], i, arg);
                if (value != null) ret.push(value);
            }
            // Flatten any nested arrays
            return concat.apply([], ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) return undefined;
            // Simulated bind
            args = slice1.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice1.call(arguments)));
            };
            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support1
    });
    if (typeof Symbol === "function") jQuery.fn[Symbol.iterator] = arr1[Symbol.iterator];
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) return false;
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle1 = /*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */ function(window) {
        var i1, support, Expr, getText, isXML1, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches1, contains, // Instance-specific data
        expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) hasDuplicate = true;
            return 0;
        }, // Instance methods
        hasOwn = {
        }.hasOwnProperty, arr2 = [], pop = arr2.pop, push_native = arr2.push, push = arr2.push, slice = arr2.slice, // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for(; i < len; i++){
                if (list[i] === elem) return i;
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]", // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            // NaN means non-codepoint
            // Support: Firefox<24
            // Workaround erroneous numeric interpretation of +"0x"
            return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
            String.fromCharCode(high + 65536) : // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            if (asCodePoint) {
                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                if (ch === "\0") return "\uFFFD";
                // Control characters and (dependent upon position) numbers get escaped as code points
                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            // Other potentially-special ASCII characters get backslash-escaped
            return "\\" + ch;
        }, // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        }, disabledAncestor = addCombinator(function(elem) {
            return elem.disabled === true && ("form" in elem || "label" in elem);
        }, {
            dir: "parentNode",
            next: "legend"
        });
        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr2 = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            arr2[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr2.length ? // Leverage slice if possible
                function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length, i = 0;
                    // Can't trust NodeList.length
                    while(target[j++] = els[i++]);
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;
            results = results || [];
            // Return early from calls with invalid selector or context
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) return results;
            // Try to shortcut find operations (as opposed to filters) in HTML documents
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) setDocument(context);
                context = context || document;
                if (documentIsHTML) {
                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                    // (excepting DocumentFragment context, where the methods don't exist)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        // ID selector
                        if (m = match[1]) {
                            // Document context
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else return results;
                            // Element context
                            } else // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        // Type selector
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        // Class selector
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    // Take advantage of querySelectorAll
                    if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;
                        // qSA looks outside Element context, which is not what we want
                        // Thanks to Andrew Dupont for this workaround technique
                        // Support: IE <=8
                        // Exclude object elements
                        } else if (context.nodeName.toLowerCase() !== "object") {
                            // Capture the context ID, setting it first if necessary
                            if (nid = context.getAttribute("id")) nid = nid.replace(rcssescape, fcssescape);
                            else context.setAttribute("id", nid = expando);
                            // Prefix every selector in the list
                            groups = tokenize(selector);
                            i = groups.length;
                            while(i--)groups[i] = "#" + nid + " " + toSelector(groups[i]);
                            newSelector = groups.join(",");
                            // Expand context for sibling selectors
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        if (newSelector) try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                        } finally{
                            if (nid === expando) context.removeAttribute("id");
                        }
                    }
                }
            }
            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */ function createCache() {
            var keys = [];
            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) // Only keep the most recent entries
                delete cache[keys.shift()];
                return cache[key + " "] = value;
            }
            return cache;
        }
        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */ function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */ function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally{
                // Remove from its parent by default
                if (el.parentNode) el.parentNode.removeChild(el);
                // release memory in IE
                el = null;
            }
        }
        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */ function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = arr.length;
            while(i--)Expr.attrHandle[arr[i]] = handler;
        }
        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */ function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            // Use IE sourceIndex if available on both nodes
            if (diff) return diff;
            // Check if b follows a
            if (cur) while(cur = cur.nextSibling){
                if (cur === b) return -1;
            }
            return a ? 1 : -1;
        }
        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */ function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */ function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */ function createDisabledPseudo(disabled) {
            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
            return function(elem) {
                // Only certain elements can match :enabled or :disabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                if ("form" in elem) {
                    // Check for inherited disabledness on relevant non-disabled elements:
                    // * listed form-associated elements in a disabled fieldset
                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                    // * option elements in a disabled optgroup
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                    // All such elements have a "form" property.
                    if (elem.parentNode && elem.disabled === false) {
                        // Option elements defer to a parent optgroup if present
                        if ("label" in elem) {
                            if ("label" in elem.parentNode) return elem.parentNode.disabled === disabled;
                            else return elem.disabled === disabled;
                        }
                        // Support: IE 6 - 11
                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                        return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                        /* jshint -W018 */ elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                // Try to winnow out elements that can't be disabled before trusting the disabled property.
                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                // even exist on them, let alone have a boolean value.
                } else if ("label" in elem) return elem.disabled === disabled;
                // Remaining elements are neither :enabled nor :disabled
                return false;
            };
        }
        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */ function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    // Match elements found at the specified indexes
                    while(i--)if (seed[j = matchIndexes[i]]) seed[j] = !(matches[j] = seed[j]);
                });
            });
        }
        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */ function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        // Expose support vars for convenience
        support = Sizzle.support = {
        };
        /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */ isXML1 = Sizzle.isXML = function(elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */ setDocument = Sizzle.setDocument = function(node1) {
            var hasCompare, subWindow, doc = node1 ? node1.ownerDocument || node1 : preferredDoc;
            // Return early if doc is invalid or already selected
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) return document;
            // Update global variables
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML1(document);
            // Support: IE 9-11, Edge
            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
            if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                // Support: IE 11, Edge
                if (subWindow.addEventListener) subWindow.addEventListener("unload", unloadHandler, false);
                else if (subWindow.attachEvent) subWindow.attachEvent("onunload", unloadHandler);
            }
            /* Attributes
	---------------------------------------------------------------------- */ // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties
            // (excepting IE8 booleans)
            support.attributes = assert(function(el) {
                el.className = "i";
                return !el.getAttribute("className");
            });
            /* getElement(s)By*
	---------------------------------------------------------------------- */ // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(el) {
                el.appendChild(document.createComment(""));
                return !el.getElementsByTagName("*").length;
            });
            // Support: IE<9
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programmatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            // ID filter and find
            if (support.getById) {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [
                            elem
                        ] : [];
                    }
                };
            } else {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
                // Support: IE 6 - 7 only
                // getElementById is not reliable as a find shortcut
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            // Verify the id attribute
                            node = elem.getAttributeNode("id");
                            if (node && node.value === id) return [
                                elem
                            ];
                            // Fall back on getElementsByName
                            elems = context.getElementsByName(id);
                            i = 0;
                            while(elem = elems[i++]){
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) return [
                                    elem
                                ];
                            }
                        }
                        return [];
                    }
                };
            }
            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") return context.getElementsByTagName(tag);
                else if (support.qsa) return context.querySelectorAll(tag);
            } : function(tag, context) {
                var elem, tmp = [], i = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);
                // Filter out possible comments
                if (tag === "*") {
                    while(elem = results[i++])if (elem.nodeType === 1) tmp.push(elem);
                    return tmp;
                }
                return results;
            };
            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) return context.getElementsByClassName(className);
            };
            /* QSA/matchesSelector
	---------------------------------------------------------------------- */ // QSA and matchesSelector support
            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];
            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See https://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(el) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // https://bugs.jquery.com/ticket/12359
                    docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (el.querySelectorAll("[msallowcapture^='']").length) rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!el.querySelectorAll("[selected]").length) rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                    if (!el.querySelectorAll("[id~=" + expando + "-]").length) rbuggyQSA.push("~=");
                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!el.querySelectorAll(":checked").length) rbuggyQSA.push(":checked");
                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibling-combinator selector` fails
                    if (!el.querySelectorAll("a#" + expando + "+*").length) rbuggyQSA.push(".#.+[+~]");
                });
                assert(function(el) {
                    el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    el.appendChild(input).setAttribute("name", "D");
                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (el.querySelectorAll("[name=d]").length) rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (el.querySelectorAll(":enabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Support: IE9-11+
                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(":disabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    el.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches1 = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) assert(function(el) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                support.disconnectedMatch = matches1.call(el, "*");
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches1.call(el, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
            });
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            /* Contains
	---------------------------------------------------------------------- */ hasCompare = rnative.test(docElem.compareDocumentPosition);
            // Element contains another
            // Purposefully self-exclusive
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) while(b = b.parentNode){
                    if (b === a) return true;
                }
                return false;
            };
            /* Sorting
	---------------------------------------------------------------------- */ // Document order sorting
            sortOrder = hasCompare ? function(a, b) {
                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) return compare;
                // Calculate position if both inputs belong to the same document
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
                1;
                // Disconnected nodes
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    // Choose the first element that is related to our preferred document
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) return -1;
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) return 1;
                    // Maintain original order
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [
                    a
                ], bp = [
                    b
                ];
                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                else if (aup === bup) return siblingCheck(a, b);
                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while(cur = cur.parentNode)ap.unshift(cur);
                cur = b;
                while(cur = cur.parentNode)bp.unshift(cur);
                // Walk down the tree looking for a discrepancy
                while(ap[i] === bp[i])i++;
                return i ? // Do a sibling check if the nodes have a common ancestor
                siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
                ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) setDocument(elem);
            // Make sure that attribute selectors are quoted
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches1.call(elem, expr);
                // IE 9's matchesSelector returns false on disconnected nodes
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) return ret;
            } catch (e) {
            }
            return Sizzle(expr, document, null, [
                elem
            ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            if ((context.ownerDocument || context) !== document) setDocument(context);
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */ Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while(elem = results[i++])if (elem === results[i]) j = duplicates.push(i);
                while(j--)results.splice(duplicates[j], 1);
            }
            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;
            return results;
        };
        /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */ getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) // If no nodeType, this is expected to be an array
            while(node = elem[i++])// Do not traverse comment nodes
            ret += getText(node);
            else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") return elem.textContent;
                else // Traverse its children
                for(elem = elem.firstChild; elem; elem = elem.nextSibling)ret += getText(elem);
            } else if (nodeType === 3 || nodeType === 4) return elem.nodeValue;
            // Do not include comment or processing instruction nodes
            return ret;
        };
        Expr = Sizzle.selectors = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {
            },
            find: {
            },
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") match[3] = " " + match[3] + " ";
                    return match.slice(0, 4);
                },
                "CHILD": function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/ match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) Sizzle.error(match[0]);
                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    // other types prohibit arguments
                    } else if (match[3]) Sizzle.error(match[0]);
                    return match;
                },
                "PSEUDO": function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) return null;
                    // Accept quoted arguments as-is
                    if (match[3]) match[2] = match[4] || match[5] || "";
                    else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },
            filter: {
                "TAG": function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                "CLASS": function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"), classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    }));
                },
                "ATTR": function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) return operator === "!=";
                        if (!operator) return true;
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                "CHILD": function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
                    function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while(dir){
                                    node = elem;
                                    while(node = node[dir]){
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) return false;
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [
                                forward ? parent.firstChild : parent.lastChild
                            ];
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {
                                });
                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {
                                });
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())// When found, cache indexes on `parent` and break
                                if (node.nodeType === 1 && ++diff && node === elem) {
                                    uniqueCache[type] = [
                                        dirruns,
                                        nodeIndex,
                                        diff
                                    ];
                                    break;
                                }
                            } else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {
                                    });
                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {
                                    });
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        // Cache the index of each encountered element
                                        if (useCache) {
                                            outerCache = node[expando] || (node[expando] = {
                                            });
                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {
                                            });
                                            uniqueCache[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) break;
                                    }
                                }
                            }
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                "PSEUDO": function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) return fn(argument);
                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            "",
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while(i--){
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        // Match elements unmatched by `matcher`
                        while(i--)if (elem = unmatched[i]) seed[i] = !(matches[i] = elem);
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                "contains": markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) Sizzle.error("unsupported lang: " + lang);
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                        }
                        while ((elem = elem.parentNode) && elem.nodeType === 1)
                        return false;
                    };
                }),
                // Miscellaneous
                "target": function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                "root": function(elem) {
                    return elem === docElem;
                },
                "focus": function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                "enabled": createDisabledPseudo(false),
                "disabled": createDisabledPseudo(true),
                "checked": function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                "selected": function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) elem.parentNode.selectedIndex;
                    return elem.selected === true;
                },
                // Contents
                "empty": function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for(elem = elem.firstChild; elem; elem = elem.nextSibling){
                        if (elem.nodeType < 6) return false;
                    }
                    return true;
                },
                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                "header": function(elem) {
                    return rheader.test(elem.nodeName);
                },
                "input": function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                "text": function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                "first": createPositionalPseudo(function() {
                    return [
                        0
                    ];
                }),
                "last": createPositionalPseudo(function(matchIndexes, length) {
                    return [
                        length - 1
                    ];
                }),
                "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [
                        argument < 0 ? argument + length : argument
                    ];
                }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for(; --i >= 0;)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for(; ++i < length;)matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        // Add button/input type pseudos
        for(i1 in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        })Expr.pseudos[i1] = createInputPseudo(i1);
        for(i1 in {
            submit: true,
            reset: true
        })Expr.pseudos[i1] = createButtonPseudo(i1);
        // Easy API for creating new setFilters
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while(soFar){
                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) // Don't consume trailing commas as valid
                    soFar = soFar.slice(match[0].length) || soFar;
                    groups.push(tokens = []);
                }
                matched = false;
                // Combinators
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                // Filters
                for(type in Expr.filter)if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    });
                    soFar = soFar.slice(matched.length);
                }
                if (!matched) break;
            }
            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
            tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for(; i < len; i++)selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? // Check against closest ancestor/preceding element
            function(elem, context, xml) {
                while(elem = elem[dir]){
                    if (elem.nodeType === 1 || checkNonElements) return matcher(elem, context, xml);
                }
                return false;
            } : // Check against all ancestor/preceding elements
            function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                    dirruns,
                    doneName
                ];
                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if (xml) {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context, xml)) return true;
                    }
                } else {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {
                        });
                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {
                        });
                        if (skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem;
                        else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) // Assign to newCache so results back-propagate to previous elements
                        return newCache[2] = oldCache[2];
                        else {
                            // Reuse newcache so results back-propagate to previous elements
                            uniqueCache[key] = newCache;
                            // A match means we're done; a fail means we have to keep checking
                            if (newCache[2] = matcher(elem, context, xml)) return true;
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while(i--){
                    if (!matchers[i](elem, context, xml)) return false;
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for(; i < len; i++)Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for(; i < len; i++){
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) map.push(i);
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) postFilter = setMatcher(postFilter);
            if (postFinder && !postFinder[expando]) postFinder = setMatcher(postFinder, postSelector);
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [
                    context
                ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                [] : // ...otherwise use results directly
                results : matcherIn;
                // Find primary matches
                if (matcher) matcher(matcherIn, matcherOut, context, xml);
                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while(i--)if (elem = temp[i]) matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while(i--)if (elem = matcherOut[i]) // Restore matcherIn since elem is not yet a final match
                            temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while(i--)if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) seed[temp] = !(results[temp] = elem);
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) postFinder(null, results, matcherOut, xml);
                    else push.apply(results, matcherOut);
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [
                function(elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    // Avoid hanging onto element (issue #299)
                    checkContext = null;
                    return ret;
                }
            ];
            for(; i < len; i++)if (matcher = Expr.relative[tokens[i].type]) matchers = [
                addCombinator(elementMatcher(matchers), matcher)
            ];
            else {
                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                // Return special upon seeing a positional matcher
                if (matcher[expando]) {
                    // Find the next relative operator (if any) for proper handling
                    j = ++i;
                    for(; j < len; j++){
                        if (Expr.relative[tokens[j].type]) break;
                    }
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i - 1).concat({
                        value: tokens[i - 2].type === " " ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) outermostContext = context === document || context || outermost;
                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for(; i !== len && (elem = elems[i]) != null; i++){
                    if (byElement && elem) {
                        j = 0;
                        if (!context && elem.ownerDocument !== document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while(matcher = elementMatchers[j++])if (matcher(elem, context || document, xml)) {
                            results.push(elem);
                            break;
                        }
                        if (outermost) dirruns = dirrunsUnique;
                    }
                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if (elem = !matcher && elem) matchedCount--;
                        // Lengthen the array for every element, matched or not
                        if (seed) unmatched.push(elem);
                    }
                }
                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;
                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while(matcher = setMatchers[j++])matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while(i--)if (!(unmatched[i] || setMatched[i])) setMatched[i] = pop.call(results);
                        }
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }
                    // Add matches to results
                    push.apply(results, setMatched);
                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) Sizzle.uniqueSort(results);
                }
                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) match = tokenize(selector);
                i = match.length;
                while(i--){
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) setMatchers.push(cached);
                    else elementMatchers.push(cached);
                }
                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };
        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */ select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            // Try to minimize operations if there is only one selector in the list and no seed
            // (the latter of which guarantees us context)
            if (match.length === 1) {
                // Reduce context if the leading compound selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) return results;
                    else if (compiled) context = context.parentNode;
                    selector = selector.slice(tokens.shift().value.length);
                }
                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while(i--){
                    token = tokens[i];
                    // Abort if we hit a combinator
                    if (Expr.relative[type = token.type]) break;
                    if (find = Expr.find[type]) // Search, expanding context for leading sibling combinators
                    {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        // One-time assignments
        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;
        // Initialize against the default document
        setDocument();
        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(el) {
            // Should return 1, but returns 4 (following)
            return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
        });
        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
        })) addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        });
        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
        })) addHandle("value", function(elem, name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") return elem.defaultValue;
        });
        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(el) {
            return el.getAttribute("disabled") == null;
        })) addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        });
        return Sizzle;
    }(window1);
    jQuery.find = Sizzle1;
    jQuery.expr = Sizzle1.selectors;
    // Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle1.uniqueSort;
    jQuery.text = Sizzle1.getText;
    jQuery.isXMLDoc = Sizzle1.isXML;
    jQuery.contains = Sizzle1.contains;
    jQuery.escapeSelector = Sizzle1.escape;
    var dir1 = function(elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while((elem = elem[dir]) && elem.nodeType !== 9)if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) break;
            matched.push(elem);
        }
        return matched;
    };
    var siblings = function(n, elem) {
        var matched = [];
        for(; n; n = n.nextSibling)if (n.nodeType === 1 && n !== elem) matched.push(n);
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName1(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    var risSimple = /^.[^:#\[\.,]*$/;
    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        });
        // Single element
        if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        });
        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") return jQuery.grep(elements, function(elem) {
            return indexOf1.call(qualifier, elem) > -1 !== not;
        });
        // Simple selector that can be filtered directly, removing non-Elements
        if (risSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
        // Complex selector, compare the two sets, removing non-Elements
        qualifier = jQuery.filter(qualifier, elements);
        return jQuery.grep(elements, function(elem) {
            return indexOf1.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem1 = elems[0];
        if (not) expr = ":not(" + expr + ")";
        if (elems.length === 1 && elem1.nodeType === 1) return jQuery.find.matchesSelector(elem1, expr) ? [
            elem1
        ] : [];
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== "string") return this.pushStack(jQuery(selector).filter(function() {
                for(i = 0; i < len; i++){
                    if (jQuery.contains(self[i], this)) return true;
                }
            }));
            ret = this.pushStack([]);
            for(i = 0; i < len; i++)jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    // Initialize a jQuery object
    // A central reference to the root jQuery(document)
    var rootjQuery, // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr1 = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) return this;
        // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)
        root = root || rootjQuery;
        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [
                null,
                selector,
                null
            ];
            else match = rquickExpr1.exec(selector);
            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {
                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document1, true));
                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for(match in context)// Properties of context are called as methods if possible
                        if (jQuery.isFunction(this[match])) this[match](context[match]);
                        else this.attr(match, context[match]);
                    }
                    return this;
                // HANDLE: $(#id)
                } else {
                    elem = document1.getElementById(match[2]);
                    if (elem) {
                        // Inject the element directly into the jQuery object
                        this[0] = elem;
                        this.length = 1;
                    }
                    return this;
                }
            } else if (!context || context.jquery) return (context || root).find(selector);
            else return this.constructor(context).find(selector);
        // HANDLE: $(DOMElement)
        } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
        // HANDLE: $(function)
        // Shortcut for document ready
        } else if (jQuery.isFunction(selector)) return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
        selector(jQuery);
        return jQuery.makeArray(selector, this);
    };
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    // Initialize central reference
    rootjQuery = jQuery(document1);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for(; i < l; i++){
                    if (jQuery.contains(this, targets[i])) return true;
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) for(; i < l; i++){
                for(cur = this[i]; cur && cur !== context; cur = cur.parentNode)// Always skip document fragments
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
            // No argument, return index in parent
            if (!elem) return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            // Index in selector
            if (typeof elem === "string") return indexOf1.call(jQuery(elem), this[0]);
            // Locate the position of the desired element
            return indexOf1.call(this, // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while((cur = cur[dir]) && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir1(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir1(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir1(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir1(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir1(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir1(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {
            }).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            if (nodeName1(elem, "iframe")) return elem.contentDocument;
            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName1(elem, "template")) elem = elem.content || elem;
            return jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") selector = until;
            if (selector && typeof selector === "string") matched = jQuery.filter(selector, matched);
            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) jQuery.uniqueSort(matched);
                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) matched.reverse();
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {
        };
        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */ jQuery.Callbacks = function(options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({
        }, options);
        var firing, // Last fire value for non-forgettable lists
        memory, // Flag to know if list was already fired
        fired, // Flag to prevent firing
        locked, // Actual callback list
        list = [], // Queue of execution data for repeatable lists
        queue = [], // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1, // Fire callbacks
        fire = function() {
            // Enforce single-firing
            locked = locked || options.once;
            // Execute callbacks for all pending executions,
            // respecting firingIndex overrides and runtime changes
            fired = firing = true;
            for(; queue.length; firingIndex = -1){
                memory = queue.shift();
                while(++firingIndex < list.length)// Run callback and check for early termination
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                    // Jump to end and forget the data so .add doesn't re-fire
                    firingIndex = list.length;
                    memory = false;
                }
            }
            // Forget the data if we're done with it
            if (!options.memory) memory = false;
            firing = false;
            // Clean up if we're done firing for good
            if (locked) {
                // Keep an empty list if we have data for future add calls
                if (memory) list = [];
                else list = "";
            }
        }, // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {
                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            if (jQuery.isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) list.push(arg);
                            } else if (arg && arg.length && jQuery.type(arg) !== "string") // Inspect recursively
                            add(arg);
                        });
                    })(arguments);
                    if (memory && !firing) fire();
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                jQuery.each(arguments, function(_, arg) {
                    var index;
                    while((index = jQuery.inArray(arg, list, index)) > -1){
                        list.splice(index, 1);
                        // Handle firing indexes
                        if (index <= firingIndex) firingIndex--;
                    }
                });
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
                if (list) list = [];
                return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function() {
                return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
                locked = queue = [];
                if (!memory && !firing) list = memory = "";
                return this;
            },
            locked: function() {
                return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                if (!locked) {
                    args = args || [];
                    args = [
                        context,
                        args.slice ? args.slice() : args
                    ];
                    queue.push(args);
                    if (!firing) fire();
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            // Check for promise aspect first to privilege synchronous behavior
            if (value && jQuery.isFunction(method = value.promise)) method.call(value).done(resolve).fail(reject);
            else if (value && jQuery.isFunction(method = value.then)) method.call(value, resolve, reject);
            else // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
            // * false: [ value ].slice( 0 ) => resolve( value )
            // * true: [ value ].slice( 1 ) => resolve()
            resolve.apply(undefined, [
                value
            ].slice(noValue));
        // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.
        } catch (value1) {
            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [
                value1
            ]);
        }
    }
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [
                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                [
                    "notify",
                    "progress",
                    jQuery.Callbacks("memory"),
                    jQuery.Callbacks("memory"),
                    2
                ],
                [
                    "resolve",
                    "done",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    0,
                    "resolved"
                ],
                [
                    "reject",
                    "fail",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    1,
                    "rejected"
                ]
            ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred1.done(arguments).fail(arguments);
                    return this;
                },
                "catch": function(fn) {
                    return promise.then(null, fn);
                },
                // Keep pipe for back-compat
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                            var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                            deferred1[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                else newDefer[tuple[0] + "With"](this, fn ? [
                                    returned
                                ] : arguments);
                            });
                        });
                        fns = null;
                    }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    var maxDepth = 0;
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this, args = arguments, mightThrow = function() {
                                var returned, then;
                                // Support: Promises/A+ section 2.3.3.3.3
                                // https://promisesaplus.com/#point-59
                                // Ignore double-resolution attempts
                                if (depth < maxDepth) return;
                                returned = handler.apply(that, args);
                                // Support: Promises/A+ section 2.3.1
                                // https://promisesaplus.com/#point-48
                                if (returned === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                // Support: Promises/A+ sections 2.3.3.1, 3.5
                                // https://promisesaplus.com/#point-54
                                // https://promisesaplus.com/#point-75
                                // Retrieve `then` only once
                                then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                                // Handle a returned thenable
                                if (jQuery.isFunction(then)) {
                                    // Special processors (notify) just wait for resolution
                                    if (special) then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                    else {
                                        // ...and disregard older resolution values
                                        maxDepth++;
                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                    }
                                } else {
                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if (handler !== Identity) {
                                        that = undefined;
                                        args = [
                                            returned
                                        ];
                                    }
                                    // Process the value(s)
                                    // Default process is resolve
                                    (special || deferred.resolveWith)(that, args);
                                }
                            }, // Only normal processors (resolve) catch and reject exceptions
                            process = special ? mightThrow : function() {
                                try {
                                    mightThrow();
                                } catch (e) {
                                    if (jQuery.Deferred.exceptionHook) jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                    // Support: Promises/A+ section 2.3.3.3.4.1
                                    // https://promisesaplus.com/#point-61
                                    // Ignore post-resolution exceptions
                                    if (depth + 1 >= maxDepth) {
                                        // Only substitute handlers pass on context
                                        // and multiple values (non-spec behavior)
                                        if (handler !== Thrower) {
                                            that = undefined;
                                            args = [
                                                e
                                            ];
                                        }
                                        deferred.rejectWith(that, args);
                                    }
                                }
                            };
                            // Support: Promises/A+ section 2.3.3.3.1
                            // https://promisesaplus.com/#point-57
                            // Re-resolve promises immediately to dodge false rejection from
                            // subsequent errors
                            if (depth) process();
                            else {
                                // Call an optional hook to record the stack, in case of exception
                                // since it's otherwise lost when execution goes async
                                if (jQuery.Deferred.getStackHook) process.stackTrace = jQuery.Deferred.getStackHook();
                                window1.setTimeout(process);
                            }
                        };
                    }
                    return jQuery.Deferred(function(newDefer) {
                        // progress_handlers.add( ... )
                        tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                        // fulfilled_handlers.add( ... )
                        tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));
                        // rejected_handlers.add( ... )
                        tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred1 = {
            };
            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add;
                // Handle state
                if (stateString) list.add(function() {
                    // state = "resolved" (i.e., fulfilled)
                    // state = "rejected"
                    state = stateString;
                }, // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i][2].disable, // progress_callbacks.lock
                tuples[0][2].lock);
                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);
                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred1[tuple[0]] = function() {
                    deferred1[tuple[0] + "With"](this === deferred1 ? undefined : this, arguments);
                    return this;
                };
                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred1[tuple[0] + "With"] = list.fireWith;
            });
            // Make the deferred a promise
            promise.promise(deferred1);
            // Call given func if any
            if (func) func.call(deferred1, deferred1);
            // All done!
            return deferred1;
        },
        // Deferred helper
        when: function(singleValue) {
            var // count of uncompleted subordinates
            remaining = arguments.length, // count of unprocessed arguments
            i = remaining, // subordinate fulfillment data
            resolveContexts = Array(i), resolveValues = slice1.call(arguments), // the master Deferred
            master = jQuery.Deferred(), // subordinate callback factory
            updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this;
                    resolveValues[i] = arguments.length > 1 ? slice1.call(arguments) : value;
                    if (!--remaining) master.resolveWith(resolveContexts, resolveValues);
                };
            };
            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) return master.then();
            }
            // Multiple arguments are aggregated like Promise.all array elements
            while(i--)adoptValue(resolveValues[i], updateFunc(i), master.reject);
            return master.promise();
        }
    });
    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window1.console && window1.console.warn && error && rerrorNames.test(error.name)) window1.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    };
    jQuery.readyException = function(error) {
        window1.setTimeout(function() {
            throw error;
        });
    };
    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        readyList.then(fn)// Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        .catch(function(error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) return;
            // Remember that the DOM is ready
            jQuery.isReady = true;
            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) return;
            // If there are functions bound, to execute
            readyList.resolveWith(document1, [
                jQuery
            ]);
        }
    });
    jQuery.ready.then = readyList.then;
    // The ready event handler and self cleanup method
    function completed1() {
        document1.removeEventListener("DOMContentLoaded", completed1);
        window1.removeEventListener("load", completed1);
        jQuery.ready();
    }
    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document1.readyState === "complete" || document1.readyState !== "loading" && !document1.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay ready
    window1.setTimeout(jQuery.ready);
    else {
        // Use the handy event callback
        document1.addEventListener("DOMContentLoaded", completed1);
        // A fallback to window.onload, that will always work
        window1.addEventListener("load", completed1);
    }
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function(elems, fn, key, value2, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        // Sets many values
        if (jQuery.type(key) === "object") {
            chainable = true;
            for(i in key)access(elems, fn, i, key[i], true, emptyGet, raw);
        // Sets one value
        } else if (value2 !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value2)) raw = true;
            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value2);
                    fn = null;
                // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) for(; i < len; i++)fn(elems[i], key, raw ? value2 : value2.call(elems[i], i, fn(elems[i], key)));
        }
        if (chainable) return elems;
        // Gets
        if (bulk) return fn.call(elems);
        return len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function(owner) {
            // Check if the owner object already has a cache
            var value = owner[this.expando];
            // If not, create one
            if (!value) {
                value = {
                };
                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {
                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) owner[this.expando] = value;
                    else Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true
                    });
                }
            }
            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") cache[jQuery.camelCase(data)] = value;
            else // Copy the properties one-by-one to the cache object
            for(prop in data)cache[jQuery.camelCase(prop)] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
        },
        access: function(owner, key, value) {
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || key && typeof key === "string" && value === undefined) return this.get(owner, key);
            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);
            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) return;
            if (key !== undefined) {
                // Support array or space separated string of keys
                if (Array.isArray(key)) // If key is an array of keys...
                // We always set camelCase keys, so remove that.
                key = key.map(jQuery.camelCase);
                else {
                    key = jQuery.camelCase(key);
                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ? [
                        key
                    ] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while(i--)delete cache[key[i]];
            }
            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) owner[this.expando] = undefined;
                else delete owner[this.expando];
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === "true") return true;
        if (data === "false") return false;
        if (data === "null") return null;
        // Only convert to a number if it doesn't change the string
        if (data === +data + "") return +data;
        if (rbrace.test(data)) return JSON.parse(data);
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) {
                }
                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else data = undefined;
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value3) {
            var i, name, data1, elem = this[0], attrs = elem && elem.attributes;
            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data1 = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while(i--)// Support: IE 11 only
                        // The attrs elements can be null (#14894)
                        if (attrs[i]) {
                            name = attrs[i].name;
                            if (name.indexOf("data-") === 0) {
                                name = jQuery.camelCase(name.slice(5));
                                dataAttr(elem, name, data1[name]);
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data1;
            }
            // Sets multiple values
            if (typeof key === "object") return this.each(function() {
                dataUser.set(this, key);
            });
            return access(this, function(value) {
                var data;
                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) return data;
                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) return data;
                    // We tried really hard, but the data doesn't exist.
                    return;
                }
                // Set the data...
                this.each(function() {
                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value3, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    else queue.push(data);
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") queue.unshift("inprogress");
                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) hooks.empty.fire();
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [
                        type + "queue",
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) return jQuery.queue(this[0], type);
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                // Ensure a hooks for this queue
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) defer.resolveWith(elements, [
                    elements
                ]);
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while(i--){
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = [
        "Top",
        "Right",
        "Bottom",
        "Left"
    ];
    var isHiddenWithinTree = function(elem, el) {
        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        // Inline style trumps all
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
    };
    var swap = function(elem, options, callback, args) {
        var ret, name, old = {
        };
        // Remember the old values, and insert the new ones
        for(name in options){
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        // Revert the old values
        for(name in options)elem.style[name] = old[name];
        return ret;
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];
            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;
            do {
                // If previous iteration zeroed out, double until we get *something*.
                // Use string for doubling so we don't accidentally see scale as unchanged below
                scale = scale || ".5";
                // Adjust and apply
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);
            // Update scale, tolerating zero or NaN from tween.cur()
            // Break the loop if scale is unchanged or perfect, or if we've just had enough.
            }while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations)
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {
    };
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) return display;
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") display = "block";
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        // Determine new display value for elements that need to change
        for(; index < length; index++){
            elem = elements[index];
            if (!elem.style) continue;
            display = elem.style.display;
            if (show) {
                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) elem.style.display = "";
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) values[index] = getDefaultDisplay(elem);
            } else if (display !== "none") {
                values[index] = "none";
                // Remember what we're overwriting
                dataPriv.set(elem, "display", display);
            }
        }
        // Set the display of the elements in a second loop to avoid constant reflow
        for(index = 0; index < length; index++)if (values[index] != null) elements[index].style.display = values[index];
        return elements;
    }
    jQuery.fn.extend({
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") return state ? this.show() : this.hide();
            return this.each(function() {
                if (isHiddenWithinTree(this)) jQuery(this).show();
                else jQuery(this).hide();
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
    var rscriptType = /^$|\/(?:java|ecma)script/i;
    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {
        // Support: IE <=9 only
        option: [
            1,
            "<select multiple='multiple'>",
            "</select>"
        ],
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [
            1,
            "<table>",
            "</table>"
        ],
        col: [
            2,
            "<table><colgroup>",
            "</colgroup></table>"
        ],
        tr: [
            2,
            "<table><tbody>",
            "</tbody></table>"
        ],
        td: [
            3,
            "<table><tbody><tr>",
            "</tr></tbody></table>"
        ],
        _default: [
            0,
            "",
            ""
        ]
    };
    // Support: IE <=9 only
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") ret = context.getElementsByTagName(tag || "*");
        else if (typeof context.querySelectorAll !== "undefined") ret = context.querySelectorAll(tag || "*");
        else ret = [];
        if (tag === undefined || tag && nodeName1(context, tag)) return jQuery.merge([
            context
        ], ret);
        return ret;
    }
    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for(; i < l; i++)dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for(; i < l; i++){
            elem = elems[i];
            if (elem || elem === 0) {
                // Add nodes directly
                if (jQuery.type(elem) === "object") // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(nodes, elem.nodeType ? [
                    elem
                ] : elem);
                else if (!rhtml.test(elem)) nodes.push(context.createTextNode(elem));
                else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || [
                        "",
                        ""
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while(j--)tmp = tmp.lastChild;
                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);
                    // Remember the top-level container
                    tmp = fragment.firstChild;
                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }
        // Remove wrapper from fragment
        fragment.textContent = "";
        i = 0;
        while(elem = nodes[i++]){
            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) ignored.push(elem);
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");
            // Preserve script evaluation history
            if (contains) setGlobalEval(tmp);
            // Capture executables
            if (scripts) {
                j = 0;
                while(elem = tmp[j++])if (rscriptType.test(elem.type || "")) scripts.push(elem);
            }
        }
        return fragment;
    }
    (function() {
        var fragment = document1.createDocumentFragment(), div = fragment.appendChild(document1.createElement("div")), input = document1.createElement("input");
        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support1.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support1.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var documentElement1 = document1.documentElement;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    // Support: IE <=9 only
    // See #13393 for more info
    function safeActiveElement() {
        try {
            return document1.activeElement;
        } catch (err) {
        }
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        // Types can be a map of types/handlers
        if (typeof types === "object") {
            // ( types-Object, selector, data )
            if (typeof selector !== "string") {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for(type in types)on(elem, type, selector, data, types[type], one);
            return elem;
        }
        if (data == null && fn == null) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) fn = returnFalse;
        else if (!fn) return elem;
        if (one === 1) {
            origFn = fn;
            fn = function(event) {
                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */ jQuery.event = {
        global: {
        },
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) return;
            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) jQuery.find.matchesSelector(documentElement1, selector);
            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) handler.guid = jQuery.guid++;
            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) events = elemData.events = {
            };
            if (!(eventHandle = elemData.handle)) eventHandle = elemData.handle = function(e) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // There *must* be a type, no attaching namespace-only handlers
                if (!type) continue;
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {
                };
                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;
                // Update special based on newly reset type
                special = jQuery.event.special[type] || {
                };
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) elem.addEventListener(type, eventHandle);
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) handleObj.handler.guid = handler.guid;
                }
                // Add to the element's handler list, delegates in front
                if (selector) handlers.splice(handlers.delegateCount++, 0, handleObj);
                else handlers.push(handleObj);
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) return;
            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for(type in events)jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    continue;
                }
                special = jQuery.event.special[type] || {
                };
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                // Remove matching events
                origCount = j = handlers.length;
                while(j--){
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) handlers.delegateCount--;
                        if (special.remove) special.remove.call(elem, handleObj);
                    }
                }
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) jQuery.removeEvent(elem, type, elemData.handle);
                    delete events[type];
                }
            }
            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) dataPriv.remove(elem, "handle events");
        },
        dispatch: function(nativeEvent) {
            // Make a writable jQuery.Event from the native event object
            var event = jQuery.event.fix(nativeEvent);
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {
            })[event.type] || [], special = jQuery.event.special[event.type] || {
            };
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            for(i = 1; i < arguments.length; i++)args[i] = arguments[i];
            event.delegateTarget = this;
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) return;
            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while((matched = handlerQueue[i++]) && !event.isPropagationStopped()){
                event.currentTarget = matched.elem;
                j = 0;
                while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped())// Triggered event must either 1) have no namespace, or 2) have namespace(s)
                // a subset or equal to those in the bound event (both can have no namespace).
                if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    ret = ((jQuery.event.special[handleObj.origType] || {
                    }).handle || handleObj.handler).apply(matched.elem, args);
                    if (ret !== undefined) {
                        if ((event.result = ret) === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) special.postDispatch.call(this, event);
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            // Find delegate handlers
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
                for(; cur !== this; cur = cur.parentNode || this)// Don't check non-elements (#13208)
                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                    matchedHandlers = [];
                    matchedSelectors = {
                    };
                    for(i = 0; i < delegateCount; i++){
                        handleObj = handlers[i];
                        // Don't conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + " ";
                        if (matchedSelectors[sel] === undefined) matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [
                            cur
                        ]).length;
                        if (matchedSelectors[sel]) matchedHandlers.push(handleObj);
                    }
                    if (matchedHandlers.length) handlerQueue.push({
                        elem: cur,
                        handlers: matchedHandlers
                    });
                }
            }
            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < handlers.length) handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            });
            return handlerQueue;
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: jQuery.isFunction(hook) ? function() {
                    if (this.originalEvent) return hook(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[name];
                },
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if (this.type === "checkbox" && this.click && nodeName1(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                // For cross-browser consistency, don't fire native .click() on links
                _default: function(event) {
                    return nodeName1(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) event.originalEvent.returnValue = event.result;
                }
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        // This "if" is needed for plain objects
        if (elem.removeEventListener) elem.removeEventListener(type, handle);
    };
    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        // Event type
        } else this.type = src;
        // Put explicitly provided properties onto the event object
        if (props) jQuery.extend(this, props);
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();
        // Mark it as fixed
        this[jQuery.expando] = true;
    };
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopImmediatePropagation();
            this.stopPropagation();
        }
    };
    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: function(event) {
            var button = event.button;
            // Add which for key events
            if (event.which == null && rkeyEvent.test(event.type)) return event.charCode != null ? event.charCode : event.keyCode;
            // Add which for click: 1 === left; 2 === middle; 3 === right
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) return 1;
                if (button & 2) return 3;
                if (button & 4) return 2;
                return 0;
            }
            return event.which;
        }
    }, jQuery.event.addProp);
    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for(type in types)this.off(type, selector, types[type]);
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) fn = returnFalse;
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var /* eslint-disable max-len */ // See https://github.com/eslint/eslint/issues/3229
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, /* eslint-enable */ // Support: IE <=10 - 11, Edge 12 - 13
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i, // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName1(elem, "table") && nodeName1(content.nodeType !== 11 ? content : content.firstChild, "tr")) return jQuery(">tbody", elem)[0] || elem;
        return elem;
    }
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) elem.type = match[1];
        else elem.removeAttribute("type");
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) return;
        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {
                };
                for(type in events)for(i = 0, l = events[type].length; i < l; i++)jQuery.event.add(dest, type, events[type][i]);
            }
        }
        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({
            }, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) dest.checked = src.checked;
        else if (nodeName === "input" || nodeName === "textarea") dest.defaultValue = src.defaultValue;
    }
    function domManip(collection, args, callback, ignored) {
        // Flatten any nested arrays
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        // We can't cloneNode fragments that contain checked, in WebKit
        if (isFunction || l > 1 && typeof value === "string" && !support1.checkClone && rchecked.test(value)) return collection.each(function(index) {
            var self = collection.eq(index);
            if (isFunction) args[0] = value.call(this, index, self.html());
            domManip(self, args, callback, ignored);
        });
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) fragment = first;
            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for(; i < l; i++){
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) // Support: Android <=4.0 only, PhantomJS 1 only
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(scripts, getAll(node, "script"));
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);
                    // Evaluate executable scripts on first document insertion
                    for(i = 0; i < hasScripts; i++){
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                            if (node.src) // Optional AJAX dependency, but won't run scripts if not present
                            {
                                if (jQuery._evalUrl) jQuery._evalUrl(node.src);
                            } else DOMEval(node.textContent.replace(rcleanScript, ""), doc);
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for(; (node = nodes[i]) != null; i++){
            if (!keepData && node.nodeType === 1) jQuery.cleanData(getAll(node));
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) setGlobalEval(getAll(node, "script"));
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            // Fix IE cloning issues
            if (!support1.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for(i = 0, l = srcElements.length; i < l; i++)fixInput(srcElements[i], destElements[i]);
            }
            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for(i = 0, l = srcElements.length; i < l; i++)cloneCopyEvent(srcElements[i], destElements[i]);
                } else cloneCopyEvent(elem, clone);
            }
            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            // Return the cloned set
            return clone;
        },
        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for(; (elem = elems[i]) !== undefined; i++)if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                    if (data.events) {
                        for(type in data.events)if (special[type]) jQuery.event.remove(elem, type);
                        else jQuery.removeEvent(elem, type, data.handle);
                    }
                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataPriv.expando] = undefined;
                }
                if (elem[dataUser.expando]) // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[dataUser.expando] = undefined;
            }
        }
    });
    jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, true);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value4) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) this.textContent = value;
                });
            }, null, value4, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        empty: function() {
            var elem, i = 0;
            for(; (elem = this[i]) != null; i++)if (elem.nodeType === 1) {
                // Prevent memory leaks
                jQuery.cleanData(getAll(elem, false));
                // Remove any remaining nodes
                elem.textContent = "";
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value5) {
            return access(this, function(value) {
                var elem = this[0] || {
                }, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) return elem.innerHTML;
                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                    "",
                    ""
                ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for(; i < l; i++){
                            elem = this[i] || {
                            };
                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {
                    }
                }
                if (elem) this.empty().append(value);
            }, null, value5, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) parent.replaceChild(elem, this);
                }
            // Force callback invocation
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for(; i <= last; i++){
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push1.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) view = window1;
        return view.getComputedStyle(elem);
    };
    (function() {
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
            // This is a singleton, we need to execute it only once
            if (!div) return;
            div.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%";
            div.innerHTML = "";
            documentElement1.appendChild(container);
            var divStyle = window1.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = divStyle.marginLeft === "2px";
            boxSizingReliableVal = divStyle.width === "4px";
            // Support: Android 4.0 - 4.3 only
            // Some styles come back with percentage values, even though they shouldn't
            div.style.marginRight = "50%";
            pixelMarginRightVal = divStyle.marginRight === "4px";
            documentElement1.removeChild(container);
            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document1.createElement("div"), div = document1.createElement("div");
        // Finish early in limited (non-browser) environments
        if (!div.style) return;
        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support1.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute";
        container.appendChild(div);
        jQuery.extend(support1, {
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function() {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelMarginRight: function() {
                computeStyleTests();
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
                computeStyleTests();
                return reliableMarginLeftVal;
            }
        });
    })();
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;
        computed = computed || getStyles(elem);
        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) ret = jQuery.style(elem, name);
            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support1.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }
                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [
        "Webkit",
        "Moz",
        "ms"
    ], emptyStyle = document1.createElement("div").style;
    // Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(name) {
        // Shortcut for names that are not vendor prefixed
        if (name in emptyStyle) return name;
        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while(i--){
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) return name;
        }
    }
    // Return a property mapped along what jQuery.cssProps suggests or to
    // a vendor prefixed property.
    function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        if (!ret) ret = jQuery.cssProps[name] = vendorPropName(name) || name;
        return ret;
    }
    function setPositiveNumber(elem, value, subtract) {
        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i, val = 0;
        // If we already have the right measurement, avoid augmentation
        if (extra === (isBorderBox ? "border" : "content")) i = 4;
        else i = name === "width" ? 1 : 0;
        for(; i < 4; i += 2){
            // Both box models exclude margin, so add it if we want it
            if (extra === "margin") val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === "content") val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // At this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            } else {
                // At this point, extra isn't content, so add padding
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // At this point, extra isn't content nor padding, so add border
                if (extra !== "padding") val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        // Start with computed style
        var valueIsBorderBox, styles = getStyles(elem), val = curCSS(elem, name, styles), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        // Computed unit is not pixels. Stop here and return.
        if (rnumnonpx.test(val)) return val;
        // Check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox && (support1.boxSizingReliable() || val === elem.style[name]);
        // Fall back to offsetWidth/Height when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        if (val === "auto") val = elem["offset" + name[0].toUpperCase() + name.slice(1)];
        // Normalize "", auto, and prepare for extra
        val = parseFloat(val) || 0;
        // Use the active box-sizing model to add/subtract irrelevant styles
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            "float": "cssFloat"
        },
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) return;
            // Make sure that we're working with the right name
            var ret, type, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;
                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    // Fixes bug #9237
                    type = "number";
                }
                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) return;
                // If a number was passed in, add the unit (except for certain CSS properties)
                if (type === "number") value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                // background-* props affect original clone's values
                if (!support1.clearCloneStyle && value === "" && name.indexOf("background") === 0) style[name] = "inherit";
                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    if (isCustomProp) style.setProperty(name, value);
                    else style[name] = value;
                }
            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) return ret;
                // Otherwise just get the value from the style object
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name);
            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) val = hooks.get(elem, true, extra);
            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) val = curCSS(elem, name, styles);
            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) val = cssNormalTransform[name];
            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        "height",
        "width"
    ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) // Certain elements can have dimension info if we invisibly show them
                // but it must have a current display style that would benefit
                return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, name, extra);
                }) : getWidthOrHeight(elem, name, extra);
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support1.reliableMarginLeft, function(elem, computed) {
        if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
        }, function() {
            return elem.getBoundingClientRect().left;
        })) + "px";
    });
    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {
                }, // Assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [
                    value
                ];
                for(; i < 4; i++)expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    });
    jQuery.fn.extend({
        css: function(name1, value6) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {
                }, i = 0;
                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for(; i < len; i++)map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name1, value6, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            else this.pos = eased = percent;
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) this.options.step.call(this.elem, this.now, this);
            if (hooks && hooks.set) hooks.set(this);
            else Tween.propHooks._default.set(this);
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) return tween.elem[tween.prop];
                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) jQuery.fx.step[tween.prop](tween);
                else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                else tween.elem[tween.prop] = tween.now;
            }
        }
    };
    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) tween.elem[tween.prop] = tween.now;
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    // Back compat <1.8 extension point
    jQuery.fx.step = {
    };
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
        if (inProgress) {
            if (document1.hidden === false && window1.requestAnimationFrame) window1.requestAnimationFrame(schedule);
            else window1.setTimeout(schedule, jQuery.fx.interval);
            jQuery.fx.tick();
        }
    }
    // Animations created synchronously will run synchronously
    function createFxNow() {
        window1.setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for(; i < 4; i += 2 - includeWidth){
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) attrs.opacity = attrs.width = type;
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for(; index < length; index++){
            if (tween = collection[index].call(animation, prop, value)) // We're done with this property
            return tween;
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {
        }, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) oldfire();
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                // Ensure the complete handler is called before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) hooks.empty.fire();
                });
            });
        }
        // Detect show/hide animations
        for(prop in props){
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) hidden = true;
                    else continue;
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) return;
        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {
            // Support: IE <=9 - 11, Edge 12 - 13
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) restoreDisplay = dataPriv.get(elem, "display");
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) display = restoreDisplay;
                else {
                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([
                        elem
                    ], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([
                        elem
                    ]);
                }
            }
            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {
                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function() {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        // Implement show/hide animations
        propTween = false;
        for(prop in orig){
            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) hidden = dataShow.hidden;
                } else dataShow = dataPriv.access(elem, "fxshow", {
                    display: restoreDisplay
                });
                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) dataShow.hidden = !hidden;
                // Show elements before animating them
                if (hidden) showHide([
                    elem
                ], true);
                /* eslint-disable no-loop-func */ anim.done(function() {
                    /* eslint-enable no-loop-func */ // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) showHide([
                        elem
                    ]);
                    dataPriv.remove(elem, "fxshow");
                    for(prop in orig)jQuery.style(elem, prop, orig[prop]);
                });
            }
            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        // camelCase, specialEasing and expand cssHook pass
        for(index in props){
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for(index in value)if (!(index in props)) {
                    props[index] = value[index];
                    specialEasing[index] = easing;
                }
            } else specialEasing[name] = easing;
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index1 = 0, length1 = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            // Don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) return false;
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3 only
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for(; index < length; index++)animation.tweens[index].run(percent);
            deferred.notifyWith(elem, [
                animation,
                percent,
                remaining
            ]);
            // If there's more to do, yield
            if (percent < 1 && length) return remaining;
            // If this was an empty animation, synthesize a final progress notification
            if (!length) deferred.notifyWith(elem, [
                animation,
                1,
                0
            ]);
            // Resolve the animation and report its conclusion
            deferred.resolveWith(elem, [
                animation
            ]);
            return false;
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({
            }, properties),
            opts: jQuery.extend(true, {
                specialEasing: {
                },
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                stopped = true;
                for(; index < length; index++)animation.tweens[index].run(1);
                // Resolve when we played the last frame; otherwise, reject
                if (gotoEnd) {
                    deferred.notifyWith(elem, [
                        animation,
                        1,
                        0
                    ]);
                    deferred.resolveWith(elem, [
                        animation,
                        gotoEnd
                    ]);
                } else deferred.rejectWith(elem, [
                    animation,
                    gotoEnd
                ]);
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for(; index1 < length1; index1++){
            result = Animation.prefilters[index1].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) animation.opts.start.call(elem, animation);
        // Attach callbacks from options
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [
                function(prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }
            ]
        },
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [
                    "*"
                ];
            } else props = props.match(rnothtmlwhite);
            var prop, index = 0, length = props.length;
            for(; index < length; index++){
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [
            defaultPrefilter
        ],
        prefilter: function(callback, prepend) {
            if (prepend) Animation.prefilters.unshift(callback);
            else Animation.prefilters.push(callback);
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({
        }, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        // Go to the end state if fx are off
        if (jQuery.fx.off) opt.duration = 0;
        else if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) opt.duration = jQuery.fx.speeds[opt.duration];
            else opt.duration = jQuery.fx.speeds._default;
        }
        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) opt.queue = "fx";
        // Queueing
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) opt.old.call(this);
            if (opt.queue) jQuery.dequeue(this, opt.queue);
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()// Animate to the value specified
            .end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({
                }, prop), optall);
                // Empty animations, or finishing resolves immediately
                if (empty || dataPriv.get(this, "finish")) anim.stop(true);
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) this.queue(type || "fx", []);
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) stopQueue(data[index]);
                } else {
                    for(index in data)if (data[index] && data[index].stop && rrun.test(index)) stopQueue(data[index]);
                }
                for(index = timers.length; index--;)if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                    timers[index].anim.stop(gotoEnd);
                    dequeue = false;
                    timers.splice(index, 1);
                }
                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            if (type !== false) type = type || "fx";
            return this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                // Enable finishing flag on private data
                data.finish = true;
                // Empty the queue first
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) hooks.stop.call(this, true);
                // Look for any active animations, and finish them
                for(index = timers.length; index--;)if (timers[index].elem === this && timers[index].queue === type) {
                    timers[index].anim.stop(true);
                    timers.splice(index, 1);
                }
                // Look for any animations in the old queue and finish them
                for(index = 0; index < length; index++)if (queue[index] && queue[index].finish) queue[index].finish.call(this);
                // Turn off finishing flag
                delete data.finish;
            });
        }
    });
    jQuery.each([
        "toggle",
        "show",
        "hide"
    ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for(; i < timers.length; i++){
            timer = timers[i];
            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) timers.splice(i--, 1);
        }
        if (!timers.length) jQuery.fx.stop();
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (inProgress) return;
        inProgress = true;
        schedule();
    };
    jQuery.fx.stop = function() {
        inProgress = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };
    // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = window1.setTimeout(next, time);
            hooks.stop = function() {
                window1.clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document1.createElement("input"), select = document1.createElement("select"), opt = select.appendChild(document1.createElement("option"));
        input.type = "checkbox";
        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support1.checkOn = input.value !== "";
        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support1.optSelected = opt.selected;
        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document1.createElement("input");
        input.value = "t";
        input.type = "radio";
        support1.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") return jQuery.prop(elem, name, value);
            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                elem.setAttribute(name, value + "");
                return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            ret = jQuery.find.attr(elem, name);
            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support1.radioValue && value === "radio" && nodeName1(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) elem.value = val;
                        return value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, // Attribute names can contain non-HTML whitespace characters
            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
            attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) while(name = attrNames[i++])elem.removeAttribute(name);
        }
    });
    // Hooks for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) // Remove boolean attributes when set to false
            jQuery.removeAttr(elem, name);
            else elem.setAttribute(name, name);
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name2) {
        var getter = attrHandle[name2] || jQuery.find.attr;
        attrHandle[name2] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    if (tabindex) return parseInt(tabindex, 10);
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) return 0;
                    return -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });
    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support1.optSelected) jQuery.propHooks.selected = {
        get: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent && parent.parentNode) parent.parentNode.selectedIndex;
            return null;
        },
        set: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) parent.parentNode.selectedIndex;
            }
        }
    };
    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    // Strip and collapse whitespace according to HTML spec
    // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j1, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
            if (typeof value === "string" && value) {
                classes = value.match(rnothtmlwhite) || [];
                while(elem = this[i++]){
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                    if (cur) {
                        j1 = 0;
                        while(clazz = classes[j1++])if (cur.indexOf(" " + clazz + " ") < 0) cur += clazz + " ";
                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) elem.setAttribute("class", finalValue);
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j2, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            if (typeof value === "string" && value) {
                classes = value.match(rnothtmlwhite) || [];
                while(elem = this[i++]){
                    curValue = getClass(elem);
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                    if (cur) {
                        j2 = 0;
                        while(clazz = classes[j2++])// Remove *all* instances
                        while(cur.indexOf(" " + clazz + " ") > -1)cur = cur.replace(" " + clazz + " ", " ");
                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) elem.setAttribute("class", finalValue);
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") return stateVal ? this.addClass(value) : this.removeClass(value);
            if (jQuery.isFunction(value)) return this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            });
            return this.each(function() {
                var className, i, self, classNames;
                if (type === "string") {
                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnothtmlwhite) || [];
                    while(className = classNames[i++])// Check each className given, space separated list
                    if (self.hasClass(className)) self.removeClass(className);
                    else self.addClass(className);
                // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) // Store className if set
                    dataPriv.set(this, "__className__", className);
                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                }
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while(elem = this[i++]){
                if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return true;
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value7) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) return ret;
                    ret = elem.value;
                    // Handle most common string cases
                    if (typeof ret === "string") return ret.replace(rreturn, "");
                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value7);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) return;
                if (isFunction) val = value7.call(this, i, jQuery(this).val());
                else val = value7;
                // Treat null/undefined as ""; convert numbers to string
                if (val == null) val = "";
                else if (typeof val === "number") val += "";
                else if (Array.isArray(val)) val = jQuery.map(val, function(value) {
                    return value == null ? "" : value + "";
                });
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) this.value = val;
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : // Support: IE <=10 - 11 only
                    // option.text throws exceptions (#14686, #14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) i = max;
                    else i = one ? index : 0;
                    // Loop through all the selected options
                    for(; i < max; i++){
                        option = options[i];
                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                        !option.disabled && (!option.parentNode.disabled || !nodeName1(option.parentNode, "optgroup"))) {
                            // Get the specific value for the option
                            value = jQuery(option).val();
                            // We don't need an array for one selects
                            if (one) return value;
                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while(i--){
                        option = options[i];
                        /* eslint-disable no-cond-assign */ if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) optionSet = true;
                    /* eslint-enable no-cond-assign */ }
                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) elem.selectedIndex = -1;
                    return values;
                }
            }
        }
    });
    // Radios and checkboxes getter/setter
    jQuery.each([
        "radio",
        "checkbox"
    ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (Array.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
        };
        if (!support1.checkOn) jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
        };
    });
    // Return jQuery for attributes-only inclusion
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [
                elem || document1
            ], type = hasOwn1.call(event, "type") ? event.type : event, namespaces = hasOwn1.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document1;
            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) return;
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) return;
            if (type.indexOf(".") > -1) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) event.target = elem;
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [
                event
            ] : jQuery.makeArray(data, [
                event
            ]);
            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {
            };
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) return;
            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) cur = cur.parentNode;
                for(; cur; cur = cur.parentNode){
                    eventPath.push(cur);
                    tmp = cur;
                }
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document1)) eventPath.push(tmp.defaultView || tmp.parentWindow || window1);
            }
            // Fire handlers on the event path
            i = 0;
            while((cur = eventPath[i++]) && !event.isPropagationStopped()){
                event.type = i > 1 ? bubbleType : special.bindType || type;
                // jQuery handler
                handle = (dataPriv.get(cur, "events") || {
                })[event.type] && dataPriv.get(cur, "handle");
                if (handle) handle.apply(cur, data);
                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) event.preventDefault();
                }
            }
            event.type = type;
            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) // Call a native DOM method on the target with the same name as the event.
                // Don't do default actions on window, that's where global variables be (#6170)
                {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];
                        if (tmp) elem[ontype] = null;
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) elem[ontype] = tmp;
                    }
                }
            }
            return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) return jQuery.event.trigger(type, data, elem, true);
        }
    });
    jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(i, name) {
        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    support1.focusin = "onfocusin" in window1;
    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support1.focusin) jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) doc.addEventListener(orig, handler, true);
                dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                    doc.removeEventListener(orig, handler, true);
                    dataPriv.remove(doc, fix);
                } else dataPriv.access(doc, fix, attaches);
            }
        };
    });
    var location = window1.location;
    var nonce = jQuery.now();
    var rquery = /\?/;
    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || typeof data !== "string") return null;
        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = new window1.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) jQuery.error("Invalid XML: " + data);
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) // Serialize array item.
        jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) // Treat each array item as a scalar.
            add(prefix, v);
            else // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        });
        else if (!traditional && jQuery.type(obj) === "object") // Serialize object item.
        for(name in obj)buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        else // Serialize scalar item.
        add(prefix, obj);
    }
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            // If value is a function, invoke it and use its return value
            var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) // Serialize the form elements
        jQuery.each(a, function() {
            add(this.name, this.value);
        });
        else // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for(prefix in a)buildParams(prefix, a[prefix], traditional, add);
        // Return the resulting serialization
        return s.join("&");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val1 = jQuery(this).val();
                if (val1 == null) return null;
                if (Array.isArray(val1)) return jQuery.map(val1, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                });
                return {
                    name: elem.name,
                    value: val1.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */ prefilters = {
    }, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */ transports = {
    }, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"), // Anchor tag for parsing the document origin
    originAnchor = document1.createElement("a");
    originAnchor.href = location.href;
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while(dataType = dataTypes[i++])// Prepend if requested
                if (dataType[0] === "+") {
                    dataType = dataType.slice(1) || "*";
                    (structure[dataType] = structure[dataType] || []).unshift(func);
                // Otherwise append
                } else (structure[dataType] = structure[dataType] || []).push(func);
            }
        };
    }
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {
        }, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) return !(selected = dataTypeOrTransport);
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {
        };
        for(key in src)if (src[key] !== undefined) (flatOptions[key] ? target : deep || (deep = {
        }))[key] = src[key];
        if (deep) jQuery.extend(true, target, deep);
        return target;
    }
    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */ function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        // Remove auto dataType and get content-type in the process
        while(dataTypes[0] === "*"){
            dataTypes.shift();
            if (ct === undefined) ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
        // Check if we're dealing with a known content-type
        if (ct) {
            for(type in contents)if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
            }
        }
        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) finalDataType = dataTypes[0];
        else {
            // Try convertible dataTypes
            for(type in responses){
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) firstDataType = type;
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) dataTypes.unshift(finalDataType);
            return responses[finalDataType];
        }
    }
    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */ function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {
        }, // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();
        // Create converters map with lowercased keys
        if (dataTypes[1]) for(conv in s.converters)converters[conv.toLowerCase()] = s.converters[conv];
        current = dataTypes.shift();
        // Convert to each sequential dataType
        while(current){
            if (s.responseFields[current]) jqXHR[s.responseFields[current]] = response;
            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) response = s.dataFilter(response, s.dataType);
            prev = current;
            current = dataTypes.shift();
            if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === "*") current = prev;
                else if (prev !== "*" && prev !== current) {
                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];
                    // If none found, seek a pair
                    if (!conv) for(conv2 in converters){
                        // If conv2 outputs current
                        tmp = conv2.split(" ");
                        if (tmp[1] === current) {
                            // If prev can be converted to accepted input
                            conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                            if (conv) {
                                // Condense equivalence converters
                                if (conv === true) conv = converters[conv2];
                                else if (converters[conv2] !== true) {
                                    current = tmp[0];
                                    dataTypes.unshift(tmp[1]);
                                }
                                break;
                            }
                        }
                    }
                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) response = conv(response);
                        else try {
                            response = conv(response);
                        } catch (e) {
                            return {
                                state: "parsererror",
                                error: conv ? e : "No conversion from " + prev + " to " + current
                            };
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {
        },
        etag: {
        },
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/ accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": JSON.parse,
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            return settings ? // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            // Force options to be an object
            options = options || {
            };
            var transport, // URL without anti-cache param
            cacheURL, // Response headers
            responseHeadersString, responseHeaders, // timeout handle
            timeoutTimer, // Url cleanup var
            urlAnchor, // Request state (becomes false upon send and true upon completion)
            completed, // To know if global events are to be dispatched
            fireGlobals, // Loop variable
            i, // uncached part of the url
            uncached, // Create the final options object
            s = jQuery.ajaxSetup({
            }, options), // Callbacks context
            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds
            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), // Status-dependent callbacks
            statusCode = s.statusCode || {
            }, // Headers (they are sent all at once)
            requestHeaders = {
            }, requestHeadersNames = {
            }, // Default abort message
            strAbort = "canceled", // Fake xhr
            jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) {
                            responseHeaders = {
                            };
                            while(match = rheaders.exec(responseHeadersString))responseHeaders[match[1].toLowerCase()] = match[2];
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                // Raw string
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                    if (completed == null) {
                        name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                    if (completed == null) s.mimeType = type;
                    return this;
                },
                // Status-dependent callbacks
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (completed) // Execute the appropriate callbacks
                        jqXHR.always(map[jqXHR.status]);
                        else // Lazy-add the new callbacks in a way that preserves old ones
                        for(code in map)statusCode[code] = [
                            statusCode[code],
                            map[code]
                        ];
                    }
                    return this;
                },
                // Cancel the request
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) transport.abort(finalText);
                    done(0, finalText);
                    return this;
                }
            };
            // Attach deferreds
            deferred.promise(jqXHR);
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;
            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [
                ""
            ];
            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document1.createElement("a");
                // Support: IE <=8 - 11, Edge 12 - 13
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;
                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }
            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") s.data = jQuery.param(s.data, s.traditional);
            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            // If request was aborted inside a prefilter, stop there
            if (completed) return jqXHR;
            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;
            // Watch for a new set of requests
            if (fireGlobals && (jQuery.active++) === 0) jQuery.event.trigger("ajaxStart");
            // Uppercase the type
            s.type = s.type.toUpperCase();
            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);
            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");
            // More options handling for requests with no content
            if (!s.hasContent) {
                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);
                // If data is available, append data to url
                if (s.data) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
                }
                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;
            // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) s.data = s.data.replace(r20, "+");
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                if (jQuery.etag[cacheURL]) jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) jqXHR.setRequestHeader("Content-Type", s.contentType);
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            // Check for headers option
            for(i in s.headers)jqXHR.setRequestHeader(i, s.headers[i]);
            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) // Abort if not done already and return
            return jqXHR.abort();
            // Aborting is no longer a cancellation
            strAbort = "abort";
            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            // If no transport, we auto-abort
            if (!transport) done(-1, "No Transport");
            else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) globalEventContext.trigger("ajaxSend", [
                    jqXHR,
                    s
                ]);
                // If request was aborted inside ajaxSend, stop there
                if (completed) return jqXHR;
                // Timeout
                if (s.async && s.timeout > 0) timeoutTimer = window1.setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout);
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Rethrow post-completion exceptions
                    if (completed) throw e;
                    // Propagate others as results
                    done(-1, e);
                }
            }
            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                // Ignore repeat invocations
                if (completed) return;
                completed = true;
                // Clear timeout if it exists
                if (timeoutTimer) window1.clearTimeout(timeoutTimer);
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
                // Cache response headers
                responseHeadersString = headers || "";
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;
                // Get response data
                if (responses) response = ajaxHandleResponses(s, jqXHR, responses);
                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                // If successful, handle type chaining
                if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) jQuery.lastModified[cacheURL] = modified;
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) jQuery.etag[cacheURL] = modified;
                    }
                    // if no content
                    if (status === 204 || s.type === "HEAD") statusText = "nocontent";
                    else if (status === 304) statusText = "notmodified";
                    else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) status = 0;
                    }
                }
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                // Success/Error
                if (isSuccess) deferred.resolveWith(callbackContext, [
                    success,
                    statusText,
                    jqXHR
                ]);
                else deferred.rejectWith(callbackContext, [
                    jqXHR,
                    statusText,
                    error
                ]);
                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
                    jqXHR,
                    s,
                    isSuccess ? success : error
                ]);
                // Complete
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [
                        jqXHR,
                        s
                    ]);
                    // Handle the global AJAX counter
                    if (!--jQuery.active) jQuery.event.trigger("ajaxStop");
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([
        "get",
        "post"
    ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // Shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (this[0]) {
                if (jQuery.isFunction(html)) html = html.call(this[0]);
                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) wrap.insertBefore(this[0]);
                wrap.map(function() {
                    var elem = this;
                    while(elem.firstElementChild)elem = elem.firstElementChild;
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) return this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            });
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) contents.wrapAll(html);
                else self.append(html);
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window1.XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support1.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support1.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        // Cross domain only allowed if supported through XMLHttpRequest
        if (support1.cors || xhrSupported && !options.crossDomain) return {
            send: function(headers, complete) {
                var i, xhr = options.xhr();
                xhr.open(options.type, options.url, options.async, options.username, options.password);
                // Apply custom fields if provided
                if (options.xhrFields) for(i in options.xhrFields)xhr[i] = options.xhrFields[i];
                // Override mime type if needed
                if (options.mimeType && xhr.overrideMimeType) xhr.overrideMimeType(options.mimeType);
                // X-Requested-With header
                // For cross-domain requests, seeing as conditions for a preflight are
                // akin to a jigsaw puzzle, we simply never set it to be sure.
                // (it can always be set on a per-request basis or even using ajaxSetup)
                // For same-domain requests, won't change header if already provided.
                if (!options.crossDomain && !headers["X-Requested-With"]) headers["X-Requested-With"] = "XMLHttpRequest";
                // Set headers
                for(i in headers)xhr.setRequestHeader(i, headers[i]);
                // Callback
                callback = function(type) {
                    return function() {
                        if (callback) {
                            callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                            if (type === "abort") xhr.abort();
                            else if (type === "error") {
                                // Support: IE <=9 only
                                // On a manual native abort, IE9 throws
                                // errors on any property access that is not readyState
                                if (typeof xhr.status !== "number") complete(0, "error");
                                else complete(// File: protocol always yields status 0; see #8605, #14207
                                xhr.status, xhr.statusText);
                            } else complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                binary: xhr.response
                            } : {
                                text: xhr.responseText
                            }, xhr.getAllResponseHeaders());
                        }
                    };
                };
                // Listen to events
                xhr.onload = callback();
                errorCallback = xhr.onerror = callback("error");
                // Support: IE 9 only
                // Use onreadystatechange to replace onabort
                // to handle uncaught aborts
                if (xhr.onabort !== undefined) xhr.onabort = errorCallback;
                else xhr.onreadystatechange = function() {
                    // Check readyState before timeout as it changes
                    if (xhr.readyState === 4) // Allow onerror to be called first,
                    // but that will not handle a native abort
                    // Also, save errorCallback to a variable
                    // as xhr.onerror cannot be accessed
                    window1.setTimeout(function() {
                        if (callback) errorCallback();
                    });
                };
                // Create the abort callback
                callback = callback("abort");
                try {
                    // Do send the request (this may raise an exception)
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    // #14683: Only rethrow if this hasn't been notified as an error yet
                    if (callback) throw e;
                }
            },
            abort: function() {
                if (callback) callback();
            }
        };
    });
    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function(s) {
        if (s.crossDomain) s.contents.script = false;
    });
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) s.cache = false;
        if (s.crossDomain) s.type = "GET";
    });
    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {
        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) complete(evt.type === "error" ? 404 : 200, evt.type);
                    });
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document1.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            // Insert callback into url or form data
            if (jsonProp) s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            else if (s.jsonp !== false) s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) jQuery.error(callbackName + " was not called");
                return responseContainer[0];
            };
            // Force json dataType
            s.dataTypes[0] = "json";
            // Install callback
            overwritten = window1[callbackName];
            window1[callbackName] = function() {
                responseContainer = arguments;
            };
            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // If previous value didn't exist - remove it
                if (overwritten === undefined) jQuery(window1).removeProp(callbackName);
                else window1[callbackName] = overwritten;
                // Save back as free
                if (s[callbackName]) {
                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) overwritten(responseContainer[0]);
                responseContainer = overwritten = undefined;
            });
            // Delegate to script
            return "script";
        }
    });
    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support1.createHTMLDocument = (function() {
        var body = document1.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    })();
    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") return [];
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support1.createHTMLDocument) {
                context = document1.implementation.createHTMLDocument("");
                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document1.location.href;
                context.head.appendChild(base);
            } else context = document1;
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        // Single tag
        if (parsed) return [
            context.createElement(parsed[1])
        ];
        parsed = buildFragment([
            data
        ], context, scripts);
        if (scripts && scripts.length) jQuery(scripts).remove();
        return jQuery.merge([], parsed.childNodes);
    };
    /**
 * Load a url into a page
 */ jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        // If it's a function
        if (jQuery.isFunction(params)) {
            // We assume that it's the callback
            callback = params;
            params = undefined;
        // Otherwise, build a param string
        } else if (params && typeof params === "object") type = "POST";
        // If we have elements to modify, make the request
        if (self.length > 0) jQuery.ajax({
            url: url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            // Save response for use in complete callback
            response = arguments;
            self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
            responseText);
        // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        });
        return this;
    };
    // Attach a bunch of functions for handling common AJAX events
    jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {
            };
            // Set position first, in-case top/left are set even on static elem
            if (position === "static") elem.style.position = "relative";
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
            options = options.call(elem, i, jQuery.extend({
            }, curOffset));
            if (options.top != null) props.top = options.top - curOffset.top + curTop;
            if (options.left != null) props.left = options.left - curOffset.left + curLeft;
            if ("using" in options) options.using.call(elem, props);
            else curElem.css(props);
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            // Preserve chaining for setter
            if (arguments.length) return options === undefined ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var doc, docElem, rect, win, elem = this[0];
            if (!elem) return;
            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) return {
                top: 0,
                left: 0
            };
            rect = elem.getBoundingClientRect();
            doc = elem.ownerDocument;
            docElem = doc.documentElement;
            win = doc.defaultView;
            return {
                top: rect.top + win.pageYOffset - docElem.clientTop,
                left: rect.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) return;
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
            // because it is its only offset parent
            if (jQuery.css(elem, "position") === "fixed") // Assume getBoundingClientRect is there when computed position is fixed
            offset = elem.getBoundingClientRect();
            else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();
                // Get correct offsets
                offset = this.offset();
                if (!nodeName1(offsetParent[0], "html")) parentOffset = offsetParent.offset();
                // Add offsetParent borders
                parentOffset = {
                    top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
                    left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
                };
            }
            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;
                while(offsetParent && jQuery.css(offsetParent, "position") === "static")offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement1;
            });
        }
    });
    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val2) {
            return access(this, function(elem, method, val) {
                // Coalesce documents and windows
                var win;
                if (jQuery.isWindow(elem)) win = elem;
                else if (elem.nodeType === 9) win = elem.defaultView;
                if (val === undefined) return win ? win[prop] : elem[method];
                if (win) win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                else elem[method] = val;
            }, method, val2, arguments.length);
        };
    });
    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each([
        "top",
        "left"
    ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support1.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // If curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type1) {
        jQuery.each({
            padding: "inner" + name,
            content: type1,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value8) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value8 === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                    return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type, extra) : // Set width or height on the element
                    jQuery.style(elem, type, value, extra);
                }, type1, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    jQuery.holdReady = function(hold) {
        if (hold) jQuery.readyWait++;
        else jQuery.ready(true);
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName1;
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    if (typeof define === "function" && define.amd) define("jquery", [], function() {
        return jQuery;
    });
    var // Map over jQuery in case of overwrite
    _jQuery = window1.jQuery, // Map over the $ in case of overwrite
    _$ = window1.$;
    jQuery.noConflict = function(deep) {
        if (window1.$ === jQuery) window1.$ = _$;
        if (deep && window1.jQuery === jQuery) window1.jQuery = _jQuery;
        return jQuery;
    };
    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (!noGlobal) window1.jQuery = window1.$ = jQuery;
    return jQuery;
});

},{}],"fv5p1":[function(require,module,exports) {
var global = arguments[3];
/*!
 * Materialize v1.0.0 (http://materializecss.com)
 * Copyright 2014-2017 Materialize
 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
 */ var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) return undefined;
        else return get(parent, property, receiver);
    } else if ("value" in desc) return desc.value;
    else {
        var getter = desc.get;
        if (getter === undefined) return undefined;
        return getter.call(receiver);
    }
};
var _createClass = function() {
    function defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
function _possibleConstructorReturn(self, call) {
    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
/*! cash-dom 1.3.5, https://github.com/kenwheeler/cash @license MIT */ (function(factory) {
    window.cash = factory();
})(function() {
    var doc1 = document, win = window, ArrayProto = Array.prototype, slice = ArrayProto.slice, filter = ArrayProto.filter, push = ArrayProto.push;
    var noop = function() {
    }, isFunction = function(item) {
        // @see https://crbug.com/568448
        return typeof item === typeof noop && item.call;
    }, isString = function(item) {
        return typeof item === "string";
    };
    var idMatch = /^#[\w-]*$/, classMatch = /^\.[\w-]*$/, htmlMatch = /<.+>/, singlet = /^\w+$/;
    function find(selector, context) {
        context = context || doc1;
        var elems = classMatch.test(selector) ? context.getElementsByClassName(selector.slice(1)) : singlet.test(selector) ? context.getElementsByTagName(selector) : context.querySelectorAll(selector);
        return elems;
    }
    var frag;
    function parseHTML(str) {
        if (!frag) {
            frag = doc1.implementation.createHTMLDocument(null);
            var base = frag.createElement("base");
            base.href = doc1.location.href;
            frag.head.appendChild(base);
        }
        frag.body.innerHTML = str;
        return frag.body.childNodes;
    }
    function onReady(fn) {
        if (doc1.readyState !== "loading") fn();
        else doc1.addEventListener("DOMContentLoaded", fn);
    }
    function Init(selector, context) {
        if (!selector) return this;
        // If already a cash collection, don't do any further processing
        if (selector.cash && selector !== win) return selector;
        var elems = selector, i = 0, length;
        if (isString(selector)) elems = idMatch.test(selector) ? // If an ID use the faster getElementById check
        doc1.getElementById(selector.slice(1)) : htmlMatch.test(selector) ? // If HTML, parse it into real elements
        parseHTML(selector) : // else use `find`
        find(selector, context);
        else if (isFunction(selector)) {
            onReady(selector);
            return this;
        }
        if (!elems) return this;
        // If a single DOM element is passed in or received via ID, return the single element
        if (elems.nodeType || elems === win) {
            this[0] = elems;
            this.length = 1;
        } else {
            // Treat like an array and loop through each item.
            length = this.length = elems.length;
            for(; i < length; i++)this[i] = elems[i];
        }
        return this;
    }
    function cash(selector, context) {
        return new Init(selector, context);
    }
    var fn1 = cash.fn = cash.prototype = Init.prototype = {
        cash: true,
        length: 0,
        push: push,
        splice: ArrayProto.splice,
        map: ArrayProto.map,
        init: Init
    };
    Object.defineProperty(fn1, "constructor", {
        value: cash
    });
    cash.parseHTML = parseHTML;
    cash.noop = noop;
    cash.isFunction = isFunction;
    cash.isString = isString;
    cash.extend = fn1.extend = function(target) {
        target = target || {
        };
        var args = slice.call(arguments), length = args.length, i = 1;
        if (args.length === 1) {
            target = this;
            i = 0;
        }
        for(; i < length; i++){
            if (!args[i]) continue;
            for(var key in args[i])if (args[i].hasOwnProperty(key)) target[key] = args[i][key];
        }
        return target;
    };
    function each(collection, callback) {
        var l = collection.length, i = 0;
        for(; i < l; i++){
            if (callback.call(collection[i], collection[i], i, collection) === false) break;
        }
    }
    function matches(el, selector) {
        var m = el && (el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector || el.oMatchesSelector);
        return !!m && m.call(el, selector);
    }
    function getCompareFunction(selector1) {
        return(/* Use browser's `matches` function if string */ isString(selector1) ? matches : /* Match a cash element */ selector1.cash ? function(el) {
            return selector1.is(el);
        } : /* Direct comparison */ function(el, selector) {
            return el === selector;
        });
    }
    function unique(collection) {
        return cash(slice.call(collection).filter(function(item, index, self) {
            return self.indexOf(item) === index;
        }));
    }
    cash.extend({
        merge: function(first, second) {
            var len = +second.length, i = first.length, j = 0;
            for(; j < len; i++, j++)first[i] = second[j];
            first.length = i;
            return first;
        },
        each: each,
        matches: matches,
        unique: unique,
        isArray: Array.isArray,
        isNumeric: function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
    });
    var uid = cash.uid = "_cash" + Date.now();
    function getDataCache(node) {
        return node[uid] = node[uid] || {
        };
    }
    function setData(node, key, value) {
        return getDataCache(node)[key] = value;
    }
    function getData(node, key) {
        var c = getDataCache(node);
        if (c[key] === undefined) c[key] = node.dataset ? node.dataset[key] : cash(node).attr("data-" + key);
        return c[key];
    }
    function removeData(node, key) {
        var c = getDataCache(node);
        if (c) delete c[key];
        else if (node.dataset) delete node.dataset[key];
        else cash(node).removeAttr("data-" + name);
    }
    fn1.extend({
        data: function(name, value) {
            if (isString(name)) return value === undefined ? getData(this[0], name) : this.each(function(v) {
                return setData(v, name, value);
            });
            for(var key in name)this.data(key, name[key]);
            return this;
        },
        removeData: function(key) {
            return this.each(function(v) {
                return removeData(v, key);
            });
        }
    });
    var notWhiteMatch = /\S+/g;
    function getClasses(c) {
        return isString(c) && c.match(notWhiteMatch);
    }
    function hasClass(v, c) {
        return v.classList ? v.classList.contains(c) : new RegExp("(^| )" + c + "( |$)", "gi").test(v.className);
    }
    function addClass(v, c, spacedName) {
        if (v.classList) v.classList.add(c);
        else if (spacedName.indexOf(" " + c + " ")) v.className += " " + c;
    }
    function removeClass(v, c) {
        if (v.classList) v.classList.remove(c);
        else v.className = v.className.replace(c, "");
    }
    fn1.extend({
        addClass: function(c1) {
            var classes = getClasses(c1);
            return classes ? this.each(function(v) {
                var spacedName = " " + v.className + " ";
                each(classes, function(c) {
                    addClass(v, c, spacedName);
                });
            }) : this;
        },
        attr: function(name, value) {
            if (!name) return undefined;
            if (isString(name)) {
                if (value === undefined) return this[0] ? this[0].getAttribute ? this[0].getAttribute(name) : this[0][name] : undefined;
                return this.each(function(v) {
                    if (v.setAttribute) v.setAttribute(name, value);
                    else v[name] = value;
                });
            }
            for(var key in name)this.attr(key, name[key]);
            return this;
        },
        hasClass: function(c) {
            var check = false, classes = getClasses(c);
            if (classes && classes.length) this.each(function(v) {
                check = hasClass(v, classes[0]);
                return !check;
            });
            return check;
        },
        prop: function(name, value) {
            if (isString(name)) return value === undefined ? this[0][name] : this.each(function(v) {
                v[name] = value;
            });
            for(var key in name)this.prop(key, name[key]);
            return this;
        },
        removeAttr: function(name) {
            return this.each(function(v) {
                if (v.removeAttribute) v.removeAttribute(name);
                else delete v[name];
            });
        },
        removeClass: function(c2) {
            if (!arguments.length) return this.attr("class", "");
            var classes = getClasses(c2);
            return classes ? this.each(function(v) {
                each(classes, function(c) {
                    removeClass(v, c);
                });
            }) : this;
        },
        removeProp: function(name) {
            return this.each(function(v) {
                delete v[name];
            });
        },
        toggleClass: function(c3, state) {
            if (state !== undefined) return this[state ? "addClass" : "removeClass"](c3);
            var classes = getClasses(c3);
            return classes ? this.each(function(v) {
                var spacedName = " " + v.className + " ";
                each(classes, function(c) {
                    if (hasClass(v, c)) removeClass(v, c);
                    else addClass(v, c, spacedName);
                });
            }) : this;
        }
    });
    fn1.extend({
        add: function(selector, context) {
            return unique(cash.merge(this, cash(selector, context)));
        },
        each: function(callback) {
            each(this, callback);
            return this;
        },
        eq: function(index) {
            return cash(this.get(index));
        },
        filter: function(selector) {
            if (!selector) return this;
            var comparator = isFunction(selector) ? selector : getCompareFunction(selector);
            return cash(filter.call(this, function(e) {
                return comparator(e, selector);
            }));
        },
        first: function() {
            return this.eq(0);
        },
        get: function(index) {
            if (index === undefined) return slice.call(this);
            return index < 0 ? this[index + this.length] : this[index];
        },
        index: function(elem) {
            var child = elem ? cash(elem)[0] : this[0], collection = elem ? this : cash(child).parent().children();
            return slice.call(collection).indexOf(child);
        },
        last: function() {
            return this.eq(-1);
        }
    });
    var camelCase = function() {
        var camelRegex = /(?:^\w|[A-Z]|\b\w)/g, whiteSpace = /[\s-_]+/g;
        return function(str) {
            return str.replace(camelRegex, function(letter, index) {
                return letter[index === 0 ? "toLowerCase" : "toUpperCase"]();
            }).replace(whiteSpace, "");
        };
    }();
    var getPrefixedProp = function() {
        var cache = {
        }, doc = document, div = doc.createElement("div"), style = div.style;
        return function(prop) {
            prop = camelCase(prop);
            if (cache[prop]) return cache[prop];
            var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1), prefixes = [
                "webkit",
                "moz",
                "ms",
                "o"
            ], props = (prop + " " + prefixes.join(ucProp + " ") + ucProp).split(" ");
            each(props, function(p) {
                if (p in style) {
                    cache[p] = prop = cache[prop] = p;
                    return false;
                }
            });
            return cache[prop];
        };
    }();
    cash.prefixedProp = getPrefixedProp;
    cash.camelCase = camelCase;
    fn1.extend({
        css: function(prop, value) {
            if (isString(prop)) {
                prop = getPrefixedProp(prop);
                return arguments.length > 1 ? this.each(function(v) {
                    return v.style[prop] = value;
                }) : win.getComputedStyle(this[0])[prop];
            }
            for(var key in prop)this.css(key, prop[key]);
            return this;
        }
    });
    function compute(el, prop) {
        return parseInt(win.getComputedStyle(el[0], null)[prop], 10) || 0;
    }
    each([
        "Width",
        "Height"
    ], function(v) {
        var lower = v.toLowerCase();
        fn1[lower] = function() {
            return this[0].getBoundingClientRect()[lower];
        };
        fn1["inner" + v] = function() {
            return this[0]["client" + v];
        };
        fn1["outer" + v] = function(margins) {
            return this[0]["offset" + v] + (margins ? compute(this, "margin" + (v === "Width" ? "Left" : "Top")) + compute(this, "margin" + (v === "Width" ? "Right" : "Bottom")) : 0);
        };
    });
    function registerEvent(node, eventName, callback) {
        var eventCache = getData(node, "_cashEvents") || setData(node, "_cashEvents", {
        });
        eventCache[eventName] = eventCache[eventName] || [];
        eventCache[eventName].push(callback);
        node.addEventListener(eventName, callback);
    }
    function removeEvent(node, eventName, callback) {
        var events = getData(node, "_cashEvents"), eventCache = events && events[eventName], index;
        if (!eventCache) return;
        if (callback) {
            node.removeEventListener(eventName, callback);
            index = eventCache.indexOf(callback);
            if (index >= 0) eventCache.splice(index, 1);
        } else {
            each(eventCache, function(event) {
                node.removeEventListener(eventName, event);
            });
            eventCache = [];
        }
    }
    fn1.extend({
        off: function(eventName, callback) {
            return this.each(function(v) {
                return removeEvent(v, eventName, callback);
            });
        },
        on: function(eventName, delegate, callback, runOnce) {
            // jshint ignore:line
            var originalCallback;
            if (!isString(eventName)) {
                for(var key in eventName)this.on(key, delegate, eventName[key]);
                return this;
            }
            if (isFunction(delegate)) {
                callback = delegate;
                delegate = null;
            }
            if (eventName === "ready") {
                onReady(callback);
                return this;
            }
            if (delegate) {
                originalCallback = callback;
                callback = function(e) {
                    var t = e.target;
                    while(!matches(t, delegate)){
                        if (t === this || t === null) return t = false;
                        t = t.parentNode;
                    }
                    if (t) originalCallback.call(t, e);
                };
            }
            return this.each(function(v) {
                var finalCallback = callback;
                if (runOnce) finalCallback = function() {
                    callback.apply(this, arguments);
                    removeEvent(v, eventName, finalCallback);
                };
                registerEvent(v, eventName, finalCallback);
            });
        },
        one: function(eventName, delegate, callback) {
            return this.on(eventName, delegate, callback, true);
        },
        ready: onReady,
        /**
     * Modified
     * Triggers browser event
     * @param String eventName
     * @param Object data - Add properties to event object
     */ trigger: function(eventName, data) {
            if (document.createEvent) {
                var evt = document.createEvent('HTMLEvents');
                evt.initEvent(eventName, true, false);
                evt = this.extend(evt, data);
                return this.each(function(v) {
                    return v.dispatchEvent(evt);
                });
            }
        }
    });
    function encode(name, value) {
        return "&" + encodeURIComponent(name) + "=" + encodeURIComponent(value).replace(/%20/g, "+");
    }
    function getSelectMultiple_(el) {
        var values = [];
        each(el.options, function(o) {
            if (o.selected) values.push(o.value);
        });
        return values.length ? values : null;
    }
    function getSelectSingle_(el) {
        var selectedIndex = el.selectedIndex;
        return selectedIndex >= 0 ? el.options[selectedIndex].value : null;
    }
    function getValue(el) {
        var type = el.type;
        if (!type) return null;
        switch(type.toLowerCase()){
            case "select-one":
                return getSelectSingle_(el);
            case "select-multiple":
                return getSelectMultiple_(el);
            case "radio":
                return el.checked ? el.value : null;
            case "checkbox":
                return el.checked ? el.value : null;
            default:
                return el.value ? el.value : null;
        }
    }
    fn1.extend({
        serialize: function() {
            var query = "";
            each(this[0].elements || this, function(el) {
                if (el.disabled || el.tagName === "FIELDSET") return;
                var name = el.name;
                switch(el.type.toLowerCase()){
                    case "file":
                    case "reset":
                    case "submit":
                    case "button":
                        break;
                    case "select-multiple":
                        var values = getValue(el);
                        if (values !== null) each(values, function(value) {
                            query += encode(name, value);
                        });
                        break;
                    default:
                        var value1 = getValue(el);
                        if (value1 !== null) query += encode(name, value1);
                }
            });
            return query.substr(1);
        },
        val: function(value) {
            if (value === undefined) return getValue(this[0]);
            return this.each(function(v) {
                return v.value = value;
            });
        }
    });
    function insertElement(el, child, prepend) {
        if (prepend) {
            var first = el.childNodes[0];
            el.insertBefore(child, first);
        } else el.appendChild(child);
    }
    function insertContent(parent, child, prepend) {
        var str = isString(child);
        if (!str && child.length) {
            each(child, function(v) {
                return insertContent(parent, v, prepend);
            });
            return;
        }
        each(parent, str ? function(v) {
            return v.insertAdjacentHTML(prepend ? "afterbegin" : "beforeend", child);
        } : function(v, i) {
            return insertElement(v, i === 0 ? child : child.cloneNode(true), prepend);
        });
    }
    fn1.extend({
        after: function(selector) {
            cash(selector).insertAfter(this);
            return this;
        },
        append: function(content) {
            insertContent(this, content);
            return this;
        },
        appendTo: function(parent) {
            insertContent(cash(parent), this);
            return this;
        },
        before: function(selector) {
            cash(selector).insertBefore(this);
            return this;
        },
        clone: function() {
            return cash(this.map(function(v) {
                return v.cloneNode(true);
            }));
        },
        empty: function() {
            this.html("");
            return this;
        },
        html: function(content) {
            if (content === undefined) return this[0].innerHTML;
            var source = content.nodeType ? content[0].outerHTML : content;
            return this.each(function(v) {
                return v.innerHTML = source;
            });
        },
        insertAfter: function(selector) {
            var _this = this;
            cash(selector).each(function(el, i) {
                var parent = el.parentNode, sibling = el.nextSibling;
                _this.each(function(v) {
                    parent.insertBefore(i === 0 ? v : v.cloneNode(true), sibling);
                });
            });
            return this;
        },
        insertBefore: function(selector) {
            var _this2 = this;
            cash(selector).each(function(el, i) {
                var parent = el.parentNode;
                _this2.each(function(v) {
                    parent.insertBefore(i === 0 ? v : v.cloneNode(true), el);
                });
            });
            return this;
        },
        prepend: function(content) {
            insertContent(this, content, true);
            return this;
        },
        prependTo: function(parent) {
            insertContent(cash(parent), this, true);
            return this;
        },
        remove: function() {
            return this.each(function(v) {
                if (!!v.parentNode) return v.parentNode.removeChild(v);
            });
        },
        text: function(content) {
            if (content === undefined) return this[0].textContent;
            return this.each(function(v) {
                return v.textContent = content;
            });
        }
    });
    var docEl = doc1.documentElement;
    fn1.extend({
        position: function() {
            var el = this[0];
            return {
                left: el.offsetLeft,
                top: el.offsetTop
            };
        },
        offset: function() {
            var rect = this[0].getBoundingClientRect();
            return {
                top: rect.top + win.pageYOffset - docEl.clientTop,
                left: rect.left + win.pageXOffset - docEl.clientLeft
            };
        },
        offsetParent: function() {
            return cash(this[0].offsetParent);
        }
    });
    fn1.extend({
        children: function(selector) {
            var elems = [];
            this.each(function(el) {
                push.apply(elems, el.children);
            });
            elems = unique(elems);
            return !selector ? elems : elems.filter(function(v) {
                return matches(v, selector);
            });
        },
        closest: function(selector) {
            if (!selector || this.length < 1) return cash();
            if (this.is(selector)) return this.filter(selector);
            return this.parent().closest(selector);
        },
        is: function(selector) {
            if (!selector) return false;
            var match = false, comparator = getCompareFunction(selector);
            this.each(function(el) {
                match = comparator(el, selector);
                return !match;
            });
            return match;
        },
        find: function(selector) {
            if (!selector || selector.nodeType) return cash(selector && this.has(selector).length ? selector : null);
            var elems = [];
            this.each(function(el) {
                push.apply(elems, find(selector, el));
            });
            return unique(elems);
        },
        has: function(selector) {
            var comparator = isString(selector) ? function(el) {
                return find(selector, el).length !== 0;
            } : function(el) {
                return el.contains(selector);
            };
            return this.filter(comparator);
        },
        next: function() {
            return cash(this[0].nextElementSibling);
        },
        not: function(selector) {
            if (!selector) return this;
            var comparator = getCompareFunction(selector);
            return this.filter(function(el) {
                return !comparator(el, selector);
            });
        },
        parent: function() {
            var result = [];
            this.each(function(item) {
                if (item && item.parentNode) result.push(item.parentNode);
            });
            return unique(result);
        },
        parents: function(selector) {
            var last, result = [];
            this.each(function(item) {
                last = item;
                while(last && last.parentNode && last !== doc1.body.parentNode){
                    last = last.parentNode;
                    if (!selector || selector && matches(last, selector)) result.push(last);
                }
            });
            return unique(result);
        },
        prev: function() {
            return cash(this[0].previousElementSibling);
        },
        siblings: function(selector) {
            var collection = this.parent().children(selector), el = this[0];
            return collection.filter(function(i) {
                return i !== el;
            });
        }
    });
    return cash;
});
var Component = function() {
    /**
   * Generic constructor for all components
   * @constructor
   * @param {Element} el
   * @param {Object} options
   */ function Component1(classDef, el, options) {
        _classCallCheck(this, Component1);
        // Display error if el is valid HTML Element
        if (!(el instanceof Element)) console.error(Error(el + ' is not an HTML Element'));
        // If exists, destroy and reinitialize in child
        var ins = classDef.getInstance(el);
        if (!!ins) ins.destroy();
        this.el = el;
        this.$el = cash(el);
    }
    /**
   * Initializes components
   * @param {class} classDef
   * @param {Element | NodeList | jQuery} els
   * @param {Object} options
   */ _createClass(Component1, null, [
        {
            key: "init",
            value: function init(classDef, els, options) {
                var instances = null;
                if (els instanceof Element) instances = new classDef(els, options);
                else if (!!els && (els.jquery || els.cash || els instanceof NodeList)) {
                    var instancesArr = [];
                    for(var i = 0; i < els.length; i++)instancesArr.push(new classDef(els[i], options));
                    instances = instancesArr;
                }
                return instances;
            }
        }
    ]);
    return Component1;
}();
(function(window) {
    if (window.Package) M = {
    };
    else window.M = {
    };
    // Check for jQuery
    M.jQueryLoaded = !!window.jQuery;
})(window);
// AMD
if (typeof define === 'function' && define.amd) define('M', [], function() {
    return M;
});
else if (typeof exports !== 'undefined' && !exports.nodeType) {
    if (typeof module !== 'undefined' && !module.nodeType && module.exports) exports = module.exports = M;
    exports.default = M;
}
M.version = '1.0.0';
M.keys = {
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    ARROW_UP: 38,
    ARROW_DOWN: 40
};
/**
 * TabPress Keydown handler
 */ M.tabPressed = false;
M.keyDown = false;
var docHandleKeydown = function(e) {
    M.keyDown = true;
    if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) M.tabPressed = true;
};
var docHandleKeyup = function(e) {
    M.keyDown = false;
    if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) M.tabPressed = false;
};
var docHandleFocus = function(e) {
    if (M.keyDown) document.body.classList.add('keyboard-focused');
};
var docHandleBlur = function(e) {
    document.body.classList.remove('keyboard-focused');
};
document.addEventListener('keydown', docHandleKeydown, true);
document.addEventListener('keyup', docHandleKeyup, true);
document.addEventListener('focus', docHandleFocus, true);
document.addEventListener('blur', docHandleBlur, true);
/**
 * Initialize jQuery wrapper for plugin
 * @param {Class} plugin  javascript class
 * @param {string} pluginName  jQuery plugin name
 * @param {string} classRef  Class reference name
 */ M.initializeJqueryWrapper = function(plugin, pluginName, classRef) {
    jQuery.fn[pluginName] = function(methodOrOptions) {
        // Call plugin method if valid method name is passed in
        if (plugin.prototype[methodOrOptions]) {
            var params = Array.prototype.slice.call(arguments, 1);
            // Getter methods
            if (methodOrOptions.slice(0, 3) === 'get') {
                var instance = this.first()[0][classRef];
                return instance[methodOrOptions].apply(instance, params);
            }
            // Void methods
            return this.each(function() {
                var instance = this[classRef];
                instance[methodOrOptions].apply(instance, params);
            });
        // Initialize plugin if options or no argument is passed in
        } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {
            plugin.init(this, arguments[0]);
            return this;
        }
        // Return error if an unrecognized  method name is passed in
        jQuery.error("Method " + methodOrOptions + " does not exist on jQuery." + pluginName);
    };
};
/**
 * Automatically initialize components
 * @param {Element} context  DOM Element to search within for components
 */ M.AutoInit = function(context) {
    // Use document.body if no context is given
    var root = !!context ? context : document.body;
    var registry = {
        Autocomplete: root.querySelectorAll('.autocomplete:not(.no-autoinit)'),
        Carousel: root.querySelectorAll('.carousel:not(.no-autoinit)'),
        Chips: root.querySelectorAll('.chips:not(.no-autoinit)'),
        Collapsible: root.querySelectorAll('.collapsible:not(.no-autoinit)'),
        Datepicker: root.querySelectorAll('.datepicker:not(.no-autoinit)'),
        Dropdown: root.querySelectorAll('.dropdown-trigger:not(.no-autoinit)'),
        Materialbox: root.querySelectorAll('.materialboxed:not(.no-autoinit)'),
        Modal: root.querySelectorAll('.modal:not(.no-autoinit)'),
        Parallax: root.querySelectorAll('.parallax:not(.no-autoinit)'),
        Pushpin: root.querySelectorAll('.pushpin:not(.no-autoinit)'),
        ScrollSpy: root.querySelectorAll('.scrollspy:not(.no-autoinit)'),
        FormSelect: root.querySelectorAll('select:not(.no-autoinit)'),
        Sidenav: root.querySelectorAll('.sidenav:not(.no-autoinit)'),
        Tabs: root.querySelectorAll('.tabs:not(.no-autoinit)'),
        TapTarget: root.querySelectorAll('.tap-target:not(.no-autoinit)'),
        Timepicker: root.querySelectorAll('.timepicker:not(.no-autoinit)'),
        Tooltip: root.querySelectorAll('.tooltipped:not(.no-autoinit)'),
        FloatingActionButton: root.querySelectorAll('.fixed-action-btn:not(.no-autoinit)')
    };
    for(var pluginName in registry){
        var plugin = M[pluginName];
        plugin.init(registry[pluginName]);
    }
};
/**
 * Generate approximated selector string for a jQuery object
 * @param {jQuery} obj  jQuery object to be parsed
 * @returns {string}
 */ M.objectSelectorString = function(obj) {
    var tagStr = obj.prop('tagName') || '';
    var idStr = obj.attr('id') || '';
    var classStr = obj.attr('class') || '';
    return (tagStr + idStr + classStr).replace(/\s/g, '');
};
// Unique Random ID
M.guid = (function() {
    function s4() {
        return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return function() {
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    };
})();
/**
 * Escapes hash from special characters
 * @param {string} hash  String returned from this.hash
 * @returns {string}
 */ M.escapeHash = function(hash) {
    return hash.replace(/(:|\.|\[|\]|,|=|\/)/g, '\\$1');
};
M.elementOrParentIsFixed = function(element) {
    var $element = $(element);
    var $checkElements = $element.add($element.parents());
    var isFixed = false;
    $checkElements.each(function() {
        if ($(this).css('position') === 'fixed') {
            isFixed = true;
            return false;
        }
    });
    return isFixed;
};
/**
 * @typedef {Object} Edges
 * @property {Boolean} top  If the top edge was exceeded
 * @property {Boolean} right  If the right edge was exceeded
 * @property {Boolean} bottom  If the bottom edge was exceeded
 * @property {Boolean} left  If the left edge was exceeded
 */ /**
 * @typedef {Object} Bounding
 * @property {Number} left  left offset coordinate
 * @property {Number} top  top offset coordinate
 * @property {Number} width
 * @property {Number} height
 */ /**
 * Escapes hash from special characters
 * @param {Element} container  Container element that acts as the boundary
 * @param {Bounding} bounding  element bounding that is being checked
 * @param {Number} offset  offset from edge that counts as exceeding
 * @returns {Edges}
 */ M.checkWithinContainer = function(container, bounding, offset) {
    var edges = {
        top: false,
        right: false,
        bottom: false,
        left: false
    };
    var containerRect = container.getBoundingClientRect();
    // If body element is smaller than viewport, use viewport height instead.
    var containerBottom = container === document.body ? Math.max(containerRect.bottom, window.innerHeight) : containerRect.bottom;
    var scrollLeft = container.scrollLeft;
    var scrollTop = container.scrollTop;
    var scrolledX = bounding.left - scrollLeft;
    var scrolledY = bounding.top - scrollTop;
    // Check for container and viewport for each edge
    if (scrolledX < containerRect.left + offset || scrolledX < offset) edges.left = true;
    if (scrolledX + bounding.width > containerRect.right - offset || scrolledX + bounding.width > window.innerWidth - offset) edges.right = true;
    if (scrolledY < containerRect.top + offset || scrolledY < offset) edges.top = true;
    if (scrolledY + bounding.height > containerBottom - offset || scrolledY + bounding.height > window.innerHeight - offset) edges.bottom = true;
    return edges;
};
M.checkPossibleAlignments = function(el, container, bounding, offset) {
    var canAlign = {
        top: true,
        right: true,
        bottom: true,
        left: true,
        spaceOnTop: null,
        spaceOnRight: null,
        spaceOnBottom: null,
        spaceOnLeft: null
    };
    var containerAllowsOverflow = getComputedStyle(container).overflow === 'visible';
    var containerRect = container.getBoundingClientRect();
    var containerHeight = Math.min(containerRect.height, window.innerHeight);
    var containerWidth = Math.min(containerRect.width, window.innerWidth);
    var elOffsetRect = el.getBoundingClientRect();
    var scrollLeft = container.scrollLeft;
    var scrollTop = container.scrollTop;
    var scrolledX = bounding.left - scrollLeft;
    var scrolledYTopEdge = bounding.top - scrollTop;
    var scrolledYBottomEdge = bounding.top + elOffsetRect.height - scrollTop;
    // Check for container and viewport for left
    canAlign.spaceOnRight = !containerAllowsOverflow ? containerWidth - (scrolledX + bounding.width) : window.innerWidth - (elOffsetRect.left + bounding.width);
    if (canAlign.spaceOnRight < 0) canAlign.left = false;
    // Check for container and viewport for Right
    canAlign.spaceOnLeft = !containerAllowsOverflow ? scrolledX - bounding.width + elOffsetRect.width : elOffsetRect.right - bounding.width;
    if (canAlign.spaceOnLeft < 0) canAlign.right = false;
    // Check for container and viewport for Top
    canAlign.spaceOnBottom = !containerAllowsOverflow ? containerHeight - (scrolledYTopEdge + bounding.height + offset) : window.innerHeight - (elOffsetRect.top + bounding.height + offset);
    if (canAlign.spaceOnBottom < 0) canAlign.top = false;
    // Check for container and viewport for Bottom
    canAlign.spaceOnTop = !containerAllowsOverflow ? scrolledYBottomEdge - (bounding.height - offset) : elOffsetRect.bottom - (bounding.height + offset);
    if (canAlign.spaceOnTop < 0) canAlign.bottom = false;
    return canAlign;
};
M.getOverflowParent = function(element) {
    if (element == null) return null;
    if (element === document.body || getComputedStyle(element).overflow !== 'visible') return element;
    return M.getOverflowParent(element.parentElement);
};
/**
 * Gets id of component from a trigger
 * @param {Element} trigger  trigger
 * @returns {string}
 */ M.getIdFromTrigger = function(trigger) {
    var id = trigger.getAttribute('data-target');
    if (!id) {
        id = trigger.getAttribute('href');
        if (id) id = id.slice(1);
        else id = '';
    }
    return id;
};
/**
 * Multi browser support for document scroll top
 * @returns {Number}
 */ M.getDocumentScrollTop = function() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
};
/**
 * Multi browser support for document scroll left
 * @returns {Number}
 */ M.getDocumentScrollLeft = function() {
    return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
};
/**
 * @typedef {Object} Edges
 * @property {Boolean} top  If the top edge was exceeded
 * @property {Boolean} right  If the right edge was exceeded
 * @property {Boolean} bottom  If the bottom edge was exceeded
 * @property {Boolean} left  If the left edge was exceeded
 */ /**
 * @typedef {Object} Bounding
 * @property {Number} left  left offset coordinate
 * @property {Number} top  top offset coordinate
 * @property {Number} width
 * @property {Number} height
 */ /**
 * Get time in ms
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @type {function}
 * @return {number}
 */ var getTime = Date.now || function() {
    return new Date().getTime();
};
/**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. Normally, the throttled function will run
 * as much as it can, without ever going more than once per `wait` duration;
 * but if you'd like to disable the execution on the leading edge, pass
 * `{leading: false}`. To disable execution on the trailing edge, ditto.
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @param {function} func
 * @param {number} wait
 * @param {Object=} options
 * @returns {Function}
 */ M.throttle = function(func, wait, options) {
    var context = void 0, args = void 0, result = void 0;
    var timeout = null;
    var previous = 0;
    options || (options = {
    });
    var later = function() {
        previous = options.leading === false ? 0 : getTime();
        timeout = null;
        result = func.apply(context, args);
        context = args = null;
    };
    return function() {
        var now = getTime();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
            context = args = null;
        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);
        return result;
    };
};
var $jscomp = {
    scope: {
    }
};
$jscomp.defineProperty = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e, r, p) {
    if (p.get || p.set) throw new TypeError("ES3 does not support getters and setters.");
    e != Array.prototype && e != Object.prototype && (e[r] = p.value);
};
$jscomp.getGlobal = function(e) {
    return "undefined" != typeof window && window === e ? e : "undefined" != typeof global && null != global ? global : e;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
    $jscomp.initSymbol = function() {
    };
    $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.symbolCounter_ = 0;
$jscomp.Symbol = function(e) {
    return $jscomp.SYMBOL_PREFIX + (e || "") + $jscomp.symbolCounter_++;
};
$jscomp.initSymbolIterator = function() {
    $jscomp.initSymbol();
    var e = $jscomp.global.Symbol.iterator;
    e || (e = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
    "function" != typeof Array.prototype[e] && $jscomp.defineProperty(Array.prototype, e, {
        configurable: !0,
        writable: !0,
        value: function() {
            return $jscomp.arrayIterator(this);
        }
    });
    $jscomp.initSymbolIterator = function() {
    };
};
$jscomp.arrayIterator = function(e) {
    var r = 0;
    return $jscomp.iteratorPrototype(function() {
        return r < e.length ? {
            done: !1,
            value: e[r++]
        } : {
            done: !0
        };
    });
};
$jscomp.iteratorPrototype = function(e) {
    $jscomp.initSymbolIterator();
    e = {
        next: e
    };
    e[$jscomp.global.Symbol.iterator] = function() {
        return this;
    };
    return e;
};
$jscomp.array = $jscomp.array || {
};
$jscomp.iteratorFromArray = function(e, r) {
    $jscomp.initSymbolIterator();
    e instanceof String && (e += "");
    var p = 0, m = {
        next: function() {
            if (p < e.length) {
                var u = p++;
                return {
                    value: r(u, e[u]),
                    done: !1
                };
            }
            m.next = function() {
                return {
                    done: !0,
                    value: void 0
                };
            };
            return m.next();
        }
    };
    m[Symbol.iterator] = function() {
        return m;
    };
    return m;
};
$jscomp.polyfill = function(e, r, p, m) {
    if (r) {
        p = $jscomp.global;
        e = e.split(".");
        for(m = 0; m < e.length - 1; m++){
            var u = e[m];
            u in p || (p[u] = {
            });
            p = p[u];
        }
        e = e[e.length - 1];
        m = p[e];
        r = r(m);
        r != m && null != r && $jscomp.defineProperty(p, e, {
            configurable: !0,
            writable: !0,
            value: r
        });
    }
};
$jscomp.polyfill("Array.prototype.keys", function(e1) {
    return e1 ? e1 : function() {
        return $jscomp.iteratorFromArray(this, function(e) {
            return e;
        });
    };
}, "es6-impl", "es3");
var $jscomp$this = this;
(function(r) {
    M.anime = r();
})(function() {
    function e2(a) {
        if (!h1.col(a)) try {
            return document.querySelectorAll(a);
        } catch (c) {
        }
    }
    function r1(a, c) {
        for(var d = a.length, b = 2 <= arguments.length ? arguments[1] : void 0, f = [], n = 0; n < d; n++)if (n in a) {
            var k = a[n];
            c.call(b, k, n, a) && f.push(k);
        }
        return f;
    }
    function p1(a1) {
        return a1.reduce(function(a, d) {
            return a.concat(h1.arr(d) ? p1(d) : d);
        }, []);
    }
    function m1(a) {
        if (h1.arr(a)) return a;
        h1.str(a) && (a = e2(a) || a);
        return a instanceof NodeList || a instanceof HTMLCollection ? [].slice.call(a) : [
            a
        ];
    }
    function u1(a2, c) {
        return a2.some(function(a) {
            return a === c;
        });
    }
    function C(a) {
        var c = {
        }, d;
        for(d in a)c[d] = a[d];
        return c;
    }
    function D(a, c) {
        var d = C(a), b;
        for(b in a)d[b] = c.hasOwnProperty(b) ? c[b] : a[b];
        return d;
    }
    function z(a, c) {
        var d = C(a), b;
        for(b in c)d[b] = h1.und(a[b]) ? c[b] : a[b];
        return d;
    }
    function T(a) {
        a = a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, c, d, k) {
            return c + c + d + d + k + k;
        });
        var c4 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
        a = parseInt(c4[1], 16);
        var d1 = parseInt(c4[2], 16), c4 = parseInt(c4[3], 16);
        return "rgba(" + a + "," + d1 + "," + c4 + ",1)";
    }
    function U(a3) {
        function c5(a, c, b) {
            0 > b && (b += 1);
            1 < b && --b;
            return b < 1 / 6 ? a + 6 * (c - a) * b : 0.5 > b ? c : b < 2 / 3 ? a + (c - a) * (2 / 3 - b) * 6 : a;
        }
        var d = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(a3) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(a3);
        a3 = parseInt(d[1]) / 360;
        var b1 = parseInt(d[2]) / 100, f = parseInt(d[3]) / 100, d = d[4] || 1;
        if (0 == b1) f = b1 = a3 = f;
        else {
            var n = 0.5 > f ? f * (1 + b1) : f + b1 - f * b1, k = 2 * f - n, f = c5(k, n, a3 + 1 / 3), b1 = c5(k, n, a3);
            a3 = c5(k, n, a3 - 1 / 3);
        }
        return "rgba(" + 255 * f + "," + 255 * b1 + "," + 255 * a3 + "," + d + ")";
    }
    function y(a) {
        if (a = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a)) return a[2];
    }
    function V(a) {
        if (-1 < a.indexOf("translate") || "perspective" === a) return "px";
        if (-1 < a.indexOf("rotate") || -1 < a.indexOf("skew")) return "deg";
    }
    function I(a, c) {
        return h1.fnc(a) ? a(c.target, c.id, c.total) : a;
    }
    function E(a, c) {
        if (c in a.style) return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()) || "0";
    }
    function J(a, c) {
        if (h1.dom(a) && u1(W, c)) return "transform";
        if (h1.dom(a) && (a.getAttribute(c) || h1.svg(a) && a[c])) return "attribute";
        if (h1.dom(a) && "transform" !== c && E(a, c)) return "css";
        if (null != a[c]) return "object";
    }
    function X(a, c) {
        var d = V(c), d = -1 < c.indexOf("scale") ? 1 : 0 + d;
        a = a.style.transform;
        if (!a) return d;
        for(var b = [], f = [], n = [], k = /(\w+)\((.+?)\)/g; b = k.exec(a);)f.push(b[1]), n.push(b[2]);
        a = r1(n, function(a, b) {
            return f[b] === c;
        });
        return a.length ? a[0] : d;
    }
    function K(a, c) {
        switch(J(a, c)){
            case "transform":
                return X(a, c);
            case "css":
                return E(a, c);
            case "attribute":
                return a.getAttribute(c);
        }
        return a[c] || 0;
    }
    function L(a, c) {
        var d = /^(\*=|\+=|-=)/.exec(a);
        if (!d) return a;
        var b = y(a) || 0;
        c = parseFloat(c);
        a = parseFloat(a.replace(d[0], ""));
        switch(d[0][0]){
            case "+":
                return c + a + b;
            case "-":
                return c - a + b;
            case "*":
                return c * a + b;
        }
    }
    function F(a, c) {
        return Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
    }
    function M(a) {
        a = a.points;
        for(var c = 0, d, b = 0; b < a.numberOfItems; b++){
            var f = a.getItem(b);
            0 < b && (c += F(d, f));
            d = f;
        }
        return c;
    }
    function N(a) {
        if (a.getTotalLength) return a.getTotalLength();
        switch(a.tagName.toLowerCase()){
            case "circle":
                return 2 * Math.PI * a.getAttribute("r");
            case "rect":
                return 2 * a.getAttribute("width") + 2 * a.getAttribute("height");
            case "line":
                return F({
                    x: a.getAttribute("x1"),
                    y: a.getAttribute("y1")
                }, {
                    x: a.getAttribute("x2"),
                    y: a.getAttribute("y2")
                });
            case "polyline":
                return M(a);
            case "polygon":
                var c = a.points;
                return M(a) + F(c.getItem(c.numberOfItems - 1), c.getItem(0));
        }
    }
    function Y(a, c) {
        function d(b) {
            b = void 0 === b ? 0 : b;
            return a.el.getPointAtLength(1 <= c + b ? c + b : 0);
        }
        var b2 = d(), f = d(-1), n = d(1);
        switch(a.property){
            case "x":
                return b2.x;
            case "y":
                return b2.y;
            case "angle":
                return 180 * Math.atan2(n.y - f.y, n.x - f.x) / Math.PI;
        }
    }
    function O(a, c) {
        var d = /-?\d*\.?\d+/g, b;
        b = h1.pth(a) ? a.totalLength : a;
        if (h1.col(b)) {
            if (h1.rgb(b)) {
                var f = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(b);
                b = f ? "rgba(" + f[1] + ",1)" : b;
            } else b = h1.hex(b) ? T(b) : h1.hsl(b) ? U(b) : void 0;
        } else f = (f = y(b)) ? b.substr(0, b.length - f.length) : b, b = c && !/\s/g.test(b) ? f + c : f;
        b += "";
        return {
            original: b,
            numbers: b.match(d) ? b.match(d).map(Number) : [
                0
            ],
            strings: h1.str(a) || c ? b.split(d) : []
        };
    }
    function P(a4) {
        a4 = a4 ? p1(h1.arr(a4) ? a4.map(m1) : m1(a4)) : [];
        return r1(a4, function(a, d, b) {
            return b.indexOf(a) === d;
        });
    }
    function Z(a5) {
        var c = P(a5);
        return c.map(function(a, b) {
            return {
                target: a,
                id: b,
                total: c.length
            };
        });
    }
    function aa(a6, c) {
        var d = C(c);
        if (h1.arr(a6)) {
            var b = a6.length;
            2 !== b || h1.obj(a6[0]) ? h1.fnc(c.duration) || (d.duration = c.duration / b) : a6 = {
                value: a6
            };
        }
        return m1(a6).map(function(a, b) {
            b = b ? 0 : c.delay;
            a = h1.obj(a) && !h1.pth(a) ? a : {
                value: a
            };
            h1.und(a.delay) && (a.delay = b);
            return a;
        }).map(function(a) {
            return z(a, d);
        });
    }
    function ba(a7, c) {
        var d = {
        }, b;
        for(b in a7){
            var f = I(a7[b], c);
            h1.arr(f) && (f = f.map(function(a) {
                return I(a, c);
            }), 1 === f.length && (f = f[0]));
            d[b] = f;
        }
        d.duration = parseFloat(d.duration);
        d.delay = parseFloat(d.delay);
        return d;
    }
    function ca(a) {
        return h1.arr(a) ? A.apply(this, a) : Q[a];
    }
    function da(a, c) {
        var d;
        return a.tweens.map(function(b) {
            b = ba(b, c);
            var f = b.value, e = K(c.target, a.name), k = d ? d.to.original : e, k = h1.arr(f) ? f[0] : k, w = L(h1.arr(f) ? f[1] : f, k), e = y(w) || y(k) || y(e);
            b.from = O(k, e);
            b.to = O(w, e);
            b.start = d ? d.end : a.offset;
            b.end = b.start + b.delay + b.duration;
            b.easing = ca(b.easing);
            b.elasticity = (1000 - Math.min(Math.max(b.elasticity, 1), 999)) / 1000;
            b.isPath = h1.pth(f);
            b.isColor = h1.col(b.from.original);
            b.isColor && (b.round = 1);
            return d = b;
        });
    }
    function ea(a8, c6) {
        return r1(p1(a8.map(function(a) {
            return c6.map(function(b) {
                var c = J(a.target, b.name);
                if (c) {
                    var d = da(b, a);
                    b = {
                        type: c,
                        property: b.name,
                        animatable: a,
                        tweens: d,
                        duration: d[d.length - 1].end,
                        delay: d[0].delay
                    };
                } else b = void 0;
                return b;
            });
        })), function(a) {
            return !h1.und(a);
        });
    }
    function R(a, c, d, b3) {
        var f = "delay" === a;
        return c.length ? (f ? Math.min : Math.max).apply(Math, c.map(function(b) {
            return b[a];
        })) : f ? b3.delay : d.offset + b3.delay + b3.duration;
    }
    function fa(a) {
        var c = D(ga, a), d = D(S, a), b = Z(a.targets), f = [], e = z(c, d), k;
        for(k in a)e.hasOwnProperty(k) || "targets" === k || f.push({
            name: k,
            offset: e.offset,
            tweens: aa(a[k], d)
        });
        a = ea(b, f);
        return z(c, {
            children: [],
            animatables: b,
            animations: a,
            duration: R("duration", a, c, d),
            delay: R("delay", a, c, d)
        });
    }
    function q1(a9) {
        function c7() {
            return window.Promise && new Promise(function(a) {
                return p2 = a;
            });
        }
        function d2(a) {
            return g.reversed ? g.duration - a : a;
        }
        function b4(a) {
            for(var b5 = 0, c = {
            }, d = g.animations, f = d.length; b5 < f;){
                var e = d[b5], k = e.animatable, h = e.tweens, n = h.length - 1, l = h[n];
                n && (l = r1(h, function(b) {
                    return a < b.end;
                })[0] || l);
                for(var h = Math.min(Math.max(a - l.start - l.delay, 0), l.duration) / l.duration, w = isNaN(h) ? 1 : l.easing(h, l.elasticity), h = l.to.strings, p = l.round, n = [], m = void 0, m = l.to.numbers.length, t = 0; t < m; t++){
                    var x = void 0, x = l.to.numbers[t], q = l.from.numbers[t], x = l.isPath ? Y(l.value, w * x) : q + w * (x - q);
                    p && (l.isColor && 2 < t || (x = Math.round(x * p) / p));
                    n.push(x);
                }
                if (l = h.length) for(m = h[0], w = 0; w < l; w++)p = h[w + 1], t = n[w], isNaN(t) || (m = p ? m + (t + p) : m + (t + " "));
                else m = n[0];
                ha[e.type](k.target, e.property, m, c, k.id);
                e.currentValue = m;
                b5++;
            }
            if (b5 = Object.keys(c).length) for(d = 0; d < b5; d++)H || (H = E(document.body, "transform") ? "transform" : "-webkit-transform"), g.animatables[d].target.style[H] = c[d].join(" ");
            g.currentTime = a;
            g.progress = a / g.duration * 100;
        }
        function f1(a) {
            if (g[a]) g[a](g);
        }
        function e3() {
            g.remaining && !0 !== g.remaining && g.remaining--;
        }
        function k1(a) {
            var k = g.duration, n = g.offset, w = n + g.delay, r = g.currentTime, x = g.reversed, q = d2(a);
            if (g.children.length) {
                var u = g.children, v = u.length;
                if (q >= g.currentTime) for(var G = 0; G < v; G++)u[G].seek(q);
                else for(; v--;)u[v].seek(q);
            }
            if (q >= w || !k) g.began || (g.began = !0, f1("begin")), f1("run");
            if (q > n && q < k) b4(q);
            else if (q <= n && 0 !== r && (b4(0), x && e3()), q >= k && r !== k || !k) b4(k), x || e3();
            f1("update");
            a >= k && (g.remaining ? (t1 = h2, "alternate" === g.direction && (g.reversed = !g.reversed)) : (g.pause(), g.completed || (g.completed = !0, f1("complete"), "Promise" in window && (p2(), m2 = c7()))), l1 = 0);
        }
        a9 = void 0 === a9 ? {
        } : a9;
        var h2, t1, l1 = 0, p2 = null, m2 = c7(), g = fa(a9);
        g.reset = function() {
            var a = g.direction, c = g.loop;
            g.currentTime = 0;
            g.progress = 0;
            g.paused = !0;
            g.began = !1;
            g.completed = !1;
            g.reversed = "reverse" === a;
            g.remaining = "alternate" === a && 1 === c ? 2 : c;
            b4(0);
            for(a = g.children.length; a--;)g.children[a].reset();
        };
        g.tick = function(a) {
            h2 = a;
            t1 || (t1 = h2);
            k1((l1 + h2 - t1) * q1.speed);
        };
        g.seek = function(a) {
            k1(d2(a));
        };
        g.pause = function() {
            var a = v1.indexOf(g);
            -1 < a && v1.splice(a, 1);
            g.paused = !0;
        };
        g.play = function() {
            g.paused && (g.paused = !1, t1 = 0, l1 = d2(g.currentTime), v1.push(g), B || ia());
        };
        g.reverse = function() {
            g.reversed = !g.reversed;
            t1 = 0;
            l1 = d2(g.currentTime);
        };
        g.restart = function() {
            g.pause();
            g.reset();
            g.play();
        };
        g.finished = m2;
        g.reset();
        g.autoplay && g.play();
        return g;
    }
    var ga = {
        update: void 0,
        begin: void 0,
        run: void 0,
        complete: void 0,
        loop: 1,
        direction: "normal",
        autoplay: !0,
        offset: 0
    }, S = {
        duration: 1000,
        delay: 0,
        easing: "easeOutElastic",
        elasticity: 500,
        round: 0
    }, W = "translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective".split(" "), H, h1 = {
        arr: function(a) {
            return Array.isArray(a);
        },
        obj: function(a) {
            return -1 < Object.prototype.toString.call(a).indexOf("Object");
        },
        pth: function(a) {
            return h1.obj(a) && a.hasOwnProperty("totalLength");
        },
        svg: function(a) {
            return a instanceof SVGElement;
        },
        dom: function(a) {
            return a.nodeType || h1.svg(a);
        },
        str: function(a) {
            return "string" === typeof a;
        },
        fnc: function(a) {
            return "function" === typeof a;
        },
        und: function(a) {
            return "undefined" === typeof a;
        },
        hex: function(a) {
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
        },
        rgb: function(a) {
            return /^rgb/.test(a);
        },
        hsl: function(a) {
            return /^hsl/.test(a);
        },
        col: function(a) {
            return h1.hex(a) || h1.rgb(a) || h1.hsl(a);
        }
    }, A = function() {
        function a10(a, d, b) {
            return (((1 - 3 * b + 3 * d) * a + (3 * b - 6 * d)) * a + 3 * d) * a;
        }
        return function(c, d, b, f) {
            if (0 <= c && 1 >= c && 0 <= b && 1 >= b) {
                var e = new Float32Array(11);
                if (c !== d || b !== f) for(var k2 = 0; 11 > k2; ++k2)e[k2] = a10(0.1 * k2, c, b);
                return function(k) {
                    if (c === d && b === f) return k;
                    if (0 === k) return 0;
                    if (1 === k) return 1;
                    for(var h = 0, l = 1; 10 !== l && e[l] <= k; ++l)h += 0.1;
                    --l;
                    var l = h + (k - e[l]) / (e[l + 1] - e[l]) * 0.1, n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;
                    if (0.001 <= n) {
                        for(h = 0; 4 > h; ++h){
                            n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;
                            if (0 === n) break;
                            var m = a10(l, c, b) - k, l = l - m / n;
                        }
                        k = l;
                    } else if (0 === n) k = l;
                    else {
                        var l = h, h = h + 0.1, g = 0;
                        do m = l + (h - l) / 2, n = a10(m, c, b) - k, 0 < n ? h = m : l = m;
                        while (0.0000001 < Math.abs(n) && 10 > ++g)
                        k = m;
                    }
                    return a10(k, d, f);
                };
            }
        };
    }(), Q = function() {
        function a11(a, b) {
            return 0 === a || 1 === a ? a : -Math.pow(2, 10 * (a - 1)) * Math.sin(2 * (a - 1 - b / (2 * Math.PI) * Math.asin(1)) * Math.PI / b);
        }
        var c8 = "Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(" "), d3 = {
            In: [
                [
                    0.55,
                    0.085,
                    0.68,
                    0.53
                ],
                [
                    0.55,
                    0.055,
                    0.675,
                    0.19
                ],
                [
                    0.895,
                    0.03,
                    0.685,
                    0.22
                ],
                [
                    0.755,
                    0.05,
                    0.855,
                    0.06
                ],
                [
                    0.47,
                    0,
                    0.745,
                    0.715
                ],
                [
                    0.95,
                    0.05,
                    0.795,
                    0.035
                ],
                [
                    0.6,
                    0.04,
                    0.98,
                    0.335
                ],
                [
                    0.6,
                    -0.28,
                    0.735,
                    0.045
                ],
                a11
            ],
            Out: [
                [
                    0.25,
                    0.46,
                    0.45,
                    0.94
                ],
                [
                    0.215,
                    0.61,
                    0.355,
                    1
                ],
                [
                    0.165,
                    0.84,
                    0.44,
                    1
                ],
                [
                    0.23,
                    1,
                    0.32,
                    1
                ],
                [
                    0.39,
                    0.575,
                    0.565,
                    1
                ],
                [
                    0.19,
                    1,
                    0.22,
                    1
                ],
                [
                    0.075,
                    0.82,
                    0.165,
                    1
                ],
                [
                    0.175,
                    0.885,
                    0.32,
                    1.275
                ],
                function(b, c) {
                    return 1 - a11(1 - b, c);
                }
            ],
            InOut: [
                [
                    0.455,
                    0.03,
                    0.515,
                    0.955
                ],
                [
                    0.645,
                    0.045,
                    0.355,
                    1
                ],
                [
                    0.77,
                    0,
                    0.175,
                    1
                ],
                [
                    0.86,
                    0,
                    0.07,
                    1
                ],
                [
                    0.445,
                    0.05,
                    0.55,
                    0.95
                ],
                [
                    1,
                    0,
                    0,
                    1
                ],
                [
                    0.785,
                    0.135,
                    0.15,
                    0.86
                ],
                [
                    0.68,
                    -0.55,
                    0.265,
                    1.55
                ],
                function(b, c) {
                    return 0.5 > b ? a11(2 * b, c) / 2 : 1 - a11(-2 * b + 2, c) / 2;
                }
            ]
        }, b6 = {
            linear: A(0.25, 0.25, 0.75, 0.75)
        }, f = {
        }, e;
        for(e in d3)f.type = e, d3[f.type].forEach(function(a) {
            return function(d, f) {
                b6["ease" + a.type + c8[f]] = h1.fnc(d) ? d : A.apply($jscomp$this, d);
            };
        }(f)), f = {
            type: f.type
        };
        return b6;
    }(), ha = {
        css: function(a, c, d) {
            return a.style[c] = d;
        },
        attribute: function(a, c, d) {
            return a.setAttribute(c, d);
        },
        object: function(a, c, d) {
            return a[c] = d;
        },
        transform: function(a, c, d, b, f) {
            b[f] || (b[f] = []);
            b[f].push(c + "(" + d + ")");
        }
    }, v1 = [], B = 0, ia = function() {
        function a() {
            B = requestAnimationFrame(c9);
        }
        function c9(c) {
            var b = v1.length;
            if (b) {
                for(var d = 0; d < b;)v1[d] && v1[d].tick(c), d++;
                a();
            } else cancelAnimationFrame(B), B = 0;
        }
        return a;
    }();
    q1.version = "2.2.0";
    q1.speed = 1;
    q1.running = v1;
    q1.remove = function(a) {
        a = P(a);
        for(var c = v1.length; c--;)for(var d = v1[c], b = d.animations, f = b.length; f--;)u1(a, b[f].animatable.target) && (b.splice(f, 1), b.length || d.pause());
    };
    q1.getValue = K;
    q1.path = function(a12, c) {
        var d = h1.str(a12) ? e2(a12)[0] : a12, b = c || 100;
        return function(a) {
            return {
                el: d,
                property: a,
                totalLength: N(d) * (b / 100)
            };
        };
    };
    q1.setDashoffset = function(a) {
        var c = N(a);
        a.setAttribute("stroke-dasharray", c);
        return c;
    };
    q1.bezier = A;
    q1.easings = Q;
    q1.timeline = function(a13) {
        var c = q1(a13);
        c.pause();
        c.duration = 0;
        c.add = function(d4) {
            c.children.forEach(function(a) {
                a.began = !0;
                a.completed = !0;
            });
            m1(d4).forEach(function(b) {
                var d = z(b, D(S, a13 || {
                }));
                d.targets = d.targets || a13.targets;
                b = c.duration;
                var e = d.offset;
                d.autoplay = !1;
                d.direction = c.direction;
                d.offset = h1.und(e) ? b : L(e, b);
                c.began = !0;
                c.completed = !0;
                c.seek(d.offset);
                d = q1(d);
                d.began = !0;
                d.completed = !0;
                d.duration > b && (c.duration = d.duration);
                c.children.push(d);
            });
            c.seek(0);
            c.reset();
            c.autoplay && c.restart();
            return c;
        };
        return c;
    };
    q1.random = function(a, c) {
        return Math.floor(Math.random() * (c - a + 1)) + a;
    };
    return q1;
});
(function($, anim) {
    var _defaults = {
        accordion: true,
        onOpenStart: undefined,
        onOpenEnd: undefined,
        onCloseStart: undefined,
        onCloseEnd: undefined,
        inDuration: 300,
        outDuration: 300
    };
    /**
   * @class
   *
   */ var Collapsible1 = function(_Component) {
        _inherits(Collapsible, _Component);
        /**
     * Construct Collapsible instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Collapsible(el, options) {
            _classCallCheck(this, Collapsible);
            var _this3 = _possibleConstructorReturn(this, (Collapsible.__proto__ || Object.getPrototypeOf(Collapsible)).call(this, Collapsible, el, options));
            _this3.el.M_Collapsible = _this3;
            /**
       * Options for the collapsible
       * @member Collapsible#options
       * @prop {Boolean} [accordion=false] - Type of the collapsible
       * @prop {Function} onOpenStart - Callback function called before collapsible is opened
       * @prop {Function} onOpenEnd - Callback function called after collapsible is opened
       * @prop {Function} onCloseStart - Callback function called before collapsible is closed
       * @prop {Function} onCloseEnd - Callback function called after collapsible is closed
       * @prop {Number} inDuration - Transition in duration in milliseconds.
       * @prop {Number} outDuration - Transition duration in milliseconds.
       */ _this3.options = $.extend({
            }, Collapsible.defaults, options);
            // Setup tab indices
            _this3.$headers = _this3.$el.children('li').children('.collapsible-header');
            _this3.$headers.attr('tabindex', 0);
            _this3._setupEventHandlers();
            // Open first active
            var $activeBodies = _this3.$el.children('li.active').children('.collapsible-body');
            if (_this3.options.accordion) // Handle Accordion
            $activeBodies.first().css('display', 'block');
            else // Handle Expandables
            $activeBodies.css('display', 'block');
            return _this3;
        }
        _createClass(Collapsible, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.el.M_Collapsible = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    var _this4 = this;
                    this._handleCollapsibleClickBound = this._handleCollapsibleClick.bind(this);
                    this._handleCollapsibleKeydownBound = this._handleCollapsibleKeydown.bind(this);
                    this.el.addEventListener('click', this._handleCollapsibleClickBound);
                    this.$headers.each(function(header) {
                        header.addEventListener('keydown', _this4._handleCollapsibleKeydownBound);
                    });
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    var _this5 = this;
                    this.el.removeEventListener('click', this._handleCollapsibleClickBound);
                    this.$headers.each(function(header) {
                        header.removeEventListener('keydown', _this5._handleCollapsibleKeydownBound);
                    });
                }
            },
            {
                key: "_handleCollapsibleClick",
                value: function _handleCollapsibleClick(e) {
                    var $header = $(e.target).closest('.collapsible-header');
                    if (e.target && $header.length) {
                        var $collapsible = $header.closest('.collapsible');
                        if ($collapsible[0] === this.el) {
                            var $collapsibleLi = $header.closest('li');
                            var $collapsibleLis = $collapsible.children('li');
                            var isActive = $collapsibleLi[0].classList.contains('active');
                            var index = $collapsibleLis.index($collapsibleLi);
                            if (isActive) this.close(index);
                            else this.open(index);
                        }
                    }
                }
            },
            {
                key: "_handleCollapsibleKeydown",
                value: function _handleCollapsibleKeydown(e) {
                    if (e.keyCode === 13) this._handleCollapsibleClickBound(e);
                }
            },
            {
                key: "_animateIn",
                value: function _animateIn(index) {
                    var _this6 = this;
                    var $collapsibleLi = this.$el.children('li').eq(index);
                    if ($collapsibleLi.length) {
                        var $body = $collapsibleLi.children('.collapsible-body');
                        anim.remove($body[0]);
                        $body.css({
                            display: 'block',
                            overflow: 'hidden',
                            height: 0,
                            paddingTop: '',
                            paddingBottom: ''
                        });
                        var pTop = $body.css('padding-top');
                        var pBottom = $body.css('padding-bottom');
                        var finalHeight = $body[0].scrollHeight;
                        $body.css({
                            paddingTop: 0,
                            paddingBottom: 0
                        });
                        anim({
                            targets: $body[0],
                            height: finalHeight,
                            paddingTop: pTop,
                            paddingBottom: pBottom,
                            duration: this.options.inDuration,
                            easing: 'easeInOutCubic',
                            complete: function(anim) {
                                $body.css({
                                    overflow: '',
                                    paddingTop: '',
                                    paddingBottom: '',
                                    height: ''
                                });
                                // onOpenEnd callback
                                if (typeof _this6.options.onOpenEnd === 'function') _this6.options.onOpenEnd.call(_this6, $collapsibleLi[0]);
                            }
                        });
                    }
                }
            },
            {
                key: "_animateOut",
                value: function _animateOut(index) {
                    var _this7 = this;
                    var $collapsibleLi = this.$el.children('li').eq(index);
                    if ($collapsibleLi.length) {
                        var $body = $collapsibleLi.children('.collapsible-body');
                        anim.remove($body[0]);
                        $body.css('overflow', 'hidden');
                        anim({
                            targets: $body[0],
                            height: 0,
                            paddingTop: 0,
                            paddingBottom: 0,
                            duration: this.options.outDuration,
                            easing: 'easeInOutCubic',
                            complete: function() {
                                $body.css({
                                    height: '',
                                    overflow: '',
                                    padding: '',
                                    display: ''
                                });
                                // onCloseEnd callback
                                if (typeof _this7.options.onCloseEnd === 'function') _this7.options.onCloseEnd.call(_this7, $collapsibleLi[0]);
                            }
                        });
                    }
                }
            },
            {
                key: "open",
                value: function open(index1) {
                    var _this8 = this;
                    var $collapsibleLi = this.$el.children('li').eq(index1);
                    if ($collapsibleLi.length && !$collapsibleLi[0].classList.contains('active')) {
                        // onOpenStart callback
                        if (typeof this.options.onOpenStart === 'function') this.options.onOpenStart.call(this, $collapsibleLi[0]);
                        // Handle accordion behavior
                        if (this.options.accordion) {
                            var $collapsibleLis = this.$el.children('li');
                            var $activeLis = this.$el.children('li.active');
                            $activeLis.each(function(el) {
                                var index = $collapsibleLis.index($(el));
                                _this8.close(index);
                            });
                        }
                        // Animate in
                        $collapsibleLi[0].classList.add('active');
                        this._animateIn(index1);
                    }
                }
            },
            {
                key: "close",
                value: function close(index) {
                    var $collapsibleLi = this.$el.children('li').eq(index);
                    if ($collapsibleLi.length && $collapsibleLi[0].classList.contains('active')) {
                        // onCloseStart callback
                        if (typeof this.options.onCloseStart === 'function') this.options.onCloseStart.call(this, $collapsibleLi[0]);
                        // Animate out
                        $collapsibleLi[0].classList.remove('active');
                        this._animateOut(index);
                    }
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Collapsible.__proto__ || Object.getPrototypeOf(Collapsible), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Collapsible;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Collapsible;
    }(Component);
    M.Collapsible = Collapsible1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Collapsible1, 'collapsible', 'M_Collapsible');
})(cash, M.anime);
(function($, anim) {
    var _defaults = {
        alignment: 'left',
        autoFocus: true,
        constrainWidth: true,
        container: null,
        coverTrigger: true,
        closeOnClick: true,
        hover: false,
        inDuration: 150,
        outDuration: 250,
        onOpenStart: null,
        onOpenEnd: null,
        onCloseStart: null,
        onCloseEnd: null,
        onItemClick: null
    };
    /**
   * @class
   */ var Dropdown1 = function(_Component2) {
        _inherits(Dropdown, _Component2);
        function Dropdown(el, options) {
            _classCallCheck(this, Dropdown);
            var _this9 = _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, Dropdown, el, options));
            _this9.el.M_Dropdown = _this9;
            Dropdown._dropdowns.push(_this9);
            _this9.id = M.getIdFromTrigger(el);
            _this9.dropdownEl = document.getElementById(_this9.id);
            _this9.$dropdownEl = $(_this9.dropdownEl);
            /**
       * Options for the dropdown
       * @member Dropdown#options
       * @prop {String} [alignment='left'] - Edge which the dropdown is aligned to
       * @prop {Boolean} [autoFocus=true] - Automatically focus dropdown el for keyboard
       * @prop {Boolean} [constrainWidth=true] - Constrain width to width of the button
       * @prop {Element} container - Container element to attach dropdown to (optional)
       * @prop {Boolean} [coverTrigger=true] - Place dropdown over trigger
       * @prop {Boolean} [closeOnClick=true] - Close on click of dropdown item
       * @prop {Boolean} [hover=false] - Open dropdown on hover
       * @prop {Number} [inDuration=150] - Duration of open animation in ms
       * @prop {Number} [outDuration=250] - Duration of close animation in ms
       * @prop {Function} onOpenStart - Function called when dropdown starts opening
       * @prop {Function} onOpenEnd - Function called when dropdown finishes opening
       * @prop {Function} onCloseStart - Function called when dropdown starts closing
       * @prop {Function} onCloseEnd - Function called when dropdown finishes closing
       */ _this9.options = $.extend({
            }, Dropdown.defaults, options);
            /**
       * Describes open/close state of dropdown
       * @type {Boolean}
       */ _this9.isOpen = false;
            /**
       * Describes if dropdown content is scrollable
       * @type {Boolean}
       */ _this9.isScrollable = false;
            /**
       * Describes if touch moving on dropdown content
       * @type {Boolean}
       */ _this9.isTouchMoving = false;
            _this9.focusedIndex = -1;
            _this9.filterQuery = [];
            // Move dropdown-content after dropdown-trigger
            if (!!_this9.options.container) $(_this9.options.container).append(_this9.dropdownEl);
            else _this9.$el.after(_this9.dropdownEl);
            _this9._makeDropdownFocusable();
            _this9._resetFilterQueryBound = _this9._resetFilterQuery.bind(_this9);
            _this9._handleDocumentClickBound = _this9._handleDocumentClick.bind(_this9);
            _this9._handleDocumentTouchmoveBound = _this9._handleDocumentTouchmove.bind(_this9);
            _this9._handleDropdownClickBound = _this9._handleDropdownClick.bind(_this9);
            _this9._handleDropdownKeydownBound = _this9._handleDropdownKeydown.bind(_this9);
            _this9._handleTriggerKeydownBound = _this9._handleTriggerKeydown.bind(_this9);
            _this9._setupEventHandlers();
            return _this9;
        }
        _createClass(Dropdown, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._resetDropdownStyles();
                    this._removeEventHandlers();
                    Dropdown._dropdowns.splice(Dropdown._dropdowns.indexOf(this), 1);
                    this.el.M_Dropdown = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    // Trigger keydown handler
                    this.el.addEventListener('keydown', this._handleTriggerKeydownBound);
                    // Item click handler
                    this.dropdownEl.addEventListener('click', this._handleDropdownClickBound);
                    // Hover event handlers
                    if (this.options.hover) {
                        this._handleMouseEnterBound = this._handleMouseEnter.bind(this);
                        this.el.addEventListener('mouseenter', this._handleMouseEnterBound);
                        this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);
                        this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);
                        this.dropdownEl.addEventListener('mouseleave', this._handleMouseLeaveBound);
                    // Click event handlers
                    } else {
                        this._handleClickBound = this._handleClick.bind(this);
                        this.el.addEventListener('click', this._handleClickBound);
                    }
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('keydown', this._handleTriggerKeydownBound);
                    this.dropdownEl.removeEventListener('click', this._handleDropdownClickBound);
                    if (this.options.hover) {
                        this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);
                        this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);
                        this.dropdownEl.removeEventListener('mouseleave', this._handleMouseLeaveBound);
                    } else this.el.removeEventListener('click', this._handleClickBound);
                }
            },
            {
                key: "_setupTemporaryEventHandlers",
                value: function _setupTemporaryEventHandlers() {
                    // Use capture phase event handler to prevent click
                    document.body.addEventListener('click', this._handleDocumentClickBound, true);
                    document.body.addEventListener('touchend', this._handleDocumentClickBound);
                    document.body.addEventListener('touchmove', this._handleDocumentTouchmoveBound);
                    this.dropdownEl.addEventListener('keydown', this._handleDropdownKeydownBound);
                }
            },
            {
                key: "_removeTemporaryEventHandlers",
                value: function _removeTemporaryEventHandlers() {
                    // Use capture phase event handler to prevent click
                    document.body.removeEventListener('click', this._handleDocumentClickBound, true);
                    document.body.removeEventListener('touchend', this._handleDocumentClickBound);
                    document.body.removeEventListener('touchmove', this._handleDocumentTouchmoveBound);
                    this.dropdownEl.removeEventListener('keydown', this._handleDropdownKeydownBound);
                }
            },
            {
                key: "_handleClick",
                value: function _handleClick(e) {
                    e.preventDefault();
                    this.open();
                }
            },
            {
                key: "_handleMouseEnter",
                value: function _handleMouseEnter() {
                    this.open();
                }
            },
            {
                key: "_handleMouseLeave",
                value: function _handleMouseLeave(e) {
                    var toEl = e.toElement || e.relatedTarget;
                    var leaveToDropdownContent = !!$(toEl).closest('.dropdown-content').length;
                    var leaveToActiveDropdownTrigger = false;
                    var $closestTrigger = $(toEl).closest('.dropdown-trigger');
                    if ($closestTrigger.length && !!$closestTrigger[0].M_Dropdown && $closestTrigger[0].M_Dropdown.isOpen) leaveToActiveDropdownTrigger = true;
                    // Close hover dropdown if mouse did not leave to either active dropdown-trigger or dropdown-content
                    if (!leaveToActiveDropdownTrigger && !leaveToDropdownContent) this.close();
                }
            },
            {
                key: "_handleDocumentClick",
                value: function _handleDocumentClick(e) {
                    var _this10 = this;
                    var $target = $(e.target);
                    if (this.options.closeOnClick && $target.closest('.dropdown-content').length && !this.isTouchMoving) // isTouchMoving to check if scrolling on mobile.
                    setTimeout(function() {
                        _this10.close();
                    }, 0);
                    else if ($target.closest('.dropdown-trigger').length || !$target.closest('.dropdown-content').length) setTimeout(function() {
                        _this10.close();
                    }, 0);
                    this.isTouchMoving = false;
                }
            },
            {
                key: "_handleTriggerKeydown",
                value: function _handleTriggerKeydown(e) {
                    // ARROW DOWN OR ENTER WHEN SELECT IS CLOSED - open Dropdown
                    if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ENTER) && !this.isOpen) {
                        e.preventDefault();
                        this.open();
                    }
                }
            },
            {
                key: "_handleDocumentTouchmove",
                value: function _handleDocumentTouchmove(e) {
                    var $target = $(e.target);
                    if ($target.closest('.dropdown-content').length) this.isTouchMoving = true;
                }
            },
            {
                key: "_handleDropdownClick",
                value: function _handleDropdownClick(e) {
                    // onItemClick callback
                    if (typeof this.options.onItemClick === 'function') {
                        var itemEl = $(e.target).closest('li')[0];
                        this.options.onItemClick.call(this, itemEl);
                    }
                }
            },
            {
                key: "_handleDropdownKeydown",
                value: function _handleDropdownKeydown(e) {
                    if (e.which === M.keys.TAB) {
                        e.preventDefault();
                        this.close();
                    // Navigate down dropdown list
                    } else if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) && this.isOpen) {
                        e.preventDefault();
                        var direction = e.which === M.keys.ARROW_DOWN ? 1 : -1;
                        var newFocusedIndex = this.focusedIndex;
                        var foundNewIndex = false;
                        do {
                            newFocusedIndex = newFocusedIndex + direction;
                            if (!!this.dropdownEl.children[newFocusedIndex] && this.dropdownEl.children[newFocusedIndex].tabIndex !== -1) {
                                foundNewIndex = true;
                                break;
                            }
                        }while (newFocusedIndex < this.dropdownEl.children.length && newFocusedIndex >= 0)
                        if (foundNewIndex) {
                            this.focusedIndex = newFocusedIndex;
                            this._focusFocusedItem();
                        }
                    // ENTER selects choice on focused item
                    } else if (e.which === M.keys.ENTER && this.isOpen) {
                        // Search for <a> and <button>
                        var focusedElement = this.dropdownEl.children[this.focusedIndex];
                        var $activatableElement = $(focusedElement).find('a, button').first();
                        // Click a or button tag if exists, otherwise click li tag
                        if (!!$activatableElement.length) $activatableElement[0].click();
                        else if (!!focusedElement) focusedElement.click();
                    // Close dropdown on ESC
                    } else if (e.which === M.keys.ESC && this.isOpen) {
                        e.preventDefault();
                        this.close();
                    }
                    // CASE WHEN USER TYPE LETTERS
                    var letter = String.fromCharCode(e.which).toLowerCase(), nonLetters = [
                        9,
                        13,
                        27,
                        38,
                        40
                    ];
                    if (letter && nonLetters.indexOf(e.which) === -1) {
                        this.filterQuery.push(letter);
                        var string = this.filterQuery.join(''), newOptionEl = $(this.dropdownEl).find('li').filter(function(el) {
                            return $(el).text().toLowerCase().indexOf(string) === 0;
                        })[0];
                        if (newOptionEl) {
                            this.focusedIndex = $(newOptionEl).index();
                            this._focusFocusedItem();
                        }
                    }
                    this.filterTimeout = setTimeout(this._resetFilterQueryBound, 1000);
                }
            },
            {
                key: "_resetFilterQuery",
                value: function _resetFilterQuery() {
                    this.filterQuery = [];
                }
            },
            {
                key: "_resetDropdownStyles",
                value: function _resetDropdownStyles() {
                    this.$dropdownEl.css({
                        display: '',
                        width: '',
                        height: '',
                        left: '',
                        top: '',
                        'transform-origin': '',
                        transform: '',
                        opacity: ''
                    });
                }
            },
            {
                key: "_makeDropdownFocusable",
                value: function _makeDropdownFocusable() {
                    // Needed for arrow key navigation
                    this.dropdownEl.tabIndex = 0;
                    // Only set tabindex if it hasn't been set by user
                    $(this.dropdownEl).children().each(function(el) {
                        if (!el.getAttribute('tabindex')) el.setAttribute('tabindex', 0);
                    });
                }
            },
            {
                key: "_focusFocusedItem",
                value: function _focusFocusedItem() {
                    if (this.focusedIndex >= 0 && this.focusedIndex < this.dropdownEl.children.length && this.options.autoFocus) this.dropdownEl.children[this.focusedIndex].focus();
                }
            },
            {
                key: "_getDropdownPosition",
                value: function _getDropdownPosition() {
                    var offsetParentBRect = this.el.offsetParent.getBoundingClientRect();
                    var triggerBRect = this.el.getBoundingClientRect();
                    var dropdownBRect = this.dropdownEl.getBoundingClientRect();
                    var idealHeight = dropdownBRect.height;
                    var idealWidth = dropdownBRect.width;
                    var idealXPos = triggerBRect.left - dropdownBRect.left;
                    var idealYPos = triggerBRect.top - dropdownBRect.top;
                    var dropdownBounds = {
                        left: idealXPos,
                        top: idealYPos,
                        height: idealHeight,
                        width: idealWidth
                    };
                    // Countainer here will be closest ancestor with overflow: hidden
                    var closestOverflowParent = !!this.dropdownEl.offsetParent ? this.dropdownEl.offsetParent : this.dropdownEl.parentNode;
                    var alignments = M.checkPossibleAlignments(this.el, closestOverflowParent, dropdownBounds, this.options.coverTrigger ? 0 : triggerBRect.height);
                    var verticalAlignment = 'top';
                    var horizontalAlignment = this.options.alignment;
                    idealYPos += this.options.coverTrigger ? 0 : triggerBRect.height;
                    // Reset isScrollable
                    this.isScrollable = false;
                    if (!alignments.top) {
                        if (alignments.bottom) verticalAlignment = 'bottom';
                        else {
                            this.isScrollable = true;
                            // Determine which side has most space and cutoff at correct height
                            if (alignments.spaceOnTop > alignments.spaceOnBottom) {
                                verticalAlignment = 'bottom';
                                idealHeight += alignments.spaceOnTop;
                                idealYPos -= alignments.spaceOnTop;
                            } else idealHeight += alignments.spaceOnBottom;
                        }
                    }
                    // If preferred horizontal alignment is possible
                    if (!alignments[horizontalAlignment]) {
                        var oppositeAlignment = horizontalAlignment === 'left' ? 'right' : 'left';
                        if (alignments[oppositeAlignment]) horizontalAlignment = oppositeAlignment;
                        else // Determine which side has most space and cutoff at correct height
                        if (alignments.spaceOnLeft > alignments.spaceOnRight) {
                            horizontalAlignment = 'right';
                            idealWidth += alignments.spaceOnLeft;
                            idealXPos -= alignments.spaceOnLeft;
                        } else {
                            horizontalAlignment = 'left';
                            idealWidth += alignments.spaceOnRight;
                        }
                    }
                    if (verticalAlignment === 'bottom') idealYPos = idealYPos - dropdownBRect.height + (this.options.coverTrigger ? triggerBRect.height : 0);
                    if (horizontalAlignment === 'right') idealXPos = idealXPos - dropdownBRect.width + triggerBRect.width;
                    return {
                        x: idealXPos,
                        y: idealYPos,
                        verticalAlignment: verticalAlignment,
                        horizontalAlignment: horizontalAlignment,
                        height: idealHeight,
                        width: idealWidth
                    };
                }
            },
            {
                key: "_animateIn",
                value: function _animateIn() {
                    var _this11 = this;
                    anim.remove(this.dropdownEl);
                    anim({
                        targets: this.dropdownEl,
                        opacity: {
                            value: [
                                0,
                                1
                            ],
                            easing: 'easeOutQuad'
                        },
                        scaleX: [
                            0.3,
                            1
                        ],
                        scaleY: [
                            0.3,
                            1
                        ],
                        duration: this.options.inDuration,
                        easing: 'easeOutQuint',
                        complete: function(anim) {
                            if (_this11.options.autoFocus) _this11.dropdownEl.focus();
                            // onOpenEnd callback
                            if (typeof _this11.options.onOpenEnd === 'function') _this11.options.onOpenEnd.call(_this11, _this11.el);
                        }
                    });
                }
            },
            {
                key: "_animateOut",
                value: function _animateOut() {
                    var _this12 = this;
                    anim.remove(this.dropdownEl);
                    anim({
                        targets: this.dropdownEl,
                        opacity: {
                            value: 0,
                            easing: 'easeOutQuint'
                        },
                        scaleX: 0.3,
                        scaleY: 0.3,
                        duration: this.options.outDuration,
                        easing: 'easeOutQuint',
                        complete: function(anim) {
                            _this12._resetDropdownStyles();
                            // onCloseEnd callback
                            if (typeof _this12.options.onCloseEnd === 'function') _this12.options.onCloseEnd.call(_this12, _this12.el);
                        }
                    });
                }
            },
            {
                key: "_placeDropdown",
                value: function _placeDropdown() {
                    // Set width before calculating positionInfo
                    var idealWidth = this.options.constrainWidth ? this.el.getBoundingClientRect().width : this.dropdownEl.getBoundingClientRect().width;
                    this.dropdownEl.style.width = idealWidth + 'px';
                    var positionInfo = this._getDropdownPosition();
                    this.dropdownEl.style.left = positionInfo.x + 'px';
                    this.dropdownEl.style.top = positionInfo.y + 'px';
                    this.dropdownEl.style.height = positionInfo.height + 'px';
                    this.dropdownEl.style.width = positionInfo.width + 'px';
                    this.dropdownEl.style.transformOrigin = (positionInfo.horizontalAlignment === 'left' ? '0' : '100%') + " " + (positionInfo.verticalAlignment === 'top' ? '0' : '100%');
                }
            },
            {
                key: "open",
                value: function open() {
                    if (this.isOpen) return;
                    this.isOpen = true;
                    // onOpenStart callback
                    if (typeof this.options.onOpenStart === 'function') this.options.onOpenStart.call(this, this.el);
                    // Reset styles
                    this._resetDropdownStyles();
                    this.dropdownEl.style.display = 'block';
                    this._placeDropdown();
                    this._animateIn();
                    this._setupTemporaryEventHandlers();
                }
            },
            {
                key: "close",
                value: function close() {
                    if (!this.isOpen) return;
                    this.isOpen = false;
                    this.focusedIndex = -1;
                    // onCloseStart callback
                    if (typeof this.options.onCloseStart === 'function') this.options.onCloseStart.call(this, this.el);
                    this._animateOut();
                    this._removeTemporaryEventHandlers();
                    if (this.options.autoFocus) this.el.focus();
                }
            },
            {
                key: "recalculateDimensions",
                value: function recalculateDimensions() {
                    if (this.isOpen) {
                        this.$dropdownEl.css({
                            width: '',
                            height: '',
                            left: '',
                            top: '',
                            'transform-origin': ''
                        });
                        this._placeDropdown();
                    }
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Dropdown.__proto__ || Object.getPrototypeOf(Dropdown), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Dropdown;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Dropdown;
    }(Component);
    /**
   * @static
   * @memberof Dropdown
   */ Dropdown1._dropdowns = [];
    M.Dropdown = Dropdown1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Dropdown1, 'dropdown', 'M_Dropdown');
})(cash, M.anime);
(function($, anim) {
    var _defaults = {
        opacity: 0.5,
        inDuration: 250,
        outDuration: 250,
        onOpenStart: null,
        onOpenEnd: null,
        onCloseStart: null,
        onCloseEnd: null,
        preventScrolling: true,
        dismissible: true,
        startingTop: '4%',
        endingTop: '10%'
    };
    /**
   * @class
   *
   */ var Modal1 = function(_Component3) {
        _inherits(Modal, _Component3);
        /**
     * Construct Modal instance and set up overlay
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Modal(el, options) {
            _classCallCheck(this, Modal);
            var _this13 = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, Modal, el, options));
            _this13.el.M_Modal = _this13;
            /**
       * Options for the modal
       * @member Modal#options
       * @prop {Number} [opacity=0.5] - Opacity of the modal overlay
       * @prop {Number} [inDuration=250] - Length in ms of enter transition
       * @prop {Number} [outDuration=250] - Length in ms of exit transition
       * @prop {Function} onOpenStart - Callback function called before modal is opened
       * @prop {Function} onOpenEnd - Callback function called after modal is opened
       * @prop {Function} onCloseStart - Callback function called before modal is closed
       * @prop {Function} onCloseEnd - Callback function called after modal is closed
       * @prop {Boolean} [dismissible=true] - Allow modal to be dismissed by keyboard or overlay click
       * @prop {String} [startingTop='4%'] - startingTop
       * @prop {String} [endingTop='10%'] - endingTop
       */ _this13.options = $.extend({
            }, Modal.defaults, options);
            /**
       * Describes open/close state of modal
       * @type {Boolean}
       */ _this13.isOpen = false;
            _this13.id = _this13.$el.attr('id');
            _this13._openingTrigger = undefined;
            _this13.$overlay = $('<div class="modal-overlay"></div>');
            _this13.el.tabIndex = 0;
            _this13._nthModalOpened = 0;
            Modal._count++;
            _this13._setupEventHandlers();
            return _this13;
        }
        _createClass(Modal, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    Modal._count--;
                    this._removeEventHandlers();
                    this.el.removeAttribute('style');
                    this.$overlay.remove();
                    this.el.M_Modal = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleOverlayClickBound = this._handleOverlayClick.bind(this);
                    this._handleModalCloseClickBound = this._handleModalCloseClick.bind(this);
                    if (Modal._count === 1) document.body.addEventListener('click', this._handleTriggerClick);
                    this.$overlay[0].addEventListener('click', this._handleOverlayClickBound);
                    this.el.addEventListener('click', this._handleModalCloseClickBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    if (Modal._count === 0) document.body.removeEventListener('click', this._handleTriggerClick);
                    this.$overlay[0].removeEventListener('click', this._handleOverlayClickBound);
                    this.el.removeEventListener('click', this._handleModalCloseClickBound);
                }
            },
            {
                key: "_handleTriggerClick",
                value: function _handleTriggerClick(e) {
                    var $trigger = $(e.target).closest('.modal-trigger');
                    if ($trigger.length) {
                        var modalId = M.getIdFromTrigger($trigger[0]);
                        var modalInstance = document.getElementById(modalId).M_Modal;
                        if (modalInstance) modalInstance.open($trigger);
                        e.preventDefault();
                    }
                }
            },
            {
                key: "_handleOverlayClick",
                value: function _handleOverlayClick() {
                    if (this.options.dismissible) this.close();
                }
            },
            {
                key: "_handleModalCloseClick",
                value: function _handleModalCloseClick(e) {
                    var $closeTrigger = $(e.target).closest('.modal-close');
                    if ($closeTrigger.length) this.close();
                }
            },
            {
                key: "_handleKeydown",
                value: function _handleKeydown(e) {
                    // ESC key
                    if (e.keyCode === 27 && this.options.dismissible) this.close();
                }
            },
            {
                key: "_handleFocus",
                value: function _handleFocus(e) {
                    // Only trap focus if this modal is the last model opened (prevents loops in nested modals).
                    if (!this.el.contains(e.target) && this._nthModalOpened === Modal._modalsOpen) this.el.focus();
                }
            },
            {
                key: "_animateIn",
                value: function _animateIn() {
                    var _this14 = this;
                    // Set initial styles
                    $.extend(this.el.style, {
                        display: 'block',
                        opacity: 0
                    });
                    $.extend(this.$overlay[0].style, {
                        display: 'block',
                        opacity: 0
                    });
                    // Animate overlay
                    anim({
                        targets: this.$overlay[0],
                        opacity: this.options.opacity,
                        duration: this.options.inDuration,
                        easing: 'easeOutQuad'
                    });
                    // Define modal animation options
                    var enterAnimOptions = {
                        targets: this.el,
                        duration: this.options.inDuration,
                        easing: 'easeOutCubic',
                        // Handle modal onOpenEnd callback
                        complete: function() {
                            if (typeof _this14.options.onOpenEnd === 'function') _this14.options.onOpenEnd.call(_this14, _this14.el, _this14._openingTrigger);
                        }
                    };
                    // Bottom sheet animation
                    if (this.el.classList.contains('bottom-sheet')) {
                        $.extend(enterAnimOptions, {
                            bottom: 0,
                            opacity: 1
                        });
                        anim(enterAnimOptions);
                    // Normal modal animation
                    } else {
                        $.extend(enterAnimOptions, {
                            top: [
                                this.options.startingTop,
                                this.options.endingTop
                            ],
                            opacity: 1,
                            scaleX: [
                                0.8,
                                1
                            ],
                            scaleY: [
                                0.8,
                                1
                            ]
                        });
                        anim(enterAnimOptions);
                    }
                }
            },
            {
                key: "_animateOut",
                value: function _animateOut() {
                    var _this15 = this;
                    // Animate overlay
                    anim({
                        targets: this.$overlay[0],
                        opacity: 0,
                        duration: this.options.outDuration,
                        easing: 'easeOutQuart'
                    });
                    // Define modal animation options
                    var exitAnimOptions = {
                        targets: this.el,
                        duration: this.options.outDuration,
                        easing: 'easeOutCubic',
                        // Handle modal ready callback
                        complete: function() {
                            _this15.el.style.display = 'none';
                            _this15.$overlay.remove();
                            // Call onCloseEnd callback
                            if (typeof _this15.options.onCloseEnd === 'function') _this15.options.onCloseEnd.call(_this15, _this15.el);
                        }
                    };
                    // Bottom sheet animation
                    if (this.el.classList.contains('bottom-sheet')) {
                        $.extend(exitAnimOptions, {
                            bottom: '-100%',
                            opacity: 0
                        });
                        anim(exitAnimOptions);
                    // Normal modal animation
                    } else {
                        $.extend(exitAnimOptions, {
                            top: [
                                this.options.endingTop,
                                this.options.startingTop
                            ],
                            opacity: 0,
                            scaleX: 0.8,
                            scaleY: 0.8
                        });
                        anim(exitAnimOptions);
                    }
                }
            },
            {
                key: "open",
                value: function open($trigger) {
                    if (this.isOpen) return;
                    this.isOpen = true;
                    Modal._modalsOpen++;
                    this._nthModalOpened = Modal._modalsOpen;
                    // Set Z-Index based on number of currently open modals
                    this.$overlay[0].style.zIndex = 1000 + Modal._modalsOpen * 2;
                    this.el.style.zIndex = 1000 + Modal._modalsOpen * 2 + 1;
                    // Set opening trigger, undefined indicates modal was opened by javascript
                    this._openingTrigger = !!$trigger ? $trigger[0] : undefined;
                    // onOpenStart callback
                    if (typeof this.options.onOpenStart === 'function') this.options.onOpenStart.call(this, this.el, this._openingTrigger);
                    if (this.options.preventScrolling) document.body.style.overflow = 'hidden';
                    this.el.classList.add('open');
                    this.el.insertAdjacentElement('afterend', this.$overlay[0]);
                    if (this.options.dismissible) {
                        this._handleKeydownBound = this._handleKeydown.bind(this);
                        this._handleFocusBound = this._handleFocus.bind(this);
                        document.addEventListener('keydown', this._handleKeydownBound);
                        document.addEventListener('focus', this._handleFocusBound, true);
                    }
                    anim.remove(this.el);
                    anim.remove(this.$overlay[0]);
                    this._animateIn();
                    // Focus modal
                    this.el.focus();
                    return this;
                }
            },
            {
                key: "close",
                value: function close() {
                    if (!this.isOpen) return;
                    this.isOpen = false;
                    Modal._modalsOpen--;
                    this._nthModalOpened = 0;
                    // Call onCloseStart callback
                    if (typeof this.options.onCloseStart === 'function') this.options.onCloseStart.call(this, this.el);
                    this.el.classList.remove('open');
                    // Enable body scrolling only if there are no more modals open.
                    if (Modal._modalsOpen === 0) document.body.style.overflow = '';
                    if (this.options.dismissible) {
                        document.removeEventListener('keydown', this._handleKeydownBound);
                        document.removeEventListener('focus', this._handleFocusBound, true);
                    }
                    anim.remove(this.el);
                    anim.remove(this.$overlay[0]);
                    this._animateOut();
                    return this;
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Modal.__proto__ || Object.getPrototypeOf(Modal), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Modal;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Modal;
    }(Component);
    /**
   * @static
   * @memberof Modal
   */ Modal1._modalsOpen = 0;
    /**
   * @static
   * @memberof Modal
   */ Modal1._count = 0;
    M.Modal = Modal1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Modal1, 'modal', 'M_Modal');
})(cash, M.anime);
(function($, anim) {
    var _defaults = {
        inDuration: 275,
        outDuration: 200,
        onOpenStart: null,
        onOpenEnd: null,
        onCloseStart: null,
        onCloseEnd: null
    };
    /**
   * @class
   *
   */ var Materialbox1 = function(_Component4) {
        _inherits(Materialbox, _Component4);
        /**
     * Construct Materialbox instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Materialbox(el, options) {
            _classCallCheck(this, Materialbox);
            var _this16 = _possibleConstructorReturn(this, (Materialbox.__proto__ || Object.getPrototypeOf(Materialbox)).call(this, Materialbox, el, options));
            _this16.el.M_Materialbox = _this16;
            /**
       * Options for the modal
       * @member Materialbox#options
       * @prop {Number} [inDuration=275] - Length in ms of enter transition
       * @prop {Number} [outDuration=200] - Length in ms of exit transition
       * @prop {Function} onOpenStart - Callback function called before materialbox is opened
       * @prop {Function} onOpenEnd - Callback function called after materialbox is opened
       * @prop {Function} onCloseStart - Callback function called before materialbox is closed
       * @prop {Function} onCloseEnd - Callback function called after materialbox is closed
       */ _this16.options = $.extend({
            }, Materialbox.defaults, options);
            _this16.overlayActive = false;
            _this16.doneAnimating = true;
            _this16.placeholder = $('<div></div>').addClass('material-placeholder');
            _this16.originalWidth = 0;
            _this16.originalHeight = 0;
            _this16.originInlineStyles = _this16.$el.attr('style');
            _this16.caption = _this16.el.getAttribute('data-caption') || '';
            // Wrap
            _this16.$el.before(_this16.placeholder);
            _this16.placeholder.append(_this16.$el);
            _this16._setupEventHandlers();
            return _this16;
        }
        _createClass(Materialbox, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.el.M_Materialbox = undefined;
                    // Unwrap image
                    $(this.placeholder).after(this.el).remove();
                    this.$el.removeAttr('style');
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleMaterialboxClickBound = this._handleMaterialboxClick.bind(this);
                    this.el.addEventListener('click', this._handleMaterialboxClickBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('click', this._handleMaterialboxClickBound);
                }
            },
            {
                key: "_handleMaterialboxClick",
                value: function _handleMaterialboxClick(e) {
                    // If already modal, return to original
                    if (this.doneAnimating === false || this.overlayActive && this.doneAnimating) this.close();
                    else this.open();
                }
            },
            {
                key: "_handleWindowScroll",
                value: function _handleWindowScroll() {
                    if (this.overlayActive) this.close();
                }
            },
            {
                key: "_handleWindowResize",
                value: function _handleWindowResize() {
                    if (this.overlayActive) this.close();
                }
            },
            {
                key: "_handleWindowEscape",
                value: function _handleWindowEscape(e) {
                    // ESC key
                    if (e.keyCode === 27 && this.doneAnimating && this.overlayActive) this.close();
                }
            },
            {
                key: "_makeAncestorsOverflowVisible",
                value: function _makeAncestorsOverflowVisible() {
                    this.ancestorsChanged = $();
                    var ancestor = this.placeholder[0].parentNode;
                    while(ancestor !== null && !$(ancestor).is(document)){
                        var curr = $(ancestor);
                        if (curr.css('overflow') !== 'visible') {
                            curr.css('overflow', 'visible');
                            if (this.ancestorsChanged === undefined) this.ancestorsChanged = curr;
                            else this.ancestorsChanged = this.ancestorsChanged.add(curr);
                        }
                        ancestor = ancestor.parentNode;
                    }
                }
            },
            {
                key: "_animateImageIn",
                value: function _animateImageIn() {
                    var _this17 = this;
                    var animOptions = {
                        targets: this.el,
                        height: [
                            this.originalHeight,
                            this.newHeight
                        ],
                        width: [
                            this.originalWidth,
                            this.newWidth
                        ],
                        left: M.getDocumentScrollLeft() + this.windowWidth / 2 - this.placeholder.offset().left - this.newWidth / 2,
                        top: M.getDocumentScrollTop() + this.windowHeight / 2 - this.placeholder.offset().top - this.newHeight / 2,
                        duration: this.options.inDuration,
                        easing: 'easeOutQuad',
                        complete: function() {
                            _this17.doneAnimating = true;
                            // onOpenEnd callback
                            if (typeof _this17.options.onOpenEnd === 'function') _this17.options.onOpenEnd.call(_this17, _this17.el);
                        }
                    };
                    // Override max-width or max-height if needed
                    this.maxWidth = this.$el.css('max-width');
                    this.maxHeight = this.$el.css('max-height');
                    if (this.maxWidth !== 'none') animOptions.maxWidth = this.newWidth;
                    if (this.maxHeight !== 'none') animOptions.maxHeight = this.newHeight;
                    anim(animOptions);
                }
            },
            {
                key: "_animateImageOut",
                value: function _animateImageOut() {
                    var _this18 = this;
                    var animOptions = {
                        targets: this.el,
                        width: this.originalWidth,
                        height: this.originalHeight,
                        left: 0,
                        top: 0,
                        duration: this.options.outDuration,
                        easing: 'easeOutQuad',
                        complete: function() {
                            _this18.placeholder.css({
                                height: '',
                                width: '',
                                position: '',
                                top: '',
                                left: ''
                            });
                            // Revert to width or height attribute
                            if (_this18.attrWidth) _this18.$el.attr('width', _this18.attrWidth);
                            if (_this18.attrHeight) _this18.$el.attr('height', _this18.attrHeight);
                            _this18.$el.removeAttr('style');
                            _this18.originInlineStyles && _this18.$el.attr('style', _this18.originInlineStyles);
                            // Remove class
                            _this18.$el.removeClass('active');
                            _this18.doneAnimating = true;
                            // Remove overflow overrides on ancestors
                            if (_this18.ancestorsChanged.length) _this18.ancestorsChanged.css('overflow', '');
                            // onCloseEnd callback
                            if (typeof _this18.options.onCloseEnd === 'function') _this18.options.onCloseEnd.call(_this18, _this18.el);
                        }
                    };
                    anim(animOptions);
                }
            },
            {
                key: "_updateVars",
                value: function _updateVars() {
                    this.windowWidth = window.innerWidth;
                    this.windowHeight = window.innerHeight;
                    this.caption = this.el.getAttribute('data-caption') || '';
                }
            },
            {
                key: "open",
                value: function open() {
                    var _this19 = this;
                    this._updateVars();
                    this.originalWidth = this.el.getBoundingClientRect().width;
                    this.originalHeight = this.el.getBoundingClientRect().height;
                    // Set states
                    this.doneAnimating = false;
                    this.$el.addClass('active');
                    this.overlayActive = true;
                    // onOpenStart callback
                    if (typeof this.options.onOpenStart === 'function') this.options.onOpenStart.call(this, this.el);
                    // Set positioning for placeholder
                    this.placeholder.css({
                        width: this.placeholder[0].getBoundingClientRect().width + 'px',
                        height: this.placeholder[0].getBoundingClientRect().height + 'px',
                        position: 'relative',
                        top: 0,
                        left: 0
                    });
                    this._makeAncestorsOverflowVisible();
                    // Set css on origin
                    this.$el.css({
                        position: 'absolute',
                        'z-index': 1000,
                        'will-change': 'left, top, width, height'
                    });
                    // Change from width or height attribute to css
                    this.attrWidth = this.$el.attr('width');
                    this.attrHeight = this.$el.attr('height');
                    if (this.attrWidth) {
                        this.$el.css('width', this.attrWidth + 'px');
                        this.$el.removeAttr('width');
                    }
                    if (this.attrHeight) {
                        this.$el.css('width', this.attrHeight + 'px');
                        this.$el.removeAttr('height');
                    }
                    // Add overlay
                    this.$overlay = $('<div id="materialbox-overlay"></div>').css({
                        opacity: 0
                    }).one('click', function() {
                        if (_this19.doneAnimating) _this19.close();
                    });
                    // Put before in origin image to preserve z-index layering.
                    this.$el.before(this.$overlay);
                    // Set dimensions if needed
                    var overlayOffset = this.$overlay[0].getBoundingClientRect();
                    this.$overlay.css({
                        width: this.windowWidth + 'px',
                        height: this.windowHeight + 'px',
                        left: -1 * overlayOffset.left + 'px',
                        top: -1 * overlayOffset.top + 'px'
                    });
                    anim.remove(this.el);
                    anim.remove(this.$overlay[0]);
                    // Animate Overlay
                    anim({
                        targets: this.$overlay[0],
                        opacity: 1,
                        duration: this.options.inDuration,
                        easing: 'easeOutQuad'
                    });
                    // Add and animate caption if it exists
                    if (this.caption !== '') {
                        if (this.$photocaption) anim.remove(this.$photoCaption[0]);
                        this.$photoCaption = $('<div class="materialbox-caption"></div>');
                        this.$photoCaption.text(this.caption);
                        $('body').append(this.$photoCaption);
                        this.$photoCaption.css({
                            display: 'inline'
                        });
                        anim({
                            targets: this.$photoCaption[0],
                            opacity: 1,
                            duration: this.options.inDuration,
                            easing: 'easeOutQuad'
                        });
                    }
                    // Resize Image
                    var ratio = 0;
                    var widthPercent = this.originalWidth / this.windowWidth;
                    var heightPercent = this.originalHeight / this.windowHeight;
                    this.newWidth = 0;
                    this.newHeight = 0;
                    if (widthPercent > heightPercent) {
                        ratio = this.originalHeight / this.originalWidth;
                        this.newWidth = this.windowWidth * 0.9;
                        this.newHeight = this.windowWidth * 0.9 * ratio;
                    } else {
                        ratio = this.originalWidth / this.originalHeight;
                        this.newWidth = this.windowHeight * 0.9 * ratio;
                        this.newHeight = this.windowHeight * 0.9;
                    }
                    this._animateImageIn();
                    // Handle Exit triggers
                    this._handleWindowScrollBound = this._handleWindowScroll.bind(this);
                    this._handleWindowResizeBound = this._handleWindowResize.bind(this);
                    this._handleWindowEscapeBound = this._handleWindowEscape.bind(this);
                    window.addEventListener('scroll', this._handleWindowScrollBound);
                    window.addEventListener('resize', this._handleWindowResizeBound);
                    window.addEventListener('keyup', this._handleWindowEscapeBound);
                }
            },
            {
                key: "close",
                value: function close() {
                    var _this20 = this;
                    this._updateVars();
                    this.doneAnimating = false;
                    // onCloseStart callback
                    if (typeof this.options.onCloseStart === 'function') this.options.onCloseStart.call(this, this.el);
                    anim.remove(this.el);
                    anim.remove(this.$overlay[0]);
                    if (this.caption !== '') anim.remove(this.$photoCaption[0]);
                    // disable exit handlers
                    window.removeEventListener('scroll', this._handleWindowScrollBound);
                    window.removeEventListener('resize', this._handleWindowResizeBound);
                    window.removeEventListener('keyup', this._handleWindowEscapeBound);
                    anim({
                        targets: this.$overlay[0],
                        opacity: 0,
                        duration: this.options.outDuration,
                        easing: 'easeOutQuad',
                        complete: function() {
                            _this20.overlayActive = false;
                            _this20.$overlay.remove();
                        }
                    });
                    this._animateImageOut();
                    // Remove Caption + reset css settings on image
                    if (this.caption !== '') anim({
                        targets: this.$photoCaption[0],
                        opacity: 0,
                        duration: this.options.outDuration,
                        easing: 'easeOutQuad',
                        complete: function() {
                            _this20.$photoCaption.remove();
                        }
                    });
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Materialbox.__proto__ || Object.getPrototypeOf(Materialbox), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Materialbox;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Materialbox;
    }(Component);
    M.Materialbox = Materialbox1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Materialbox1, 'materialbox', 'M_Materialbox');
})(cash, M.anime);
(function($) {
    var _defaults = {
        responsiveThreshold: 0 // breakpoint for swipeable
    };
    var Parallax1 = function(_Component5) {
        _inherits(Parallax, _Component5);
        function Parallax(el1, options) {
            _classCallCheck(this, Parallax);
            var _this21 = _possibleConstructorReturn(this, (Parallax.__proto__ || Object.getPrototypeOf(Parallax)).call(this, Parallax, el1, options));
            _this21.el.M_Parallax = _this21;
            /**
       * Options for the Parallax
       * @member Parallax#options
       * @prop {Number} responsiveThreshold
       */ _this21.options = $.extend({
            }, Parallax.defaults, options);
            _this21._enabled = window.innerWidth > _this21.options.responsiveThreshold;
            _this21.$img = _this21.$el.find('img').first();
            _this21.$img.each(function() {
                var el = this;
                if (el.complete) $(el).trigger('load');
            });
            _this21._updateParallax();
            _this21._setupEventHandlers();
            _this21._setupStyles();
            Parallax._parallaxes.push(_this21);
            return _this21;
        }
        _createClass(Parallax, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    Parallax._parallaxes.splice(Parallax._parallaxes.indexOf(this), 1);
                    this.$img[0].style.transform = '';
                    this._removeEventHandlers();
                    this.$el[0].M_Parallax = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleImageLoadBound = this._handleImageLoad.bind(this);
                    this.$img[0].addEventListener('load', this._handleImageLoadBound);
                    if (Parallax._parallaxes.length === 0) {
                        Parallax._handleScrollThrottled = M.throttle(Parallax._handleScroll, 5);
                        window.addEventListener('scroll', Parallax._handleScrollThrottled);
                        Parallax._handleWindowResizeThrottled = M.throttle(Parallax._handleWindowResize, 5);
                        window.addEventListener('resize', Parallax._handleWindowResizeThrottled);
                    }
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.$img[0].removeEventListener('load', this._handleImageLoadBound);
                    if (Parallax._parallaxes.length === 0) {
                        window.removeEventListener('scroll', Parallax._handleScrollThrottled);
                        window.removeEventListener('resize', Parallax._handleWindowResizeThrottled);
                    }
                }
            },
            {
                key: "_setupStyles",
                value: function _setupStyles() {
                    this.$img[0].style.opacity = 1;
                }
            },
            {
                key: "_handleImageLoad",
                value: function _handleImageLoad() {
                    this._updateParallax();
                }
            },
            {
                key: "_updateParallax",
                value: function _updateParallax() {
                    var containerHeight = this.$el.height() > 0 ? this.el.parentNode.offsetHeight : 500;
                    var imgHeight = this.$img[0].offsetHeight;
                    var parallaxDist = imgHeight - containerHeight;
                    var bottom = this.$el.offset().top + containerHeight;
                    var top = this.$el.offset().top;
                    var scrollTop = M.getDocumentScrollTop();
                    var windowHeight = window.innerHeight;
                    var windowBottom = scrollTop + windowHeight;
                    var percentScrolled = (windowBottom - top) / (containerHeight + windowHeight);
                    var parallax = parallaxDist * percentScrolled;
                    if (!this._enabled) this.$img[0].style.transform = '';
                    else if (bottom > scrollTop && top < scrollTop + windowHeight) this.$img[0].style.transform = "translate3D(-50%, " + parallax + "px, 0)";
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Parallax.__proto__ || Object.getPrototypeOf(Parallax), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Parallax;
                }
            },
            {
                key: "_handleScroll",
                value: function _handleScroll() {
                    for(var i = 0; i < Parallax._parallaxes.length; i++){
                        var parallaxInstance = Parallax._parallaxes[i];
                        parallaxInstance._updateParallax.call(parallaxInstance);
                    }
                }
            },
            {
                key: "_handleWindowResize",
                value: function _handleWindowResize() {
                    for(var i = 0; i < Parallax._parallaxes.length; i++){
                        var parallaxInstance = Parallax._parallaxes[i];
                        parallaxInstance._enabled = window.innerWidth > parallaxInstance.options.responsiveThreshold;
                    }
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Parallax;
    }(Component);
    /**
   * @static
   * @memberof Parallax
   */ Parallax1._parallaxes = [];
    M.Parallax = Parallax1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Parallax1, 'parallax', 'M_Parallax');
})(cash);
(function($, anim) {
    var _defaults = {
        duration: 300,
        onShow: null,
        swipeable: false,
        responsiveThreshold: Infinity // breakpoint for swipeable
    };
    /**
   * @class
   *
   */ var Tabs1 = function(_Component6) {
        _inherits(Tabs, _Component6);
        /**
     * Construct Tabs instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Tabs(el, options) {
            _classCallCheck(this, Tabs);
            var _this22 = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, Tabs, el, options));
            _this22.el.M_Tabs = _this22;
            /**
       * Options for the Tabs
       * @member Tabs#options
       * @prop {Number} duration
       * @prop {Function} onShow
       * @prop {Boolean} swipeable
       * @prop {Number} responsiveThreshold
       */ _this22.options = $.extend({
            }, Tabs.defaults, options);
            // Setup
            _this22.$tabLinks = _this22.$el.children('li.tab').children('a');
            _this22.index = 0;
            _this22._setupActiveTabLink();
            // Setup tabs content
            if (_this22.options.swipeable) _this22._setupSwipeableTabs();
            else _this22._setupNormalTabs();
            // Setup tabs indicator after content to ensure accurate widths
            _this22._setTabsAndTabWidth();
            _this22._createIndicator();
            _this22._setupEventHandlers();
            return _this22;
        }
        _createClass(Tabs, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this._indicator.parentNode.removeChild(this._indicator);
                    if (this.options.swipeable) this._teardownSwipeableTabs();
                    else this._teardownNormalTabs();
                    this.$el[0].M_Tabs = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleWindowResizeBound = this._handleWindowResize.bind(this);
                    window.addEventListener('resize', this._handleWindowResizeBound);
                    this._handleTabClickBound = this._handleTabClick.bind(this);
                    this.el.addEventListener('click', this._handleTabClickBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    window.removeEventListener('resize', this._handleWindowResizeBound);
                    this.el.removeEventListener('click', this._handleTabClickBound);
                }
            },
            {
                key: "_handleWindowResize",
                value: function _handleWindowResize() {
                    this._setTabsAndTabWidth();
                    if (this.tabWidth !== 0 && this.tabsWidth !== 0) {
                        this._indicator.style.left = this._calcLeftPos(this.$activeTabLink) + 'px';
                        this._indicator.style.right = this._calcRightPos(this.$activeTabLink) + 'px';
                    }
                }
            },
            {
                key: "_handleTabClick",
                value: function _handleTabClick(e) {
                    var _this23 = this;
                    var tab = $(e.target).closest('li.tab');
                    var tabLink = $(e.target).closest('a');
                    // Handle click on tab link only
                    if (!tabLink.length || !tabLink.parent().hasClass('tab')) return;
                    if (tab.hasClass('disabled')) {
                        e.preventDefault();
                        return;
                    }
                    // Act as regular link if target attribute is specified.
                    if (!!tabLink.attr('target')) return;
                    // Make the old tab inactive.
                    this.$activeTabLink.removeClass('active');
                    var $oldContent = this.$content;
                    // Update the variables with the new link and content
                    this.$activeTabLink = tabLink;
                    this.$content = $(M.escapeHash(tabLink[0].hash));
                    this.$tabLinks = this.$el.children('li.tab').children('a');
                    // Make the tab active.
                    this.$activeTabLink.addClass('active');
                    var prevIndex = this.index;
                    this.index = Math.max(this.$tabLinks.index(tabLink), 0);
                    // Swap content
                    if (this.options.swipeable) {
                        if (this._tabsCarousel) this._tabsCarousel.set(this.index, function() {
                            if (typeof _this23.options.onShow === 'function') _this23.options.onShow.call(_this23, _this23.$content[0]);
                        });
                    } else if (this.$content.length) {
                        this.$content[0].style.display = 'block';
                        this.$content.addClass('active');
                        if (typeof this.options.onShow === 'function') this.options.onShow.call(this, this.$content[0]);
                        if ($oldContent.length && !$oldContent.is(this.$content)) {
                            $oldContent[0].style.display = 'none';
                            $oldContent.removeClass('active');
                        }
                    }
                    // Update widths after content is swapped (scrollbar bugfix)
                    this._setTabsAndTabWidth();
                    // Update indicator
                    this._animateIndicator(prevIndex);
                    // Prevent the anchor's default click action
                    e.preventDefault();
                }
            },
            {
                key: "_createIndicator",
                value: function _createIndicator() {
                    var _this24 = this;
                    var indicator = document.createElement('li');
                    indicator.classList.add('indicator');
                    this.el.appendChild(indicator);
                    this._indicator = indicator;
                    setTimeout(function() {
                        _this24._indicator.style.left = _this24._calcLeftPos(_this24.$activeTabLink) + 'px';
                        _this24._indicator.style.right = _this24._calcRightPos(_this24.$activeTabLink) + 'px';
                    }, 0);
                }
            },
            {
                key: "_setupActiveTabLink",
                value: function _setupActiveTabLink() {
                    // If the location.hash matches one of the links, use that as the active tab.
                    this.$activeTabLink = $(this.$tabLinks.filter('[href="' + location.hash + '"]'));
                    // If no match is found, use the first link or any with class 'active' as the initial active tab.
                    if (this.$activeTabLink.length === 0) this.$activeTabLink = this.$el.children('li.tab').children('a.active').first();
                    if (this.$activeTabLink.length === 0) this.$activeTabLink = this.$el.children('li.tab').children('a').first();
                    this.$tabLinks.removeClass('active');
                    this.$activeTabLink[0].classList.add('active');
                    this.index = Math.max(this.$tabLinks.index(this.$activeTabLink), 0);
                    if (this.$activeTabLink.length) {
                        this.$content = $(M.escapeHash(this.$activeTabLink[0].hash));
                        this.$content.addClass('active');
                    }
                }
            },
            {
                key: "_setupSwipeableTabs",
                value: function _setupSwipeableTabs() {
                    var _this25 = this;
                    // Change swipeable according to responsive threshold
                    if (window.innerWidth > this.options.responsiveThreshold) this.options.swipeable = false;
                    var $tabsContent = $();
                    this.$tabLinks.each(function(link) {
                        var $currContent = $(M.escapeHash(link.hash));
                        $currContent.addClass('carousel-item');
                        $tabsContent = $tabsContent.add($currContent);
                    });
                    var $tabsWrapper = $('<div class="tabs-content carousel carousel-slider"></div>');
                    $tabsContent.first().before($tabsWrapper);
                    $tabsWrapper.append($tabsContent);
                    $tabsContent[0].style.display = '';
                    // Keep active tab index to set initial carousel slide
                    var activeTabIndex = this.$activeTabLink.closest('.tab').index();
                    this._tabsCarousel = M.Carousel.init($tabsWrapper[0], {
                        fullWidth: true,
                        noWrap: true,
                        onCycleTo: function(item) {
                            var prevIndex = _this25.index;
                            _this25.index = $(item).index();
                            _this25.$activeTabLink.removeClass('active');
                            _this25.$activeTabLink = _this25.$tabLinks.eq(_this25.index);
                            _this25.$activeTabLink.addClass('active');
                            _this25._animateIndicator(prevIndex);
                            if (typeof _this25.options.onShow === 'function') _this25.options.onShow.call(_this25, _this25.$content[0]);
                        }
                    });
                    // Set initial carousel slide to active tab
                    this._tabsCarousel.set(activeTabIndex);
                }
            },
            {
                key: "_teardownSwipeableTabs",
                value: function _teardownSwipeableTabs() {
                    var $tabsWrapper = this._tabsCarousel.$el;
                    this._tabsCarousel.destroy();
                    // Unwrap
                    $tabsWrapper.after($tabsWrapper.children());
                    $tabsWrapper.remove();
                }
            },
            {
                key: "_setupNormalTabs",
                value: function _setupNormalTabs() {
                    // Hide Tabs Content
                    this.$tabLinks.not(this.$activeTabLink).each(function(link) {
                        if (!!link.hash) {
                            var $currContent = $(M.escapeHash(link.hash));
                            if ($currContent.length) $currContent[0].style.display = 'none';
                        }
                    });
                }
            },
            {
                key: "_teardownNormalTabs",
                value: function _teardownNormalTabs() {
                    // show Tabs Content
                    this.$tabLinks.each(function(link) {
                        if (!!link.hash) {
                            var $currContent = $(M.escapeHash(link.hash));
                            if ($currContent.length) $currContent[0].style.display = '';
                        }
                    });
                }
            },
            {
                key: "_setTabsAndTabWidth",
                value: function _setTabsAndTabWidth() {
                    this.tabsWidth = this.$el.width();
                    this.tabWidth = Math.max(this.tabsWidth, this.el.scrollWidth) / this.$tabLinks.length;
                }
            },
            {
                key: "_calcRightPos",
                value: function _calcRightPos(el) {
                    return Math.ceil(this.tabsWidth - el.position().left - el[0].getBoundingClientRect().width);
                }
            },
            {
                key: "_calcLeftPos",
                value: function _calcLeftPos(el) {
                    return Math.floor(el.position().left);
                }
            },
            {
                key: "updateTabIndicator",
                value: function updateTabIndicator() {
                    this._setTabsAndTabWidth();
                    this._animateIndicator(this.index);
                }
            },
            {
                key: "_animateIndicator",
                value: function _animateIndicator(prevIndex) {
                    var leftDelay = 0, rightDelay = 0;
                    if (this.index - prevIndex >= 0) leftDelay = 90;
                    else rightDelay = 90;
                    // Animate
                    var animOptions = {
                        targets: this._indicator,
                        left: {
                            value: this._calcLeftPos(this.$activeTabLink),
                            delay: leftDelay
                        },
                        right: {
                            value: this._calcRightPos(this.$activeTabLink),
                            delay: rightDelay
                        },
                        duration: this.options.duration,
                        easing: 'easeOutQuad'
                    };
                    anim.remove(this._indicator);
                    anim(animOptions);
                }
            },
            {
                key: "select",
                value: function select(tabId) {
                    var tab = this.$tabLinks.filter('[href="#' + tabId + '"]');
                    if (tab.length) tab.trigger('click');
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Tabs.__proto__ || Object.getPrototypeOf(Tabs), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Tabs;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Tabs;
    }(Component);
    M.Tabs = Tabs1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Tabs1, 'tabs', 'M_Tabs');
})(cash, M.anime);
(function($, anim) {
    var _defaults = {
        exitDelay: 200,
        enterDelay: 0,
        html: null,
        margin: 5,
        inDuration: 250,
        outDuration: 200,
        position: 'bottom',
        transitionMovement: 10
    };
    /**
   * @class
   *
   */ var Tooltip1 = function(_Component7) {
        _inherits(Tooltip, _Component7);
        /**
     * Construct Tooltip instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Tooltip(el, options) {
            _classCallCheck(this, Tooltip);
            var _this26 = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, Tooltip, el, options));
            _this26.el.M_Tooltip = _this26;
            _this26.options = $.extend({
            }, Tooltip.defaults, options);
            _this26.isOpen = false;
            _this26.isHovered = false;
            _this26.isFocused = false;
            _this26._appendTooltipEl();
            _this26._setupEventHandlers();
            return _this26;
        }
        _createClass(Tooltip, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    $(this.tooltipEl).remove();
                    this._removeEventHandlers();
                    this.el.M_Tooltip = undefined;
                }
            },
            {
                key: "_appendTooltipEl",
                value: function _appendTooltipEl() {
                    var tooltipEl = document.createElement('div');
                    tooltipEl.classList.add('material-tooltip');
                    this.tooltipEl = tooltipEl;
                    var tooltipContentEl = document.createElement('div');
                    tooltipContentEl.classList.add('tooltip-content');
                    tooltipContentEl.innerHTML = this.options.html;
                    tooltipEl.appendChild(tooltipContentEl);
                    document.body.appendChild(tooltipEl);
                }
            },
            {
                key: "_updateTooltipContent",
                value: function _updateTooltipContent() {
                    this.tooltipEl.querySelector('.tooltip-content').innerHTML = this.options.html;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleMouseEnterBound = this._handleMouseEnter.bind(this);
                    this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);
                    this._handleFocusBound = this._handleFocus.bind(this);
                    this._handleBlurBound = this._handleBlur.bind(this);
                    this.el.addEventListener('mouseenter', this._handleMouseEnterBound);
                    this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);
                    this.el.addEventListener('focus', this._handleFocusBound, true);
                    this.el.addEventListener('blur', this._handleBlurBound, true);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);
                    this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);
                    this.el.removeEventListener('focus', this._handleFocusBound, true);
                    this.el.removeEventListener('blur', this._handleBlurBound, true);
                }
            },
            {
                key: "open",
                value: function open(isManual) {
                    if (this.isOpen) return;
                    isManual = isManual === undefined ? true : undefined; // Default value true
                    this.isOpen = true;
                    // Update tooltip content with HTML attribute options
                    this.options = $.extend({
                    }, this.options, this._getAttributeOptions());
                    this._updateTooltipContent();
                    this._setEnterDelayTimeout(isManual);
                }
            },
            {
                key: "close",
                value: function close() {
                    if (!this.isOpen) return;
                    this.isHovered = false;
                    this.isFocused = false;
                    this.isOpen = false;
                    this._setExitDelayTimeout();
                }
            },
            {
                key: "_setExitDelayTimeout",
                value: function _setExitDelayTimeout() {
                    var _this27 = this;
                    clearTimeout(this._exitDelayTimeout);
                    this._exitDelayTimeout = setTimeout(function() {
                        if (_this27.isHovered || _this27.isFocused) return;
                        _this27._animateOut();
                    }, this.options.exitDelay);
                }
            },
            {
                key: "_setEnterDelayTimeout",
                value: function _setEnterDelayTimeout(isManual) {
                    var _this28 = this;
                    clearTimeout(this._enterDelayTimeout);
                    this._enterDelayTimeout = setTimeout(function() {
                        if (!_this28.isHovered && !_this28.isFocused && !isManual) return;
                        _this28._animateIn();
                    }, this.options.enterDelay);
                }
            },
            {
                key: "_positionTooltip",
                value: function _positionTooltip() {
                    var origin = this.el, tooltip = this.tooltipEl, originHeight = origin.offsetHeight, originWidth = origin.offsetWidth, tooltipHeight = tooltip.offsetHeight, tooltipWidth = tooltip.offsetWidth, newCoordinates = void 0, margin = this.options.margin, targetTop = void 0, targetLeft = void 0;
                    this.xMovement = 0, this.yMovement = 0;
                    targetTop = origin.getBoundingClientRect().top + M.getDocumentScrollTop();
                    targetLeft = origin.getBoundingClientRect().left + M.getDocumentScrollLeft();
                    if (this.options.position === 'top') {
                        targetTop += -tooltipHeight - margin;
                        targetLeft += originWidth / 2 - tooltipWidth / 2;
                        this.yMovement = -this.options.transitionMovement;
                    } else if (this.options.position === 'right') {
                        targetTop += originHeight / 2 - tooltipHeight / 2;
                        targetLeft += originWidth + margin;
                        this.xMovement = this.options.transitionMovement;
                    } else if (this.options.position === 'left') {
                        targetTop += originHeight / 2 - tooltipHeight / 2;
                        targetLeft += -tooltipWidth - margin;
                        this.xMovement = -this.options.transitionMovement;
                    } else {
                        targetTop += originHeight + margin;
                        targetLeft += originWidth / 2 - tooltipWidth / 2;
                        this.yMovement = this.options.transitionMovement;
                    }
                    newCoordinates = this._repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
                    $(tooltip).css({
                        top: newCoordinates.y + 'px',
                        left: newCoordinates.x + 'px'
                    });
                }
            },
            {
                key: "_repositionWithinScreen",
                value: function _repositionWithinScreen(x, y, width, height) {
                    var scrollLeft = M.getDocumentScrollLeft();
                    var scrollTop = M.getDocumentScrollTop();
                    var newX = x - scrollLeft;
                    var newY = y - scrollTop;
                    var bounding = {
                        left: newX,
                        top: newY,
                        width: width,
                        height: height
                    };
                    var offset = this.options.margin + this.options.transitionMovement;
                    var edges = M.checkWithinContainer(document.body, bounding, offset);
                    if (edges.left) newX = offset;
                    else if (edges.right) newX -= newX + width - window.innerWidth;
                    if (edges.top) newY = offset;
                    else if (edges.bottom) newY -= newY + height - window.innerHeight;
                    return {
                        x: newX + scrollLeft,
                        y: newY + scrollTop
                    };
                }
            },
            {
                key: "_animateIn",
                value: function _animateIn() {
                    this._positionTooltip();
                    this.tooltipEl.style.visibility = 'visible';
                    anim.remove(this.tooltipEl);
                    anim({
                        targets: this.tooltipEl,
                        opacity: 1,
                        translateX: this.xMovement,
                        translateY: this.yMovement,
                        duration: this.options.inDuration,
                        easing: 'easeOutCubic'
                    });
                }
            },
            {
                key: "_animateOut",
                value: function _animateOut() {
                    anim.remove(this.tooltipEl);
                    anim({
                        targets: this.tooltipEl,
                        opacity: 0,
                        translateX: 0,
                        translateY: 0,
                        duration: this.options.outDuration,
                        easing: 'easeOutCubic'
                    });
                }
            },
            {
                key: "_handleMouseEnter",
                value: function _handleMouseEnter() {
                    this.isHovered = true;
                    this.isFocused = false; // Allows close of tooltip when opened by focus.
                    this.open(false);
                }
            },
            {
                key: "_handleMouseLeave",
                value: function _handleMouseLeave() {
                    this.isHovered = false;
                    this.isFocused = false; // Allows close of tooltip when opened by focus.
                    this.close();
                }
            },
            {
                key: "_handleFocus",
                value: function _handleFocus() {
                    if (M.tabPressed) {
                        this.isFocused = true;
                        this.open(false);
                    }
                }
            },
            {
                key: "_handleBlur",
                value: function _handleBlur() {
                    this.isFocused = false;
                    this.close();
                }
            },
            {
                key: "_getAttributeOptions",
                value: function _getAttributeOptions() {
                    var attributeOptions = {
                    };
                    var tooltipTextOption = this.el.getAttribute('data-tooltip');
                    var positionOption = this.el.getAttribute('data-position');
                    if (tooltipTextOption) attributeOptions.html = tooltipTextOption;
                    if (positionOption) attributeOptions.position = positionOption;
                    return attributeOptions;
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Tooltip.__proto__ || Object.getPrototypeOf(Tooltip), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Tooltip;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Tooltip;
    }(Component);
    M.Tooltip = Tooltip1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Tooltip1, 'tooltip', 'M_Tooltip');
})(cash, M.anime);
(function(window) {
    var Waves = Waves || {
    };
    var $$ = document.querySelectorAll.bind(document);
    // Find exact position of element
    function isWindow(obj) {
        return obj !== null && obj === obj.window;
    }
    function getWindow(elem) {
        return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    function offset(elem) {
        var docElem, win, box = {
            top: 0,
            left: 0
        }, doc = elem && elem.ownerDocument;
        docElem = doc.documentElement;
        if (typeof elem.getBoundingClientRect !== "undefined") box = elem.getBoundingClientRect();
        win = getWindow(doc);
        return {
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
        };
    }
    function convertStyle(obj) {
        var style = '';
        for(var a in obj)if (obj.hasOwnProperty(a)) style += a + ':' + obj[a] + ';';
        return style;
    }
    var Effect = {
        // Effect delay
        duration: 750,
        show: function(e, element) {
            // Disable right click
            if (e.button === 2) return false;
            var el = element || this;
            // Create ripple
            var ripple = document.createElement('div');
            ripple.className = 'waves-ripple';
            el.appendChild(ripple);
            // Get click coordinate and element witdh
            var pos = offset(el);
            var relativeY = e.pageY - pos.top;
            var relativeX = e.pageX - pos.left;
            var scale = 'scale(' + el.clientWidth / 100 * 10 + ')';
            // Support for touch devices
            if ('touches' in e) {
                relativeY = e.touches[0].pageY - pos.top;
                relativeX = e.touches[0].pageX - pos.left;
            }
            // Attach data to element
            ripple.setAttribute('data-hold', Date.now());
            ripple.setAttribute('data-scale', scale);
            ripple.setAttribute('data-x', relativeX);
            ripple.setAttribute('data-y', relativeY);
            // Set ripple position
            var rippleStyle = {
                'top': relativeY + 'px',
                'left': relativeX + 'px'
            };
            ripple.className = ripple.className + ' waves-notransition';
            ripple.setAttribute('style', convertStyle(rippleStyle));
            ripple.className = ripple.className.replace('waves-notransition', '');
            // Scale the ripple
            rippleStyle['-webkit-transform'] = scale;
            rippleStyle['-moz-transform'] = scale;
            rippleStyle['-ms-transform'] = scale;
            rippleStyle['-o-transform'] = scale;
            rippleStyle.transform = scale;
            rippleStyle.opacity = '1';
            rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';
            rippleStyle['-moz-transition-duration'] = Effect.duration + 'ms';
            rippleStyle['-o-transition-duration'] = Effect.duration + 'ms';
            rippleStyle['transition-duration'] = Effect.duration + 'ms';
            rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
            rippleStyle['-moz-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
            rippleStyle['-o-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
            rippleStyle['transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
            ripple.setAttribute('style', convertStyle(rippleStyle));
        },
        hide: function(e) {
            TouchHandler.touchup(e);
            var el = this;
            var width = el.clientWidth * 1.4;
            // Get first ripple
            var ripple = null;
            var ripples = el.getElementsByClassName('waves-ripple');
            if (ripples.length > 0) ripple = ripples[ripples.length - 1];
            else return false;
            var relativeX = ripple.getAttribute('data-x');
            var relativeY = ripple.getAttribute('data-y');
            var scale = ripple.getAttribute('data-scale');
            // Get delay beetween mousedown and mouse leave
            var diff = Date.now() - Number(ripple.getAttribute('data-hold'));
            var delay = 350 - diff;
            if (delay < 0) delay = 0;
            // Fade out ripple after delay
            setTimeout(function() {
                var style = {
                    'top': relativeY + 'px',
                    'left': relativeX + 'px',
                    'opacity': '0',
                    // Duration
                    '-webkit-transition-duration': Effect.duration + 'ms',
                    '-moz-transition-duration': Effect.duration + 'ms',
                    '-o-transition-duration': Effect.duration + 'ms',
                    'transition-duration': Effect.duration + 'ms',
                    '-webkit-transform': scale,
                    '-moz-transform': scale,
                    '-ms-transform': scale,
                    '-o-transform': scale,
                    'transform': scale
                };
                ripple.setAttribute('style', convertStyle(style));
                setTimeout(function() {
                    try {
                        el.removeChild(ripple);
                    } catch (e) {
                        return false;
                    }
                }, Effect.duration);
            }, delay);
        },
        // Little hack to make <input> can perform waves effect
        wrapInput: function(elements) {
            for(var a = 0; a < elements.length; a++){
                var el = elements[a];
                if (el.tagName.toLowerCase() === 'input') {
                    var parent = el.parentNode;
                    // If input already have parent just pass through
                    if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) continue;
                    // Put element class and style to the specified parent
                    var wrapper = document.createElement('i');
                    wrapper.className = el.className + ' waves-input-wrapper';
                    var elementStyle = el.getAttribute('style');
                    if (!elementStyle) elementStyle = '';
                    wrapper.setAttribute('style', elementStyle);
                    el.className = 'waves-button-input';
                    el.removeAttribute('style');
                    // Put element as child
                    parent.replaceChild(wrapper, el);
                    wrapper.appendChild(el);
                }
            }
        }
    };
    /**
   * Disable mousedown event for 500ms during and after touch
   */ var TouchHandler = {
        /* uses an integer rather than bool so there's no issues with
     * needing to clear timeouts if another touch event occurred
     * within the 500ms. Cannot mouseup between touchstart and
     * touchend, nor in the 500ms after touchend. */ touches: 0,
        allowEvent: function(e) {
            var allow = true;
            if (e.type === 'touchstart') TouchHandler.touches += 1; //push
            else if (e.type === 'touchend' || e.type === 'touchcancel') setTimeout(function() {
                if (TouchHandler.touches > 0) TouchHandler.touches -= 1; //pop after 500ms
            }, 500);
            else if (e.type === 'mousedown' && TouchHandler.touches > 0) allow = false;
            return allow;
        },
        touchup: function(e) {
            TouchHandler.allowEvent(e);
        }
    };
    /**
   * Delegated click handler for .waves-effect element.
   * returns null when .waves-effect element not in "click tree"
   */ function getWavesEffectElement(e) {
        if (TouchHandler.allowEvent(e) === false) return null;
        var element = null;
        var target = e.target || e.srcElement;
        while(target.parentNode !== null){
            if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {
                element = target;
                break;
            }
            target = target.parentNode;
        }
        return element;
    }
    /**
   * Bubble the click and show effect if .waves-effect elem was found
   */ function showEffect(e) {
        var element = getWavesEffectElement(e);
        if (element !== null) {
            Effect.show(e, element);
            if ('ontouchstart' in window) {
                element.addEventListener('touchend', Effect.hide, false);
                element.addEventListener('touchcancel', Effect.hide, false);
            }
            element.addEventListener('mouseup', Effect.hide, false);
            element.addEventListener('mouseleave', Effect.hide, false);
            element.addEventListener('dragend', Effect.hide, false);
        }
    }
    Waves.displayEffect = function(options) {
        options = options || {
        };
        if ('duration' in options) Effect.duration = options.duration;
        //Wrap input inside <i> tag
        Effect.wrapInput($$('.waves-effect'));
        if ('ontouchstart' in window) document.body.addEventListener('touchstart', showEffect, false);
        document.body.addEventListener('mousedown', showEffect, false);
    };
    /**
   * Attach Waves to an input element (or any element which doesn't
   * bubble mouseup/mousedown events).
   *   Intended to be used with dynamically loaded forms/inputs, or
   * where the user doesn't want a delegated click handler.
   */ Waves.attach = function(element) {
        //FUTURE: automatically add waves classes and allow users
        // to specify them with an options param? Eg. light/classic/button
        if (element.tagName.toLowerCase() === 'input') {
            Effect.wrapInput([
                element
            ]);
            element = element.parentNode;
        }
        if ('ontouchstart' in window) element.addEventListener('touchstart', showEffect, false);
        element.addEventListener('mousedown', showEffect, false);
    };
    window.Waves = Waves;
    document.addEventListener('DOMContentLoaded', function() {
        Waves.displayEffect();
    }, false);
})(window);
(function($, anim) {
    var _defaults = {
        html: '',
        displayLength: 4000,
        inDuration: 300,
        outDuration: 375,
        classes: '',
        completeCallback: null,
        activationPercent: 0.8
    };
    var Toast1 = function() {
        function Toast(options) {
            _classCallCheck(this, Toast);
            /**
       * Options for the toast
       * @member Toast#options
       */ this.options = $.extend({
            }, Toast.defaults, options);
            this.message = this.options.html;
            /**
       * Describes current pan state toast
       * @type {Boolean}
       */ this.panning = false;
            /**
       * Time remaining until toast is removed
       */ this.timeRemaining = this.options.displayLength;
            if (Toast._toasts.length === 0) Toast._createContainer();
            // Create new toast
            Toast._toasts.push(this);
            var toastElement = this._createToast();
            toastElement.M_Toast = this;
            this.el = toastElement;
            this.$el = $(toastElement);
            this._animateIn();
            this._setTimer();
        }
        _createClass(Toast, [
            {
                key: "_createToast",
                /**
       * Create toast and append it to toast container
       */ value: function _createToast() {
                    var toast = document.createElement('div');
                    toast.classList.add('toast');
                    // Add custom classes onto toast
                    if (!!this.options.classes.length) $(toast).addClass(this.options.classes);
                    // Set content
                    if (typeof HTMLElement === 'object' ? this.message instanceof HTMLElement : this.message && typeof this.message === 'object' && this.message !== null && this.message.nodeType === 1 && typeof this.message.nodeName === 'string') toast.appendChild(this.message);
                    else if (!!this.message.jquery) $(toast).append(this.message[0]);
                    else toast.innerHTML = this.message;
                    // Append toasft
                    Toast._container.appendChild(toast);
                    return toast;
                }
            },
            {
                key: "_animateIn",
                value: function _animateIn() {
                    // Animate toast in
                    anim({
                        targets: this.el,
                        top: 0,
                        opacity: 1,
                        duration: this.options.inDuration,
                        easing: 'easeOutCubic'
                    });
                }
            },
            {
                key: "_setTimer",
                value: function _setTimer() {
                    var _this29 = this;
                    if (this.timeRemaining !== Infinity) this.counterInterval = setInterval(function() {
                        // If toast is not being dragged, decrease its time remaining
                        if (!_this29.panning) _this29.timeRemaining -= 20;
                        // Animate toast out
                        if (_this29.timeRemaining <= 0) _this29.dismiss();
                    }, 20);
                }
            },
            {
                key: "dismiss",
                value: function dismiss() {
                    var _this30 = this;
                    window.clearInterval(this.counterInterval);
                    var activationDistance = this.el.offsetWidth * this.options.activationPercent;
                    if (this.wasSwiped) {
                        this.el.style.transition = 'transform .05s, opacity .05s';
                        this.el.style.transform = "translateX(" + activationDistance + "px)";
                        this.el.style.opacity = 0;
                    }
                    anim({
                        targets: this.el,
                        opacity: 0,
                        marginTop: -40,
                        duration: this.options.outDuration,
                        easing: 'easeOutExpo',
                        complete: function() {
                            // Call the optional callback
                            if (typeof _this30.options.completeCallback === 'function') _this30.options.completeCallback();
                            // Remove toast from DOM
                            _this30.$el.remove();
                            Toast._toasts.splice(Toast._toasts.indexOf(_this30), 1);
                            if (Toast._toasts.length === 0) Toast._removeContainer();
                        }
                    });
                }
            }
        ], [
            {
                key: "getInstance",
                /**
       * Get Instance
       */ value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Toast;
                }
            },
            {
                key: "_createContainer",
                value: function _createContainer() {
                    var container = document.createElement('div');
                    container.setAttribute('id', 'toast-container');
                    // Add event handler
                    container.addEventListener('touchstart', Toast._onDragStart);
                    container.addEventListener('touchmove', Toast._onDragMove);
                    container.addEventListener('touchend', Toast._onDragEnd);
                    container.addEventListener('mousedown', Toast._onDragStart);
                    document.addEventListener('mousemove', Toast._onDragMove);
                    document.addEventListener('mouseup', Toast._onDragEnd);
                    document.body.appendChild(container);
                    Toast._container = container;
                }
            },
            {
                key: "_removeContainer",
                value: function _removeContainer() {
                    // Add event handler
                    document.removeEventListener('mousemove', Toast._onDragMove);
                    document.removeEventListener('mouseup', Toast._onDragEnd);
                    $(Toast._container).remove();
                    Toast._container = null;
                }
            },
            {
                key: "_onDragStart",
                value: function _onDragStart(e) {
                    if (e.target && $(e.target).closest('.toast').length) {
                        var $toast = $(e.target).closest('.toast');
                        var toast = $toast[0].M_Toast;
                        toast.panning = true;
                        Toast._draggedToast = toast;
                        toast.el.classList.add('panning');
                        toast.el.style.transition = '';
                        toast.startingXPos = Toast._xPos(e);
                        toast.time = Date.now();
                        toast.xPos = Toast._xPos(e);
                    }
                }
            },
            {
                key: "_onDragMove",
                value: function _onDragMove(e) {
                    if (!!Toast._draggedToast) {
                        e.preventDefault();
                        var toast = Toast._draggedToast;
                        toast.deltaX = Math.abs(toast.xPos - Toast._xPos(e));
                        toast.xPos = Toast._xPos(e);
                        toast.velocityX = toast.deltaX / (Date.now() - toast.time);
                        toast.time = Date.now();
                        var totalDeltaX = toast.xPos - toast.startingXPos;
                        var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;
                        toast.el.style.transform = "translateX(" + totalDeltaX + "px)";
                        toast.el.style.opacity = 1 - Math.abs(totalDeltaX / activationDistance);
                    }
                }
            },
            {
                key: "_onDragEnd",
                value: function _onDragEnd() {
                    if (!!Toast._draggedToast) {
                        var toast = Toast._draggedToast;
                        toast.panning = false;
                        toast.el.classList.remove('panning');
                        var totalDeltaX = toast.xPos - toast.startingXPos;
                        var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;
                        var shouldBeDismissed = Math.abs(totalDeltaX) > activationDistance || toast.velocityX > 1;
                        // Remove toast
                        if (shouldBeDismissed) {
                            toast.wasSwiped = true;
                            toast.dismiss();
                        // Animate toast back to original position
                        } else {
                            toast.el.style.transition = 'transform .2s, opacity .2s';
                            toast.el.style.transform = '';
                            toast.el.style.opacity = '';
                        }
                        Toast._draggedToast = null;
                    }
                }
            },
            {
                key: "_xPos",
                value: function _xPos(e) {
                    if (e.targetTouches && e.targetTouches.length >= 1) return e.targetTouches[0].clientX;
                    // mouse event
                    return e.clientX;
                }
            },
            {
                key: "dismissAll",
                value: function dismissAll() {
                    for(var toastIndex in Toast._toasts)Toast._toasts[toastIndex].dismiss();
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Toast;
    }();
    /**
   * @static
   * @memberof Toast
   * @type {Array.<Toast>}
   */ Toast1._toasts = [];
    /**
   * @static
   * @memberof Toast
   */ Toast1._container = null;
    /**
   * @static
   * @memberof Toast
   * @type {Toast}
   */ Toast1._draggedToast = null;
    M.Toast = Toast1;
    M.toast = function(options) {
        return new Toast1(options);
    };
})(cash, M.anime);
(function($, anim) {
    var _defaults = {
        edge: 'left',
        draggable: true,
        inDuration: 250,
        outDuration: 200,
        onOpenStart: null,
        onOpenEnd: null,
        onCloseStart: null,
        onCloseEnd: null,
        preventScrolling: true
    };
    /**
   * @class
   */ var Sidenav1 = function(_Component8) {
        _inherits(Sidenav, _Component8);
        /**
     * Construct Sidenav instance and set up overlay
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Sidenav(el, options) {
            _classCallCheck(this, Sidenav);
            var _this31 = _possibleConstructorReturn(this, (Sidenav.__proto__ || Object.getPrototypeOf(Sidenav)).call(this, Sidenav, el, options));
            _this31.el.M_Sidenav = _this31;
            _this31.id = _this31.$el.attr('id');
            /**
       * Options for the Sidenav
       * @member Sidenav#options
       * @prop {String} [edge='left'] - Side of screen on which Sidenav appears
       * @prop {Boolean} [draggable=true] - Allow swipe gestures to open/close Sidenav
       * @prop {Number} [inDuration=250] - Length in ms of enter transition
       * @prop {Number} [outDuration=200] - Length in ms of exit transition
       * @prop {Function} onOpenStart - Function called when sidenav starts entering
       * @prop {Function} onOpenEnd - Function called when sidenav finishes entering
       * @prop {Function} onCloseStart - Function called when sidenav starts exiting
       * @prop {Function} onCloseEnd - Function called when sidenav finishes exiting
       */ _this31.options = $.extend({
            }, Sidenav.defaults, options);
            /**
       * Describes open/close state of Sidenav
       * @type {Boolean}
       */ _this31.isOpen = false;
            /**
       * Describes if Sidenav is fixed
       * @type {Boolean}
       */ _this31.isFixed = _this31.el.classList.contains('sidenav-fixed');
            /**
       * Describes if Sidenav is being draggeed
       * @type {Boolean}
       */ _this31.isDragged = false;
            // Window size variables for window resize checks
            _this31.lastWindowWidth = window.innerWidth;
            _this31.lastWindowHeight = window.innerHeight;
            _this31._createOverlay();
            _this31._createDragTarget();
            _this31._setupEventHandlers();
            _this31._setupClasses();
            _this31._setupFixed();
            Sidenav._sidenavs.push(_this31);
            return _this31;
        }
        _createClass(Sidenav, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this._enableBodyScrolling();
                    this._overlay.parentNode.removeChild(this._overlay);
                    this.dragTarget.parentNode.removeChild(this.dragTarget);
                    this.el.M_Sidenav = undefined;
                    this.el.style.transform = '';
                    var index = Sidenav._sidenavs.indexOf(this);
                    if (index >= 0) Sidenav._sidenavs.splice(index, 1);
                }
            },
            {
                key: "_createOverlay",
                value: function _createOverlay() {
                    var overlay = document.createElement('div');
                    this._closeBound = this.close.bind(this);
                    overlay.classList.add('sidenav-overlay');
                    overlay.addEventListener('click', this._closeBound);
                    document.body.appendChild(overlay);
                    this._overlay = overlay;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    if (Sidenav._sidenavs.length === 0) document.body.addEventListener('click', this._handleTriggerClick);
                    this._handleDragTargetDragBound = this._handleDragTargetDrag.bind(this);
                    this._handleDragTargetReleaseBound = this._handleDragTargetRelease.bind(this);
                    this._handleCloseDragBound = this._handleCloseDrag.bind(this);
                    this._handleCloseReleaseBound = this._handleCloseRelease.bind(this);
                    this._handleCloseTriggerClickBound = this._handleCloseTriggerClick.bind(this);
                    this.dragTarget.addEventListener('touchmove', this._handleDragTargetDragBound);
                    this.dragTarget.addEventListener('touchend', this._handleDragTargetReleaseBound);
                    this._overlay.addEventListener('touchmove', this._handleCloseDragBound);
                    this._overlay.addEventListener('touchend', this._handleCloseReleaseBound);
                    this.el.addEventListener('touchmove', this._handleCloseDragBound);
                    this.el.addEventListener('touchend', this._handleCloseReleaseBound);
                    this.el.addEventListener('click', this._handleCloseTriggerClickBound);
                    // Add resize for side nav fixed
                    if (this.isFixed) {
                        this._handleWindowResizeBound = this._handleWindowResize.bind(this);
                        window.addEventListener('resize', this._handleWindowResizeBound);
                    }
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    if (Sidenav._sidenavs.length === 1) document.body.removeEventListener('click', this._handleTriggerClick);
                    this.dragTarget.removeEventListener('touchmove', this._handleDragTargetDragBound);
                    this.dragTarget.removeEventListener('touchend', this._handleDragTargetReleaseBound);
                    this._overlay.removeEventListener('touchmove', this._handleCloseDragBound);
                    this._overlay.removeEventListener('touchend', this._handleCloseReleaseBound);
                    this.el.removeEventListener('touchmove', this._handleCloseDragBound);
                    this.el.removeEventListener('touchend', this._handleCloseReleaseBound);
                    this.el.removeEventListener('click', this._handleCloseTriggerClickBound);
                    // Remove resize for side nav fixed
                    if (this.isFixed) window.removeEventListener('resize', this._handleWindowResizeBound);
                }
            },
            {
                key: "_handleTriggerClick",
                value: function _handleTriggerClick(e) {
                    var $trigger = $(e.target).closest('.sidenav-trigger');
                    if (e.target && $trigger.length) {
                        var sidenavId = M.getIdFromTrigger($trigger[0]);
                        var sidenavInstance = document.getElementById(sidenavId).M_Sidenav;
                        if (sidenavInstance) sidenavInstance.open($trigger);
                        e.preventDefault();
                    }
                }
            },
            {
                key: "_startDrag",
                value: function _startDrag(e) {
                    var clientX = e.targetTouches[0].clientX;
                    this.isDragged = true;
                    this._startingXpos = clientX;
                    this._xPos = this._startingXpos;
                    this._time = Date.now();
                    this._width = this.el.getBoundingClientRect().width;
                    this._overlay.style.display = 'block';
                    this._initialScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();
                    this._verticallyScrolling = false;
                    anim.remove(this.el);
                    anim.remove(this._overlay);
                }
            },
            {
                key: "_dragMoveUpdate",
                value: function _dragMoveUpdate(e) {
                    var clientX = e.targetTouches[0].clientX;
                    var currentScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();
                    this.deltaX = Math.abs(this._xPos - clientX);
                    this._xPos = clientX;
                    this.velocityX = this.deltaX / (Date.now() - this._time);
                    this._time = Date.now();
                    if (this._initialScrollTop !== currentScrollTop) this._verticallyScrolling = true;
                }
            },
            {
                key: "_handleDragTargetDrag",
                value: function _handleDragTargetDrag(e) {
                    // Check if draggable
                    if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) return;
                    // If not being dragged, set initial drag start variables
                    if (!this.isDragged) this._startDrag(e);
                    // Run touchmove updates
                    this._dragMoveUpdate(e);
                    // Calculate raw deltaX
                    var totalDeltaX = this._xPos - this._startingXpos;
                    // dragDirection is the attempted user drag direction
                    var dragDirection = totalDeltaX > 0 ? 'right' : 'left';
                    // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction
                    totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));
                    if (this.options.edge === dragDirection) totalDeltaX = 0;
                    /**
         * transformX is the drag displacement
         * transformPrefix is the initial transform placement
         * Invert values if Sidenav is right edge
         */ var transformX = totalDeltaX;
                    var transformPrefix = 'translateX(-100%)';
                    if (this.options.edge === 'right') {
                        transformPrefix = 'translateX(100%)';
                        transformX = -transformX;
                    }
                    // Calculate open/close percentage of sidenav, with open = 1 and close = 0
                    this.percentOpen = Math.min(1, totalDeltaX / this._width);
                    // Set transform and opacity styles
                    this.el.style.transform = transformPrefix + " translateX(" + transformX + "px)";
                    this._overlay.style.opacity = this.percentOpen;
                }
            },
            {
                key: "_handleDragTargetRelease",
                value: function _handleDragTargetRelease() {
                    if (this.isDragged) {
                        if (this.percentOpen > 0.2) this.open();
                        else this._animateOut();
                        this.isDragged = false;
                        this._verticallyScrolling = false;
                    }
                }
            },
            {
                key: "_handleCloseDrag",
                value: function _handleCloseDrag(e) {
                    if (this.isOpen) {
                        // Check if draggable
                        if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) return;
                        // If not being dragged, set initial drag start variables
                        if (!this.isDragged) this._startDrag(e);
                        // Run touchmove updates
                        this._dragMoveUpdate(e);
                        // Calculate raw deltaX
                        var totalDeltaX = this._xPos - this._startingXpos;
                        // dragDirection is the attempted user drag direction
                        var dragDirection = totalDeltaX > 0 ? 'right' : 'left';
                        // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction
                        totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));
                        if (this.options.edge !== dragDirection) totalDeltaX = 0;
                        var transformX = -totalDeltaX;
                        if (this.options.edge === 'right') transformX = -transformX;
                        // Calculate open/close percentage of sidenav, with open = 1 and close = 0
                        this.percentOpen = Math.min(1, 1 - totalDeltaX / this._width);
                        // Set transform and opacity styles
                        this.el.style.transform = "translateX(" + transformX + "px)";
                        this._overlay.style.opacity = this.percentOpen;
                    }
                }
            },
            {
                key: "_handleCloseRelease",
                value: function _handleCloseRelease() {
                    if (this.isOpen && this.isDragged) {
                        if (this.percentOpen > 0.8) this._animateIn();
                        else this.close();
                        this.isDragged = false;
                        this._verticallyScrolling = false;
                    }
                }
            },
            {
                key: "_handleCloseTriggerClick",
                value: function _handleCloseTriggerClick(e) {
                    var $closeTrigger = $(e.target).closest('.sidenav-close');
                    if ($closeTrigger.length && !this._isCurrentlyFixed()) this.close();
                }
            },
            {
                key: "_handleWindowResize",
                value: function _handleWindowResize() {
                    // Only handle horizontal resizes
                    if (this.lastWindowWidth !== window.innerWidth) {
                        if (window.innerWidth > 992) this.open();
                        else this.close();
                    }
                    this.lastWindowWidth = window.innerWidth;
                    this.lastWindowHeight = window.innerHeight;
                }
            },
            {
                key: "_setupClasses",
                value: function _setupClasses() {
                    if (this.options.edge === 'right') {
                        this.el.classList.add('right-aligned');
                        this.dragTarget.classList.add('right-aligned');
                    }
                }
            },
            {
                key: "_removeClasses",
                value: function _removeClasses() {
                    this.el.classList.remove('right-aligned');
                    this.dragTarget.classList.remove('right-aligned');
                }
            },
            {
                key: "_setupFixed",
                value: function _setupFixed() {
                    if (this._isCurrentlyFixed()) this.open();
                }
            },
            {
                key: "_isCurrentlyFixed",
                value: function _isCurrentlyFixed() {
                    return this.isFixed && window.innerWidth > 992;
                }
            },
            {
                key: "_createDragTarget",
                value: function _createDragTarget() {
                    var dragTarget = document.createElement('div');
                    dragTarget.classList.add('drag-target');
                    document.body.appendChild(dragTarget);
                    this.dragTarget = dragTarget;
                }
            },
            {
                key: "_preventBodyScrolling",
                value: function _preventBodyScrolling() {
                    var body = document.body;
                    body.style.overflow = 'hidden';
                }
            },
            {
                key: "_enableBodyScrolling",
                value: function _enableBodyScrolling() {
                    var body = document.body;
                    body.style.overflow = '';
                }
            },
            {
                key: "open",
                value: function open() {
                    if (this.isOpen === true) return;
                    this.isOpen = true;
                    // Run onOpenStart callback
                    if (typeof this.options.onOpenStart === 'function') this.options.onOpenStart.call(this, this.el);
                    // Handle fixed Sidenav
                    if (this._isCurrentlyFixed()) {
                        anim.remove(this.el);
                        anim({
                            targets: this.el,
                            translateX: 0,
                            duration: 0,
                            easing: 'easeOutQuad'
                        });
                        this._enableBodyScrolling();
                        this._overlay.style.display = 'none';
                    // Handle non-fixed Sidenav
                    } else {
                        if (this.options.preventScrolling) this._preventBodyScrolling();
                        if (!this.isDragged || this.percentOpen != 1) this._animateIn();
                    }
                }
            },
            {
                key: "close",
                value: function close() {
                    if (this.isOpen === false) return;
                    this.isOpen = false;
                    // Run onCloseStart callback
                    if (typeof this.options.onCloseStart === 'function') this.options.onCloseStart.call(this, this.el);
                    // Handle fixed Sidenav
                    if (this._isCurrentlyFixed()) {
                        var transformX = this.options.edge === 'left' ? '-105%' : '105%';
                        this.el.style.transform = "translateX(" + transformX + ")";
                    // Handle non-fixed Sidenav
                    } else {
                        this._enableBodyScrolling();
                        if (!this.isDragged || this.percentOpen != 0) this._animateOut();
                        else this._overlay.style.display = 'none';
                    }
                }
            },
            {
                key: "_animateIn",
                value: function _animateIn() {
                    this._animateSidenavIn();
                    this._animateOverlayIn();
                }
            },
            {
                key: "_animateSidenavIn",
                value: function _animateSidenavIn() {
                    var _this32 = this;
                    var slideOutPercent = this.options.edge === 'left' ? -1 : 1;
                    if (this.isDragged) slideOutPercent = this.options.edge === 'left' ? slideOutPercent + this.percentOpen : slideOutPercent - this.percentOpen;
                    anim.remove(this.el);
                    anim({
                        targets: this.el,
                        translateX: [
                            slideOutPercent * 100 + "%",
                            0
                        ],
                        duration: this.options.inDuration,
                        easing: 'easeOutQuad',
                        complete: function() {
                            // Run onOpenEnd callback
                            if (typeof _this32.options.onOpenEnd === 'function') _this32.options.onOpenEnd.call(_this32, _this32.el);
                        }
                    });
                }
            },
            {
                key: "_animateOverlayIn",
                value: function _animateOverlayIn() {
                    var start = 0;
                    if (this.isDragged) start = this.percentOpen;
                    else $(this._overlay).css({
                        display: 'block'
                    });
                    anim.remove(this._overlay);
                    anim({
                        targets: this._overlay,
                        opacity: [
                            start,
                            1
                        ],
                        duration: this.options.inDuration,
                        easing: 'easeOutQuad'
                    });
                }
            },
            {
                key: "_animateOut",
                value: function _animateOut() {
                    this._animateSidenavOut();
                    this._animateOverlayOut();
                }
            },
            {
                key: "_animateSidenavOut",
                value: function _animateSidenavOut() {
                    var _this33 = this;
                    var endPercent = this.options.edge === 'left' ? -1 : 1;
                    var slideOutPercent = 0;
                    if (this.isDragged) slideOutPercent = this.options.edge === 'left' ? endPercent + this.percentOpen : endPercent - this.percentOpen;
                    anim.remove(this.el);
                    anim({
                        targets: this.el,
                        translateX: [
                            slideOutPercent * 100 + "%",
                            endPercent * 105 + "%"
                        ],
                        duration: this.options.outDuration,
                        easing: 'easeOutQuad',
                        complete: function() {
                            // Run onOpenEnd callback
                            if (typeof _this33.options.onCloseEnd === 'function') _this33.options.onCloseEnd.call(_this33, _this33.el);
                        }
                    });
                }
            },
            {
                key: "_animateOverlayOut",
                value: function _animateOverlayOut() {
                    var _this34 = this;
                    anim.remove(this._overlay);
                    anim({
                        targets: this._overlay,
                        opacity: 0,
                        duration: this.options.outDuration,
                        easing: 'easeOutQuad',
                        complete: function() {
                            $(_this34._overlay).css('display', 'none');
                        }
                    });
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Sidenav.__proto__ || Object.getPrototypeOf(Sidenav), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Sidenav;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Sidenav;
    }(Component);
    /**
   * @static
   * @memberof Sidenav
   * @type {Array.<Sidenav>}
   */ Sidenav1._sidenavs = [];
    M.Sidenav = Sidenav1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Sidenav1, 'sidenav', 'M_Sidenav');
})(cash, M.anime);
(function($, anim) {
    var _defaults = {
        throttle: 100,
        scrollOffset: 200,
        activeClass: 'active',
        getActiveElement: function(id) {
            return 'a[href="#' + id + '"]';
        }
    };
    /**
   * @class
   *
   */ var ScrollSpy1 = function(_Component9) {
        _inherits(ScrollSpy, _Component9);
        /**
     * Construct ScrollSpy instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function ScrollSpy(el, options) {
            _classCallCheck(this, ScrollSpy);
            var _this35 = _possibleConstructorReturn(this, (ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy)).call(this, ScrollSpy, el, options));
            _this35.el.M_ScrollSpy = _this35;
            /**
       * Options for the modal
       * @member Modal#options
       * @prop {Number} [throttle=100] - Throttle of scroll handler
       * @prop {Number} [scrollOffset=200] - Offset for centering element when scrolled to
       * @prop {String} [activeClass='active'] - Class applied to active elements
       * @prop {Function} [getActiveElement] - Used to find active element
       */ _this35.options = $.extend({
            }, ScrollSpy.defaults, options);
            // setup
            ScrollSpy._elements.push(_this35);
            ScrollSpy._count++;
            ScrollSpy._increment++;
            _this35.tickId = -1;
            _this35.id = ScrollSpy._increment;
            _this35._setupEventHandlers();
            _this35._handleWindowScroll();
            return _this35;
        }
        _createClass(ScrollSpy, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    ScrollSpy._elements.splice(ScrollSpy._elements.indexOf(this), 1);
                    ScrollSpy._elementsInView.splice(ScrollSpy._elementsInView.indexOf(this), 1);
                    ScrollSpy._visibleElements.splice(ScrollSpy._visibleElements.indexOf(this.$el), 1);
                    ScrollSpy._count--;
                    this._removeEventHandlers();
                    $(this.options.getActiveElement(this.$el.attr('id'))).removeClass(this.options.activeClass);
                    this.el.M_ScrollSpy = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    var throttledResize = M.throttle(this._handleWindowScroll, 200);
                    this._handleThrottledResizeBound = throttledResize.bind(this);
                    this._handleWindowScrollBound = this._handleWindowScroll.bind(this);
                    if (ScrollSpy._count === 1) {
                        window.addEventListener('scroll', this._handleWindowScrollBound);
                        window.addEventListener('resize', this._handleThrottledResizeBound);
                        document.body.addEventListener('click', this._handleTriggerClick);
                    }
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    if (ScrollSpy._count === 0) {
                        window.removeEventListener('scroll', this._handleWindowScrollBound);
                        window.removeEventListener('resize', this._handleThrottledResizeBound);
                        document.body.removeEventListener('click', this._handleTriggerClick);
                    }
                }
            },
            {
                key: "_handleTriggerClick",
                value: function _handleTriggerClick(e) {
                    var $trigger = $(e.target);
                    for(var i = ScrollSpy._elements.length - 1; i >= 0; i--){
                        var scrollspy = ScrollSpy._elements[i];
                        if ($trigger.is('a[href="#' + scrollspy.$el.attr('id') + '"]')) {
                            e.preventDefault();
                            var offset = scrollspy.$el.offset().top + 1;
                            anim({
                                targets: [
                                    document.documentElement,
                                    document.body
                                ],
                                scrollTop: offset - scrollspy.options.scrollOffset,
                                duration: 400,
                                easing: 'easeOutCubic'
                            });
                            break;
                        }
                    }
                }
            },
            {
                key: "_handleWindowScroll",
                value: function _handleWindowScroll() {
                    // unique tick id
                    ScrollSpy._ticks++;
                    // viewport rectangle
                    var top = M.getDocumentScrollTop(), left = M.getDocumentScrollLeft(), right = left + window.innerWidth, bottom = top + window.innerHeight;
                    // determine which elements are in view
                    var intersections = ScrollSpy._findElements(top, right, bottom, left);
                    for(var i = 0; i < intersections.length; i++){
                        var scrollspy = intersections[i];
                        var lastTick = scrollspy.tickId;
                        if (lastTick < 0) // entered into view
                        scrollspy._enter();
                        // update tick id
                        scrollspy.tickId = ScrollSpy._ticks;
                    }
                    for(var _i = 0; _i < ScrollSpy._elementsInView.length; _i++){
                        var _scrollspy = ScrollSpy._elementsInView[_i];
                        var _lastTick = _scrollspy.tickId;
                        if (_lastTick >= 0 && _lastTick !== ScrollSpy._ticks) {
                            // exited from view
                            _scrollspy._exit();
                            _scrollspy.tickId = -1;
                        }
                    }
                    // remember elements in view for next tick
                    ScrollSpy._elementsInView = intersections;
                }
            },
            {
                key: "_enter",
                value: function _enter() {
                    ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function(value) {
                        return value.height() != 0;
                    });
                    if (ScrollSpy._visibleElements[0]) {
                        $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);
                        if (ScrollSpy._visibleElements[0][0].M_ScrollSpy && this.id < ScrollSpy._visibleElements[0][0].M_ScrollSpy.id) ScrollSpy._visibleElements.unshift(this.$el);
                        else ScrollSpy._visibleElements.push(this.$el);
                    } else ScrollSpy._visibleElements.push(this.$el);
                    $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);
                }
            },
            {
                key: "_exit",
                value: function _exit() {
                    var _this36 = this;
                    ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function(value) {
                        return value.height() != 0;
                    });
                    if (ScrollSpy._visibleElements[0]) {
                        $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);
                        ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function(el) {
                            return el.attr('id') != _this36.$el.attr('id');
                        });
                        if (ScrollSpy._visibleElements[0]) // Check if empty
                        $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);
                    }
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_ScrollSpy;
                }
            },
            {
                key: "_findElements",
                value: function _findElements(top, right, bottom, left) {
                    var hits = [];
                    for(var i = 0; i < ScrollSpy._elements.length; i++){
                        var scrollspy = ScrollSpy._elements[i];
                        var currTop = top + scrollspy.options.scrollOffset || 200;
                        if (scrollspy.$el.height() > 0) {
                            var elTop = scrollspy.$el.offset().top, elLeft = scrollspy.$el.offset().left, elRight = elLeft + scrollspy.$el.width(), elBottom = elTop + scrollspy.$el.height();
                            var isIntersect = !(elLeft > right || elRight < left || elTop > bottom || elBottom < currTop);
                            if (isIntersect) hits.push(scrollspy);
                        }
                    }
                    return hits;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return ScrollSpy;
    }(Component);
    /**
   * @static
   * @memberof ScrollSpy
   * @type {Array.<ScrollSpy>}
   */ ScrollSpy1._elements = [];
    /**
   * @static
   * @memberof ScrollSpy
   * @type {Array.<ScrollSpy>}
   */ ScrollSpy1._elementsInView = [];
    /**
   * @static
   * @memberof ScrollSpy
   * @type {Array.<cash>}
   */ ScrollSpy1._visibleElements = [];
    /**
   * @static
   * @memberof ScrollSpy
   */ ScrollSpy1._count = 0;
    /**
   * @static
   * @memberof ScrollSpy
   */ ScrollSpy1._increment = 0;
    /**
   * @static
   * @memberof ScrollSpy
   */ ScrollSpy1._ticks = 0;
    M.ScrollSpy = ScrollSpy1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(ScrollSpy1, 'scrollSpy', 'M_ScrollSpy');
})(cash, M.anime);
(function($) {
    var _defaults = {
        data: {
        },
        limit: Infinity,
        onAutocomplete: null,
        minLength: 1,
        sortFunction: function(a, b, inputString) {
            // Sort function for sorting autocomplete results
            return a.indexOf(inputString) - b.indexOf(inputString);
        }
    };
    /**
   * @class
   *
   */ var Autocomplete1 = function(_Component10) {
        _inherits(Autocomplete, _Component10);
        /**
     * Construct Autocomplete instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Autocomplete(el, options) {
            _classCallCheck(this, Autocomplete);
            var _this37 = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, Autocomplete, el, options));
            _this37.el.M_Autocomplete = _this37;
            /**
       * Options for the autocomplete
       * @member Autocomplete#options
       * @prop {Number} duration
       * @prop {Number} dist
       * @prop {number} shift
       * @prop {number} padding
       * @prop {Boolean} fullWidth
       * @prop {Boolean} indicators
       * @prop {Boolean} noWrap
       * @prop {Function} onCycleTo
       */ _this37.options = $.extend({
            }, Autocomplete.defaults, options);
            // Setup
            _this37.isOpen = false;
            _this37.count = 0;
            _this37.activeIndex = -1;
            _this37.oldVal;
            _this37.$inputField = _this37.$el.closest('.input-field');
            _this37.$active = $();
            _this37._mousedown = false;
            _this37._setupDropdown();
            _this37._setupEventHandlers();
            return _this37;
        }
        _createClass(Autocomplete, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this._removeDropdown();
                    this.el.M_Autocomplete = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleInputBlurBound = this._handleInputBlur.bind(this);
                    this._handleInputKeyupAndFocusBound = this._handleInputKeyupAndFocus.bind(this);
                    this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
                    this._handleInputClickBound = this._handleInputClick.bind(this);
                    this._handleContainerMousedownAndTouchstartBound = this._handleContainerMousedownAndTouchstart.bind(this);
                    this._handleContainerMouseupAndTouchendBound = this._handleContainerMouseupAndTouchend.bind(this);
                    this.el.addEventListener('blur', this._handleInputBlurBound);
                    this.el.addEventListener('keyup', this._handleInputKeyupAndFocusBound);
                    this.el.addEventListener('focus', this._handleInputKeyupAndFocusBound);
                    this.el.addEventListener('keydown', this._handleInputKeydownBound);
                    this.el.addEventListener('click', this._handleInputClickBound);
                    this.container.addEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);
                    this.container.addEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);
                    if (typeof window.ontouchstart !== 'undefined') {
                        this.container.addEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);
                        this.container.addEventListener('touchend', this._handleContainerMouseupAndTouchendBound);
                    }
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('blur', this._handleInputBlurBound);
                    this.el.removeEventListener('keyup', this._handleInputKeyupAndFocusBound);
                    this.el.removeEventListener('focus', this._handleInputKeyupAndFocusBound);
                    this.el.removeEventListener('keydown', this._handleInputKeydownBound);
                    this.el.removeEventListener('click', this._handleInputClickBound);
                    this.container.removeEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);
                    this.container.removeEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);
                    if (typeof window.ontouchstart !== 'undefined') {
                        this.container.removeEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);
                        this.container.removeEventListener('touchend', this._handleContainerMouseupAndTouchendBound);
                    }
                }
            },
            {
                key: "_setupDropdown",
                value: function _setupDropdown() {
                    var _this38 = this;
                    this.container = document.createElement('ul');
                    this.container.id = "autocomplete-options-" + M.guid();
                    $(this.container).addClass('autocomplete-content dropdown-content');
                    this.$inputField.append(this.container);
                    this.el.setAttribute('data-target', this.container.id);
                    this.dropdown = M.Dropdown.init(this.el, {
                        autoFocus: false,
                        closeOnClick: false,
                        coverTrigger: false,
                        onItemClick: function(itemEl) {
                            _this38.selectOption($(itemEl));
                        }
                    });
                    // Sketchy removal of dropdown click handler
                    this.el.removeEventListener('click', this.dropdown._handleClickBound);
                }
            },
            {
                key: "_removeDropdown",
                value: function _removeDropdown() {
                    this.container.parentNode.removeChild(this.container);
                }
            },
            {
                key: "_handleInputBlur",
                value: function _handleInputBlur() {
                    if (!this._mousedown) {
                        this.close();
                        this._resetAutocomplete();
                    }
                }
            },
            {
                key: "_handleInputKeyupAndFocus",
                value: function _handleInputKeyupAndFocus(e) {
                    if (e.type === 'keyup') Autocomplete._keydown = false;
                    this.count = 0;
                    var val = this.el.value.toLowerCase();
                    // Don't capture enter or arrow key usage.
                    if (e.keyCode === 13 || e.keyCode === 38 || e.keyCode === 40) return;
                    // Check if the input isn't empty
                    // Check if focus triggered by tab
                    if (this.oldVal !== val && (M.tabPressed || e.type !== 'focus')) this.open();
                    // Update oldVal
                    this.oldVal = val;
                }
            },
            {
                key: "_handleInputKeydown",
                value: function _handleInputKeydown(e) {
                    Autocomplete._keydown = true;
                    // Arrow keys and enter key usage
                    var keyCode = e.keyCode, liElement = void 0, numItems = $(this.container).children('li').length;
                    // select element on Enter
                    if (keyCode === M.keys.ENTER && this.activeIndex >= 0) {
                        liElement = $(this.container).children('li').eq(this.activeIndex);
                        if (liElement.length) {
                            this.selectOption(liElement);
                            e.preventDefault();
                        }
                        return;
                    }
                    // Capture up and down key
                    if (keyCode === M.keys.ARROW_UP || keyCode === M.keys.ARROW_DOWN) {
                        e.preventDefault();
                        if (keyCode === M.keys.ARROW_UP && this.activeIndex > 0) this.activeIndex--;
                        if (keyCode === M.keys.ARROW_DOWN && this.activeIndex < numItems - 1) this.activeIndex++;
                        this.$active.removeClass('active');
                        if (this.activeIndex >= 0) {
                            this.$active = $(this.container).children('li').eq(this.activeIndex);
                            this.$active.addClass('active');
                        }
                    }
                }
            },
            {
                key: "_handleInputClick",
                value: function _handleInputClick(e) {
                    this.open();
                }
            },
            {
                key: "_handleContainerMousedownAndTouchstart",
                value: function _handleContainerMousedownAndTouchstart(e) {
                    this._mousedown = true;
                }
            },
            {
                key: "_handleContainerMouseupAndTouchend",
                value: function _handleContainerMouseupAndTouchend(e) {
                    this._mousedown = false;
                }
            },
            {
                key: "_highlight",
                value: function _highlight(string, $el) {
                    var img = $el.find('img');
                    var matchStart = $el.text().toLowerCase().indexOf('' + string.toLowerCase() + ''), matchEnd = matchStart + string.length - 1, beforeMatch = $el.text().slice(0, matchStart), matchText = $el.text().slice(matchStart, matchEnd + 1), afterMatch = $el.text().slice(matchEnd + 1);
                    $el.html("<span>" + beforeMatch + "<span class='highlight'>" + matchText + "</span>" + afterMatch + "</span>");
                    if (img.length) $el.prepend(img);
                }
            },
            {
                key: "_resetCurrentElement",
                value: function _resetCurrentElement() {
                    this.activeIndex = -1;
                    this.$active.removeClass('active');
                }
            },
            {
                key: "_resetAutocomplete",
                value: function _resetAutocomplete() {
                    $(this.container).empty();
                    this._resetCurrentElement();
                    this.oldVal = null;
                    this.isOpen = false;
                    this._mousedown = false;
                }
            },
            {
                key: "selectOption",
                value: function selectOption(el) {
                    var text = el.text().trim();
                    this.el.value = text;
                    this.$el.trigger('change');
                    this._resetAutocomplete();
                    this.close();
                    // Handle onAutocomplete callback.
                    if (typeof this.options.onAutocomplete === 'function') this.options.onAutocomplete.call(this, text);
                }
            },
            {
                key: "_renderDropdown",
                value: function _renderDropdown(data, val) {
                    var _this39 = this;
                    this._resetAutocomplete();
                    var matchingData = [];
                    // Gather all matching data
                    for(var key in data)if (data.hasOwnProperty(key) && key.toLowerCase().indexOf(val) !== -1) {
                        // Break if past limit
                        if (this.count >= this.options.limit) break;
                        var entry = {
                            data: data[key],
                            key: key
                        };
                        matchingData.push(entry);
                        this.count++;
                    }
                    // Sort
                    if (this.options.sortFunction) {
                        var sortFunctionBound = function(a, b) {
                            return _this39.options.sortFunction(a.key.toLowerCase(), b.key.toLowerCase(), val.toLowerCase());
                        };
                        matchingData.sort(sortFunctionBound);
                    }
                    // Render
                    for(var i = 0; i < matchingData.length; i++){
                        var _entry = matchingData[i];
                        var $autocompleteOption = $('<li></li>');
                        if (!!_entry.data) $autocompleteOption.append("<img src=\"" + _entry.data + "\" class=\"right circle\"><span>" + _entry.key + "</span>");
                        else $autocompleteOption.append('<span>' + _entry.key + '</span>');
                        $(this.container).append($autocompleteOption);
                        this._highlight(val, $autocompleteOption);
                    }
                }
            },
            {
                key: "open",
                value: function open() {
                    var val = this.el.value.toLowerCase();
                    this._resetAutocomplete();
                    if (val.length >= this.options.minLength) {
                        this.isOpen = true;
                        this._renderDropdown(this.options.data, val);
                    }
                    // Open dropdown
                    if (!this.dropdown.isOpen) this.dropdown.open();
                    else // Recalculate dropdown when its already open
                    this.dropdown.recalculateDimensions();
                }
            },
            {
                key: "close",
                value: function close() {
                    this.dropdown.close();
                }
            },
            {
                key: "updateData",
                value: function updateData(data) {
                    var val = this.el.value.toLowerCase();
                    this.options.data = data;
                    if (this.isOpen) this._renderDropdown(data, val);
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Autocomplete;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Autocomplete;
    }(Component);
    /**
   * @static
   * @memberof Autocomplete
   */ Autocomplete1._keydown = false;
    M.Autocomplete = Autocomplete1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Autocomplete1, 'autocomplete', 'M_Autocomplete');
})(cash);
(function($) {
    // Function to update labels of text fields
    M.updateTextFields = function() {
        var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';
        $(input_selector).each(function(element, index) {
            var $this = $(this);
            if (element.value.length > 0 || $(element).is(':focus') || element.autofocus || $this.attr('placeholder') !== null) $this.siblings('label').addClass('active');
            else if (element.validity) $this.siblings('label').toggleClass('active', element.validity.badInput === true);
            else $this.siblings('label').removeClass('active');
        });
    };
    M.validate_field = function(object) {
        var hasLength = object.attr('data-length') !== null;
        var lenAttr = parseInt(object.attr('data-length'));
        var len = object[0].value.length;
        if (len === 0 && object[0].validity.badInput === false && !object.is(':required')) {
            if (object.hasClass('validate')) {
                object.removeClass('valid');
                object.removeClass('invalid');
            }
        } else if (object.hasClass('validate')) {
            // Check for character counter attributes
            if (object.is(':valid') && hasLength && len <= lenAttr || object.is(':valid') && !hasLength) {
                object.removeClass('invalid');
                object.addClass('valid');
            } else {
                object.removeClass('valid');
                object.addClass('invalid');
            }
        }
    };
    M.textareaAutoResize = function($textarea) {
        // Wrap if native element
        if ($textarea instanceof Element) $textarea = $($textarea);
        if (!$textarea.length) {
            console.error('No textarea element found');
            return;
        }
        // Textarea Auto Resize
        var hiddenDiv = $('.hiddendiv').first();
        if (!hiddenDiv.length) {
            hiddenDiv = $('<div class="hiddendiv common"></div>');
            $('body').append(hiddenDiv);
        }
        // Set font properties of hiddenDiv
        var fontFamily = $textarea.css('font-family');
        var fontSize = $textarea.css('font-size');
        var lineHeight = $textarea.css('line-height');
        // Firefox can't handle padding shorthand.
        var paddingTop = $textarea.css('padding-top');
        var paddingRight = $textarea.css('padding-right');
        var paddingBottom = $textarea.css('padding-bottom');
        var paddingLeft = $textarea.css('padding-left');
        if (fontSize) hiddenDiv.css('font-size', fontSize);
        if (fontFamily) hiddenDiv.css('font-family', fontFamily);
        if (lineHeight) hiddenDiv.css('line-height', lineHeight);
        if (paddingTop) hiddenDiv.css('padding-top', paddingTop);
        if (paddingRight) hiddenDiv.css('padding-right', paddingRight);
        if (paddingBottom) hiddenDiv.css('padding-bottom', paddingBottom);
        if (paddingLeft) hiddenDiv.css('padding-left', paddingLeft);
        // Set original-height, if none
        if (!$textarea.data('original-height')) $textarea.data('original-height', $textarea.height());
        if ($textarea.attr('wrap') === 'off') hiddenDiv.css('overflow-wrap', 'normal').css('white-space', 'pre');
        hiddenDiv.text($textarea[0].value + '\n');
        var content = hiddenDiv.html().replace(/\n/g, '<br>');
        hiddenDiv.html(content);
        // When textarea is hidden, width goes crazy.
        // Approximate with half of window size
        if ($textarea[0].offsetWidth > 0 && $textarea[0].offsetHeight > 0) hiddenDiv.css('width', $textarea.width() + 'px');
        else hiddenDiv.css('width', window.innerWidth / 2 + 'px');
        /**
     * Resize if the new height is greater than the
     * original height of the textarea
     */ if ($textarea.data('original-height') <= hiddenDiv.innerHeight()) $textarea.css('height', hiddenDiv.innerHeight() + 'px');
        else if ($textarea[0].value.length < $textarea.data('previous-length')) /**
       * In case the new height is less than original height, it
       * means the textarea has less text than before
       * So we set the height to the original one
       */ $textarea.css('height', $textarea.data('original-height') + 'px');
        $textarea.data('previous-length', $textarea[0].value.length);
    };
    $(document).ready(function() {
        // Text based inputs
        var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';
        // Add active if form auto complete
        $(document).on('change', input_selector, function() {
            if (this.value.length !== 0 || $(this).attr('placeholder') !== null) $(this).siblings('label').addClass('active');
            M.validate_field($(this));
        });
        // Add active if input element has been pre-populated on document ready
        $(document).ready(function() {
            M.updateTextFields();
        });
        // HTML DOM FORM RESET handling
        $(document).on('reset', function(e) {
            var formReset = $(e.target);
            if (formReset.is('form')) {
                formReset.find(input_selector).removeClass('valid').removeClass('invalid');
                formReset.find(input_selector).each(function(e) {
                    if (this.value.length) $(this).siblings('label').removeClass('active');
                });
                // Reset select (after native reset)
                setTimeout(function() {
                    formReset.find('select').each(function() {
                        // check if initialized
                        if (this.M_FormSelect) $(this).trigger('change');
                    });
                }, 0);
            }
        });
        /**
     * Add active when element has focus
     * @param {Event} e
     */ document.addEventListener('focus', function(e) {
            if ($(e.target).is(input_selector)) $(e.target).siblings('label, .prefix').addClass('active');
        }, true);
        /**
     * Remove active when element is blurred
     * @param {Event} e
     */ document.addEventListener('blur', function(e) {
            var $inputElement = $(e.target);
            if ($inputElement.is(input_selector)) {
                var selector = '.prefix';
                if ($inputElement[0].value.length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === null) selector += ', label';
                $inputElement.siblings(selector).removeClass('active');
                M.validate_field($inputElement);
            }
        }, true);
        // Radio and Checkbox focus class
        var radio_checkbox = 'input[type=radio], input[type=checkbox]';
        $(document).on('keyup', radio_checkbox, function(e) {
            // TAB, check if tabbing to radio or checkbox.
            if (e.which === M.keys.TAB) {
                $(this).addClass('tabbed');
                var $this = $(this);
                $this.one('blur', function(e) {
                    $(this).removeClass('tabbed');
                });
                return;
            }
        });
        var text_area_selector = '.materialize-textarea';
        $(text_area_selector).each(function() {
            var $textarea = $(this);
            /**
       * Resize textarea on document load after storing
       * the original height and the original length
       */ $textarea.data('original-height', $textarea.height());
            $textarea.data('previous-length', this.value.length);
            M.textareaAutoResize($textarea);
        });
        $(document).on('keyup', text_area_selector, function() {
            M.textareaAutoResize($(this));
        });
        $(document).on('keydown', text_area_selector, function() {
            M.textareaAutoResize($(this));
        });
        // File Input Path
        $(document).on('change', '.file-field input[type="file"]', function() {
            var file_field = $(this).closest('.file-field');
            var path_input = file_field.find('input.file-path');
            var files = $(this)[0].files;
            var file_names = [];
            for(var i = 0; i < files.length; i++)file_names.push(files[i].name);
            path_input[0].value = file_names.join(', ');
            path_input.trigger('change');
        });
    }); // End of $(document).ready
})(cash);
(function($, anim) {
    var _defaults = {
        indicators: true,
        height: 400,
        duration: 500,
        interval: 6000
    };
    /**
   * @class
   *
   */ var Slider1 = function(_Component11) {
        _inherits(Slider, _Component11);
        /**
     * Construct Slider instance and set up overlay
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Slider(el2, options) {
            _classCallCheck(this, Slider);
            var _this40 = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, Slider, el2, options));
            _this40.el.M_Slider = _this40;
            /**
       * Options for the modal
       * @member Slider#options
       * @prop {Boolean} [indicators=true] - Show indicators
       * @prop {Number} [height=400] - height of slider
       * @prop {Number} [duration=500] - Length in ms of slide transition
       * @prop {Number} [interval=6000] - Length in ms of slide interval
       */ _this40.options = $.extend({
            }, Slider.defaults, options);
            // setup
            _this40.$slider = _this40.$el.find('.slides');
            _this40.$slides = _this40.$slider.children('li');
            _this40.activeIndex = _this40.$slides.filter(function(item) {
                return $(item).hasClass('active');
            }).first().index();
            if (_this40.activeIndex != -1) _this40.$active = _this40.$slides.eq(_this40.activeIndex);
            _this40._setSliderHeight();
            // Set initial positions of captions
            _this40.$slides.find('.caption').each(function(el) {
                _this40._animateCaptionIn(el, 0);
            });
            // Move img src into background-image
            _this40.$slides.find('img').each(function(el) {
                var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
                if ($(el).attr('src') !== placeholderBase64) {
                    $(el).css('background-image', 'url("' + $(el).attr('src') + '")');
                    $(el).attr('src', placeholderBase64);
                }
            });
            _this40._setupIndicators();
            // Show active slide
            if (_this40.$active) _this40.$active.css('display', 'block');
            else {
                _this40.$slides.first().addClass('active');
                anim({
                    targets: _this40.$slides.first()[0],
                    opacity: 1,
                    duration: _this40.options.duration,
                    easing: 'easeOutQuad'
                });
                _this40.activeIndex = 0;
                _this40.$active = _this40.$slides.eq(_this40.activeIndex);
                // Update indicators
                if (_this40.options.indicators) _this40.$indicators.eq(_this40.activeIndex).addClass('active');
            }
            // Adjust height to current slide
            _this40.$active.find('img').each(function(el) {
                anim({
                    targets: _this40.$active.find('.caption')[0],
                    opacity: 1,
                    translateX: 0,
                    translateY: 0,
                    duration: _this40.options.duration,
                    easing: 'easeOutQuad'
                });
            });
            _this40._setupEventHandlers();
            // auto scroll
            _this40.start();
            return _this40;
        }
        _createClass(Slider, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this.pause();
                    this._removeIndicators();
                    this._removeEventHandlers();
                    this.el.M_Slider = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    var _this41 = this;
                    this._handleIntervalBound = this._handleInterval.bind(this);
                    this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);
                    if (this.options.indicators) this.$indicators.each(function(el) {
                        el.addEventListener('click', _this41._handleIndicatorClickBound);
                    });
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    var _this42 = this;
                    if (this.options.indicators) this.$indicators.each(function(el) {
                        el.removeEventListener('click', _this42._handleIndicatorClickBound);
                    });
                }
            },
            {
                key: "_handleIndicatorClick",
                value: function _handleIndicatorClick(e) {
                    var currIndex = $(e.target).index();
                    this.set(currIndex);
                }
            },
            {
                key: "_handleInterval",
                value: function _handleInterval() {
                    var newActiveIndex = this.$slider.find('.active').index();
                    if (this.$slides.length === newActiveIndex + 1) newActiveIndex = 0;
                    else newActiveIndex += 1;
                    this.set(newActiveIndex);
                }
            },
            {
                key: "_animateCaptionIn",
                value: function _animateCaptionIn(caption, duration) {
                    var animOptions = {
                        targets: caption,
                        opacity: 0,
                        duration: duration,
                        easing: 'easeOutQuad'
                    };
                    if ($(caption).hasClass('center-align')) animOptions.translateY = -100;
                    else if ($(caption).hasClass('right-align')) animOptions.translateX = 100;
                    else if ($(caption).hasClass('left-align')) animOptions.translateX = -100;
                    anim(animOptions);
                }
            },
            {
                key: "_setSliderHeight",
                value: function _setSliderHeight() {
                    // If fullscreen, do nothing
                    if (!this.$el.hasClass('fullscreen')) {
                        if (this.options.indicators) // Add height if indicators are present
                        this.$el.css('height', this.options.height + 40 + 'px');
                        else this.$el.css('height', this.options.height + 'px');
                        this.$slider.css('height', this.options.height + 'px');
                    }
                }
            },
            {
                key: "_setupIndicators",
                value: function _setupIndicators() {
                    var _this43 = this;
                    if (this.options.indicators) {
                        this.$indicators = $('<ul class="indicators"></ul>');
                        this.$slides.each(function(el, index) {
                            var $indicator = $('<li class="indicator-item"></li>');
                            _this43.$indicators.append($indicator[0]);
                        });
                        this.$el.append(this.$indicators[0]);
                        this.$indicators = this.$indicators.children('li.indicator-item');
                    }
                }
            },
            {
                key: "_removeIndicators",
                value: function _removeIndicators() {
                    this.$el.find('ul.indicators').remove();
                }
            },
            {
                key: "set",
                value: function set(index) {
                    var _this44 = this;
                    // Wrap around indices.
                    if (index >= this.$slides.length) index = 0;
                    else if (index < 0) index = this.$slides.length - 1;
                    // Only do if index changes
                    if (this.activeIndex != index) {
                        this.$active = this.$slides.eq(this.activeIndex);
                        var $caption = this.$active.find('.caption');
                        this.$active.removeClass('active');
                        anim({
                            targets: this.$active[0],
                            opacity: 0,
                            duration: this.options.duration,
                            easing: 'easeOutQuad',
                            complete: function() {
                                _this44.$slides.not('.active').each(function(el) {
                                    anim({
                                        targets: el,
                                        opacity: 0,
                                        translateX: 0,
                                        translateY: 0,
                                        duration: 0,
                                        easing: 'easeOutQuad'
                                    });
                                });
                            }
                        });
                        this._animateCaptionIn($caption[0], this.options.duration);
                        // Update indicators
                        if (this.options.indicators) {
                            this.$indicators.eq(this.activeIndex).removeClass('active');
                            this.$indicators.eq(index).addClass('active');
                        }
                        anim({
                            targets: this.$slides.eq(index)[0],
                            opacity: 1,
                            duration: this.options.duration,
                            easing: 'easeOutQuad'
                        });
                        anim({
                            targets: this.$slides.eq(index).find('.caption')[0],
                            opacity: 1,
                            translateX: 0,
                            translateY: 0,
                            duration: this.options.duration,
                            delay: this.options.duration,
                            easing: 'easeOutQuad'
                        });
                        this.$slides.eq(index).addClass('active');
                        this.activeIndex = index;
                        // Reset interval
                        this.start();
                    }
                }
            },
            {
                key: "pause",
                value: function pause() {
                    clearInterval(this.interval);
                }
            },
            {
                key: "start",
                value: function start() {
                    clearInterval(this.interval);
                    this.interval = setInterval(this._handleIntervalBound, this.options.duration + this.options.interval);
                }
            },
            {
                key: "next",
                value: function next() {
                    var newIndex = this.activeIndex + 1;
                    // Wrap around indices.
                    if (newIndex >= this.$slides.length) newIndex = 0;
                    else if (newIndex < 0) newIndex = this.$slides.length - 1;
                    this.set(newIndex);
                }
            },
            {
                key: "prev",
                value: function prev() {
                    var newIndex = this.activeIndex - 1;
                    // Wrap around indices.
                    if (newIndex >= this.$slides.length) newIndex = 0;
                    else if (newIndex < 0) newIndex = this.$slides.length - 1;
                    this.set(newIndex);
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Slider.__proto__ || Object.getPrototypeOf(Slider), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Slider;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Slider;
    }(Component);
    M.Slider = Slider1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Slider1, 'slider', 'M_Slider');
})(cash, M.anime);
(function($, anim1) {
    $(document).on('click', '.card', function(e) {
        if ($(this).children('.card-reveal').length) {
            var $card = $(e.target).closest('.card');
            if ($card.data('initialOverflow') === undefined) $card.data('initialOverflow', $card.css('overflow') === undefined ? '' : $card.css('overflow'));
            var $cardReveal = $(this).find('.card-reveal');
            if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) // Make Reveal animate down and display none
            anim1({
                targets: $cardReveal[0],
                translateY: 0,
                duration: 225,
                easing: 'easeInOutQuad',
                complete: function(anim) {
                    var el = anim.animatables[0].target;
                    $(el).css({
                        display: 'none'
                    });
                    $card.css('overflow', $card.data('initialOverflow'));
                }
            });
            else if ($(e.target).is($('.card .activator')) || $(e.target).is($('.card .activator i'))) {
                $card.css('overflow', 'hidden');
                $cardReveal.css({
                    display: 'block'
                });
                anim1({
                    targets: $cardReveal[0],
                    translateY: '-100%',
                    duration: 300,
                    easing: 'easeInOutQuad'
                });
            }
        }
    });
})(cash, M.anime);
(function($) {
    var _defaults = {
        data: [],
        placeholder: '',
        secondaryPlaceholder: '',
        autocompleteOptions: {
        },
        limit: Infinity,
        onChipAdd: null,
        onChipSelect: null,
        onChipDelete: null
    };
    /**
   * @typedef {Object} chip
   * @property {String} tag  chip tag string
   * @property {String} [image]  chip avatar image string
   */ /**
   * @class
   *
   */ var Chips1 = function(_Component12) {
        _inherits(Chips, _Component12);
        /**
     * Construct Chips instance and set up overlay
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Chips(el, options) {
            _classCallCheck(this, Chips);
            var _this45 = _possibleConstructorReturn(this, (Chips.__proto__ || Object.getPrototypeOf(Chips)).call(this, Chips, el, options));
            _this45.el.M_Chips = _this45;
            /**
       * Options for the modal
       * @member Chips#options
       * @prop {Array} data
       * @prop {String} placeholder
       * @prop {String} secondaryPlaceholder
       * @prop {Object} autocompleteOptions
       */ _this45.options = $.extend({
            }, Chips.defaults, options);
            _this45.$el.addClass('chips input-field');
            _this45.chipsData = [];
            _this45.$chips = $();
            _this45._setupInput();
            _this45.hasAutocomplete = Object.keys(_this45.options.autocompleteOptions).length > 0;
            // Set input id
            if (!_this45.$input.attr('id')) _this45.$input.attr('id', M.guid());
            // Render initial chips
            if (_this45.options.data.length) {
                _this45.chipsData = _this45.options.data;
                _this45._renderChips(_this45.chipsData);
            }
            // Setup autocomplete if needed
            if (_this45.hasAutocomplete) _this45._setupAutocomplete();
            _this45._setPlaceholder();
            _this45._setupLabel();
            _this45._setupEventHandlers();
            return _this45;
        }
        _createClass(Chips, [
            {
                key: "getData",
                /**
       * Get Chips Data
       */ value: function getData() {
                    return this.chipsData;
                }
            },
            {
                key: "destroy",
                value: function destroy() {
                    this._removeEventHandlers();
                    this.$chips.remove();
                    this.el.M_Chips = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleChipClickBound = this._handleChipClick.bind(this);
                    this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
                    this._handleInputFocusBound = this._handleInputFocus.bind(this);
                    this._handleInputBlurBound = this._handleInputBlur.bind(this);
                    this.el.addEventListener('click', this._handleChipClickBound);
                    document.addEventListener('keydown', Chips._handleChipsKeydown);
                    document.addEventListener('keyup', Chips._handleChipsKeyup);
                    this.el.addEventListener('blur', Chips._handleChipsBlur, true);
                    this.$input[0].addEventListener('focus', this._handleInputFocusBound);
                    this.$input[0].addEventListener('blur', this._handleInputBlurBound);
                    this.$input[0].addEventListener('keydown', this._handleInputKeydownBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('click', this._handleChipClickBound);
                    document.removeEventListener('keydown', Chips._handleChipsKeydown);
                    document.removeEventListener('keyup', Chips._handleChipsKeyup);
                    this.el.removeEventListener('blur', Chips._handleChipsBlur, true);
                    this.$input[0].removeEventListener('focus', this._handleInputFocusBound);
                    this.$input[0].removeEventListener('blur', this._handleInputBlurBound);
                    this.$input[0].removeEventListener('keydown', this._handleInputKeydownBound);
                }
            },
            {
                key: "_handleChipClick",
                value: function _handleChipClick(e) {
                    var $chip = $(e.target).closest('.chip');
                    var clickedClose = $(e.target).is('.close');
                    if ($chip.length) {
                        var index = $chip.index();
                        if (clickedClose) {
                            // delete chip
                            this.deleteChip(index);
                            this.$input[0].focus();
                        } else // select chip
                        this.selectChip(index);
                    // Default handle click to focus on input
                    } else this.$input[0].focus();
                }
            },
            {
                key: "_handleInputFocus",
                /**
       * Handle Input Focus
       */ value: function _handleInputFocus() {
                    this.$el.addClass('focus');
                }
            },
            {
                key: "_handleInputBlur",
                value: function _handleInputBlur() {
                    this.$el.removeClass('focus');
                }
            },
            {
                key: "_handleInputKeydown",
                value: function _handleInputKeydown(e) {
                    Chips._keydown = true;
                    // enter
                    if (e.keyCode === 13) {
                        // Override enter if autocompleting.
                        if (this.hasAutocomplete && this.autocomplete && this.autocomplete.isOpen) return;
                        e.preventDefault();
                        this.addChip({
                            tag: this.$input[0].value
                        });
                        this.$input[0].value = '';
                    // delete or left
                    } else if ((e.keyCode === 8 || e.keyCode === 37) && this.$input[0].value === '' && this.chipsData.length) {
                        e.preventDefault();
                        this.selectChip(this.chipsData.length - 1);
                    }
                }
            },
            {
                key: "_renderChip",
                value: function _renderChip(chip) {
                    if (!chip.tag) return;
                    var renderedChip = document.createElement('div');
                    var closeIcon = document.createElement('i');
                    renderedChip.classList.add('chip');
                    renderedChip.textContent = chip.tag;
                    renderedChip.setAttribute('tabindex', 0);
                    $(closeIcon).addClass('material-icons close');
                    closeIcon.textContent = 'close';
                    // attach image if needed
                    if (chip.image) {
                        var img = document.createElement('img');
                        img.setAttribute('src', chip.image);
                        renderedChip.insertBefore(img, renderedChip.firstChild);
                    }
                    renderedChip.appendChild(closeIcon);
                    return renderedChip;
                }
            },
            {
                key: "_renderChips",
                value: function _renderChips() {
                    this.$chips.remove();
                    for(var i = 0; i < this.chipsData.length; i++){
                        var chipEl = this._renderChip(this.chipsData[i]);
                        this.$el.append(chipEl);
                        this.$chips.add(chipEl);
                    }
                    // move input to end
                    this.$el.append(this.$input[0]);
                }
            },
            {
                key: "_setupAutocomplete",
                value: function _setupAutocomplete() {
                    var _this46 = this;
                    this.options.autocompleteOptions.onAutocomplete = function(val) {
                        _this46.addChip({
                            tag: val
                        });
                        _this46.$input[0].value = '';
                        _this46.$input[0].focus();
                    };
                    this.autocomplete = M.Autocomplete.init(this.$input[0], this.options.autocompleteOptions);
                }
            },
            {
                key: "_setupInput",
                value: function _setupInput() {
                    this.$input = this.$el.find('input');
                    if (!this.$input.length) {
                        this.$input = $('<input></input>');
                        this.$el.append(this.$input);
                    }
                    this.$input.addClass('input');
                }
            },
            {
                key: "_setupLabel",
                value: function _setupLabel() {
                    this.$label = this.$el.find('label');
                    if (this.$label.length) this.$label.setAttribute('for', this.$input.attr('id'));
                }
            },
            {
                key: "_setPlaceholder",
                value: function _setPlaceholder() {
                    if (this.chipsData !== undefined && !this.chipsData.length && this.options.placeholder) $(this.$input).prop('placeholder', this.options.placeholder);
                    else if ((this.chipsData === undefined || !!this.chipsData.length) && this.options.secondaryPlaceholder) $(this.$input).prop('placeholder', this.options.secondaryPlaceholder);
                }
            },
            {
                key: "_isValid",
                value: function _isValid(chip) {
                    if (chip.hasOwnProperty('tag') && chip.tag !== '') {
                        var exists = false;
                        for(var i = 0; i < this.chipsData.length; i++)if (this.chipsData[i].tag === chip.tag) {
                            exists = true;
                            break;
                        }
                        return !exists;
                    }
                    return false;
                }
            },
            {
                key: "addChip",
                value: function addChip(chip) {
                    if (!this._isValid(chip) || this.chipsData.length >= this.options.limit) return;
                    var renderedChip = this._renderChip(chip);
                    this.$chips.add(renderedChip);
                    this.chipsData.push(chip);
                    $(this.$input).before(renderedChip);
                    this._setPlaceholder();
                    // fire chipAdd callback
                    if (typeof this.options.onChipAdd === 'function') this.options.onChipAdd.call(this, this.$el, renderedChip);
                }
            },
            {
                key: "deleteChip",
                value: function deleteChip(chipIndex) {
                    var $chip = this.$chips.eq(chipIndex);
                    this.$chips.eq(chipIndex).remove();
                    this.$chips = this.$chips.filter(function(el) {
                        return $(el).index() >= 0;
                    });
                    this.chipsData.splice(chipIndex, 1);
                    this._setPlaceholder();
                    // fire chipDelete callback
                    if (typeof this.options.onChipDelete === 'function') this.options.onChipDelete.call(this, this.$el, $chip[0]);
                }
            },
            {
                key: "selectChip",
                value: function selectChip(chipIndex) {
                    var $chip = this.$chips.eq(chipIndex);
                    this._selectedChip = $chip;
                    $chip[0].focus();
                    // fire chipSelect callback
                    if (typeof this.options.onChipSelect === 'function') this.options.onChipSelect.call(this, this.$el, $chip[0]);
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Chips.__proto__ || Object.getPrototypeOf(Chips), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Chips;
                }
            },
            {
                key: "_handleChipsKeydown",
                value: function _handleChipsKeydown(e) {
                    Chips._keydown = true;
                    var $chips = $(e.target).closest('.chips');
                    var chipsKeydown = e.target && $chips.length;
                    // Don't handle keydown inputs on input and textarea
                    if ($(e.target).is('input, textarea') || !chipsKeydown) return;
                    var currChips = $chips[0].M_Chips;
                    // backspace and delete
                    if (e.keyCode === 8 || e.keyCode === 46) {
                        e.preventDefault();
                        var selectIndex = currChips.chipsData.length;
                        if (currChips._selectedChip) {
                            var index = currChips._selectedChip.index();
                            currChips.deleteChip(index);
                            currChips._selectedChip = null;
                            // Make sure selectIndex doesn't go negative
                            selectIndex = Math.max(index - 1, 0);
                        }
                        if (currChips.chipsData.length) currChips.selectChip(selectIndex);
                    // left arrow key
                    } else if (e.keyCode === 37) {
                        if (currChips._selectedChip) {
                            var _selectIndex = currChips._selectedChip.index() - 1;
                            if (_selectIndex < 0) return;
                            currChips.selectChip(_selectIndex);
                        }
                    } else if (e.keyCode === 39) {
                        if (currChips._selectedChip) {
                            var _selectIndex2 = currChips._selectedChip.index() + 1;
                            if (_selectIndex2 >= currChips.chipsData.length) currChips.$input[0].focus();
                            else currChips.selectChip(_selectIndex2);
                        }
                    }
                }
            },
            {
                key: "_handleChipsKeyup",
                value: function _handleChipsKeyup(e) {
                    Chips._keydown = false;
                }
            },
            {
                key: "_handleChipsBlur",
                value: function _handleChipsBlur(e) {
                    if (!Chips._keydown) {
                        var $chips = $(e.target).closest('.chips');
                        var currChips = $chips[0].M_Chips;
                        currChips._selectedChip = null;
                    }
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Chips;
    }(Component);
    /**
   * @static
   * @memberof Chips
   */ Chips1._keydown = false;
    M.Chips = Chips1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Chips1, 'chips', 'M_Chips');
    $(document).ready(function() {
        // Handle removal of static chips.
        $(document.body).on('click', '.chip .close', function() {
            var $chips = $(this).closest('.chips');
            if ($chips.length && $chips[0].M_Chips) return;
            $(this).closest('.chip').remove();
        });
    });
})(cash);
(function($) {
    var _defaults = {
        top: 0,
        bottom: Infinity,
        offset: 0,
        onPositionChange: null
    };
    /**
   * @class
   *
   */ var Pushpin1 = function(_Component13) {
        _inherits(Pushpin, _Component13);
        /**
     * Construct Pushpin instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Pushpin(el, options) {
            _classCallCheck(this, Pushpin);
            var _this47 = _possibleConstructorReturn(this, (Pushpin.__proto__ || Object.getPrototypeOf(Pushpin)).call(this, Pushpin, el, options));
            _this47.el.M_Pushpin = _this47;
            /**
       * Options for the modal
       * @member Pushpin#options
       */ _this47.options = $.extend({
            }, Pushpin.defaults, options);
            _this47.originalOffset = _this47.el.offsetTop;
            Pushpin._pushpins.push(_this47);
            _this47._setupEventHandlers();
            _this47._updatePosition();
            return _this47;
        }
        _createClass(Pushpin, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this.el.style.top = null;
                    this._removePinClasses();
                    this._removeEventHandlers();
                    // Remove pushpin Inst
                    var index = Pushpin._pushpins.indexOf(this);
                    Pushpin._pushpins.splice(index, 1);
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    document.addEventListener('scroll', Pushpin._updateElements);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    document.removeEventListener('scroll', Pushpin._updateElements);
                }
            },
            {
                key: "_updatePosition",
                value: function _updatePosition() {
                    var scrolled = M.getDocumentScrollTop() + this.options.offset;
                    if (this.options.top <= scrolled && this.options.bottom >= scrolled && !this.el.classList.contains('pinned')) {
                        this._removePinClasses();
                        this.el.style.top = this.options.offset + "px";
                        this.el.classList.add('pinned');
                        // onPositionChange callback
                        if (typeof this.options.onPositionChange === 'function') this.options.onPositionChange.call(this, 'pinned');
                    }
                    // Add pin-top (when scrolled position is above top)
                    if (scrolled < this.options.top && !this.el.classList.contains('pin-top')) {
                        this._removePinClasses();
                        this.el.style.top = 0;
                        this.el.classList.add('pin-top');
                        // onPositionChange callback
                        if (typeof this.options.onPositionChange === 'function') this.options.onPositionChange.call(this, 'pin-top');
                    }
                    // Add pin-bottom (when scrolled position is below bottom)
                    if (scrolled > this.options.bottom && !this.el.classList.contains('pin-bottom')) {
                        this._removePinClasses();
                        this.el.classList.add('pin-bottom');
                        this.el.style.top = this.options.bottom - this.originalOffset + "px";
                        // onPositionChange callback
                        if (typeof this.options.onPositionChange === 'function') this.options.onPositionChange.call(this, 'pin-bottom');
                    }
                }
            },
            {
                key: "_removePinClasses",
                value: function _removePinClasses() {
                    // IE 11 bug (can't remove multiple classes in one line)
                    this.el.classList.remove('pin-top');
                    this.el.classList.remove('pinned');
                    this.el.classList.remove('pin-bottom');
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Pushpin.__proto__ || Object.getPrototypeOf(Pushpin), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Pushpin;
                }
            },
            {
                key: "_updateElements",
                value: function _updateElements() {
                    for(var elIndex in Pushpin._pushpins){
                        var pInstance = Pushpin._pushpins[elIndex];
                        pInstance._updatePosition();
                    }
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Pushpin;
    }(Component);
    /**
   * @static
   * @memberof Pushpin
   */ Pushpin1._pushpins = [];
    M.Pushpin = Pushpin1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Pushpin1, 'pushpin', 'M_Pushpin');
})(cash);
(function($, anim) {
    var _defaults = {
        direction: 'top',
        hoverEnabled: true,
        toolbarEnabled: false
    };
    $.fn.reverse = [].reverse;
    /**
   * @class
   *
   */ var FloatingActionButton1 = function(_Component14) {
        _inherits(FloatingActionButton, _Component14);
        /**
     * Construct FloatingActionButton instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function FloatingActionButton(el, options) {
            _classCallCheck(this, FloatingActionButton);
            var _this48 = _possibleConstructorReturn(this, (FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton)).call(this, FloatingActionButton, el, options));
            _this48.el.M_FloatingActionButton = _this48;
            /**
       * Options for the fab
       * @member FloatingActionButton#options
       * @prop {Boolean} [direction] - Direction fab menu opens
       * @prop {Boolean} [hoverEnabled=true] - Enable hover vs click
       * @prop {Boolean} [toolbarEnabled=false] - Enable toolbar transition
       */ _this48.options = $.extend({
            }, FloatingActionButton.defaults, options);
            _this48.isOpen = false;
            _this48.$anchor = _this48.$el.children('a').first();
            _this48.$menu = _this48.$el.children('ul').first();
            _this48.$floatingBtns = _this48.$el.find('ul .btn-floating');
            _this48.$floatingBtnsReverse = _this48.$el.find('ul .btn-floating').reverse();
            _this48.offsetY = 0;
            _this48.offsetX = 0;
            _this48.$el.addClass("direction-" + _this48.options.direction);
            if (_this48.options.direction === 'top') _this48.offsetY = 40;
            else if (_this48.options.direction === 'right') _this48.offsetX = -40;
            else if (_this48.options.direction === 'bottom') _this48.offsetY = -40;
            else _this48.offsetX = 40;
            _this48._setupEventHandlers();
            return _this48;
        }
        _createClass(FloatingActionButton, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.el.M_FloatingActionButton = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleFABClickBound = this._handleFABClick.bind(this);
                    this._handleOpenBound = this.open.bind(this);
                    this._handleCloseBound = this.close.bind(this);
                    if (this.options.hoverEnabled && !this.options.toolbarEnabled) {
                        this.el.addEventListener('mouseenter', this._handleOpenBound);
                        this.el.addEventListener('mouseleave', this._handleCloseBound);
                    } else this.el.addEventListener('click', this._handleFABClickBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    if (this.options.hoverEnabled && !this.options.toolbarEnabled) {
                        this.el.removeEventListener('mouseenter', this._handleOpenBound);
                        this.el.removeEventListener('mouseleave', this._handleCloseBound);
                    } else this.el.removeEventListener('click', this._handleFABClickBound);
                }
            },
            {
                key: "_handleFABClick",
                value: function _handleFABClick() {
                    if (this.isOpen) this.close();
                    else this.open();
                }
            },
            {
                key: "_handleDocumentClick",
                value: function _handleDocumentClick(e) {
                    if (!$(e.target).closest(this.$menu).length) this.close();
                }
            },
            {
                key: "open",
                value: function open() {
                    if (this.isOpen) return;
                    if (this.options.toolbarEnabled) this._animateInToolbar();
                    else this._animateInFAB();
                    this.isOpen = true;
                }
            },
            {
                key: "close",
                value: function close() {
                    if (!this.isOpen) return;
                    if (this.options.toolbarEnabled) {
                        window.removeEventListener('scroll', this._handleCloseBound, true);
                        document.body.removeEventListener('click', this._handleDocumentClickBound, true);
                        this._animateOutToolbar();
                    } else this._animateOutFAB();
                    this.isOpen = false;
                }
            },
            {
                key: "_animateInFAB",
                value: function _animateInFAB() {
                    var _this49 = this;
                    this.$el.addClass('active');
                    var time = 0;
                    this.$floatingBtnsReverse.each(function(el) {
                        anim({
                            targets: el,
                            opacity: 1,
                            scale: [
                                0.4,
                                1
                            ],
                            translateY: [
                                _this49.offsetY,
                                0
                            ],
                            translateX: [
                                _this49.offsetX,
                                0
                            ],
                            duration: 275,
                            delay: time,
                            easing: 'easeInOutQuad'
                        });
                        time += 40;
                    });
                }
            },
            {
                key: "_animateOutFAB",
                value: function _animateOutFAB() {
                    var _this50 = this;
                    this.$floatingBtnsReverse.each(function(el) {
                        anim.remove(el);
                        anim({
                            targets: el,
                            opacity: 0,
                            scale: 0.4,
                            translateY: _this50.offsetY,
                            translateX: _this50.offsetX,
                            duration: 175,
                            easing: 'easeOutQuad',
                            complete: function() {
                                _this50.$el.removeClass('active');
                            }
                        });
                    });
                }
            },
            {
                key: "_animateInToolbar",
                value: function _animateInToolbar() {
                    var _this51 = this;
                    var scaleFactor = void 0;
                    var windowWidth = window.innerWidth;
                    var windowHeight = window.innerHeight;
                    var btnRect = this.el.getBoundingClientRect();
                    var backdrop = $('<div class="fab-backdrop"></div>');
                    var fabColor = this.$anchor.css('background-color');
                    this.$anchor.append(backdrop);
                    this.offsetX = btnRect.left - windowWidth / 2 + btnRect.width / 2;
                    this.offsetY = windowHeight - btnRect.bottom;
                    scaleFactor = windowWidth / backdrop[0].clientWidth;
                    this.btnBottom = btnRect.bottom;
                    this.btnLeft = btnRect.left;
                    this.btnWidth = btnRect.width;
                    // Set initial state
                    this.$el.addClass('active');
                    this.$el.css({
                        'text-align': 'center',
                        width: '100%',
                        bottom: 0,
                        left: 0,
                        transform: 'translateX(' + this.offsetX + 'px)',
                        transition: 'none'
                    });
                    this.$anchor.css({
                        transform: 'translateY(' + -this.offsetY + 'px)',
                        transition: 'none'
                    });
                    backdrop.css({
                        'background-color': fabColor
                    });
                    setTimeout(function() {
                        _this51.$el.css({
                            transform: '',
                            transition: 'transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s'
                        });
                        _this51.$anchor.css({
                            overflow: 'visible',
                            transform: '',
                            transition: 'transform .2s'
                        });
                        setTimeout(function() {
                            _this51.$el.css({
                                overflow: 'hidden',
                                'background-color': fabColor
                            });
                            backdrop.css({
                                transform: 'scale(' + scaleFactor + ')',
                                transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
                            });
                            _this51.$menu.children('li').children('a').css({
                                opacity: 1
                            });
                            // Scroll to close.
                            _this51._handleDocumentClickBound = _this51._handleDocumentClick.bind(_this51);
                            window.addEventListener('scroll', _this51._handleCloseBound, true);
                            document.body.addEventListener('click', _this51._handleDocumentClickBound, true);
                        }, 100);
                    }, 0);
                }
            },
            {
                key: "_animateOutToolbar",
                value: function _animateOutToolbar() {
                    var _this52 = this;
                    var windowWidth = window.innerWidth;
                    var windowHeight = window.innerHeight;
                    var backdrop = this.$el.find('.fab-backdrop');
                    var fabColor = this.$anchor.css('background-color');
                    this.offsetX = this.btnLeft - windowWidth / 2 + this.btnWidth / 2;
                    this.offsetY = windowHeight - this.btnBottom;
                    // Hide backdrop
                    this.$el.removeClass('active');
                    this.$el.css({
                        'background-color': 'transparent',
                        transition: 'none'
                    });
                    this.$anchor.css({
                        transition: 'none'
                    });
                    backdrop.css({
                        transform: 'scale(0)',
                        'background-color': fabColor
                    });
                    this.$menu.children('li').children('a').css({
                        opacity: ''
                    });
                    setTimeout(function() {
                        backdrop.remove();
                        // Set initial state.
                        _this52.$el.css({
                            'text-align': '',
                            width: '',
                            bottom: '',
                            left: '',
                            overflow: '',
                            'background-color': '',
                            transform: 'translate3d(' + -_this52.offsetX + 'px,0,0)'
                        });
                        _this52.$anchor.css({
                            overflow: '',
                            transform: 'translate3d(0,' + _this52.offsetY + 'px,0)'
                        });
                        setTimeout(function() {
                            _this52.$el.css({
                                transform: 'translate3d(0,0,0)',
                                transition: 'transform .2s'
                            });
                            _this52.$anchor.css({
                                transform: 'translate3d(0,0,0)',
                                transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
                            });
                        }, 20);
                    }, 200);
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_FloatingActionButton;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return FloatingActionButton;
    }(Component);
    M.FloatingActionButton = FloatingActionButton1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(FloatingActionButton1, 'floatingActionButton', 'M_FloatingActionButton');
})(cash, M.anime);
(function($) {
    var _defaults = {
        // Close when date is selected
        autoClose: false,
        // the default output format for the input field value
        format: 'mmm dd, yyyy',
        // Used to create date object from current input string
        parse: null,
        // The initial date to view when first opened
        defaultDate: null,
        // Make the `defaultDate` the initial selected value
        setDefaultDate: false,
        disableWeekends: false,
        disableDayFn: null,
        // First day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,
        // The earliest date that can be selected
        minDate: null,
        // Thelatest date that can be selected
        maxDate: null,
        // Number of years either side, or array of upper/lower range
        yearRange: 10,
        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: undefined,
        maxMonth: undefined,
        startRange: null,
        endRange: null,
        isRTL: false,
        // Render the month after year in the calendar title
        showMonthAfterYear: false,
        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,
        // Specify a DOM element to render the calendar in
        container: null,
        // Show clear button
        showClearBtn: false,
        // internationalization
        i18n: {
            cancel: 'Cancel',
            clear: 'Clear',
            done: 'Ok',
            previousMonth: '‹',
            nextMonth: '›',
            months: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December'
            ],
            monthsShort: [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'
            ],
            weekdays: [
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ],
            weekdaysShort: [
                'Sun',
                'Mon',
                'Tue',
                'Wed',
                'Thu',
                'Fri',
                'Sat'
            ],
            weekdaysAbbrev: [
                'S',
                'M',
                'T',
                'W',
                'T',
                'F',
                'S'
            ]
        },
        // events array
        events: [],
        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null
    };
    /**
   * @class
   *
   */ var Datepicker1 = function(_Component15) {
        _inherits(Datepicker, _Component15);
        /**
     * Construct Datepicker instance and set up overlay
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Datepicker(el, options) {
            _classCallCheck(this, Datepicker);
            var _this53 = _possibleConstructorReturn(this, (Datepicker.__proto__ || Object.getPrototypeOf(Datepicker)).call(this, Datepicker, el, options));
            _this53.el.M_Datepicker = _this53;
            _this53.options = $.extend({
            }, Datepicker.defaults, options);
            // make sure i18n defaults are not lost when only few i18n option properties are passed
            if (!!options && options.hasOwnProperty('i18n') && typeof options.i18n === 'object') _this53.options.i18n = $.extend({
            }, Datepicker.defaults.i18n, options.i18n);
            // Remove time component from minDate and maxDate options
            if (_this53.options.minDate) _this53.options.minDate.setHours(0, 0, 0, 0);
            if (_this53.options.maxDate) _this53.options.maxDate.setHours(0, 0, 0, 0);
            _this53.id = M.guid();
            _this53._setupVariables();
            _this53._insertHTMLIntoDOM();
            _this53._setupModal();
            _this53._setupEventHandlers();
            if (!_this53.options.defaultDate) _this53.options.defaultDate = new Date(Date.parse(_this53.el.value));
            var defDate = _this53.options.defaultDate;
            if (Datepicker._isDate(defDate)) {
                if (_this53.options.setDefaultDate) {
                    _this53.setDate(defDate, true);
                    _this53.setInputValue();
                } else _this53.gotoDate(defDate);
            } else _this53.gotoDate(new Date());
            /**
       * Describes open/close state of datepicker
       * @type {Boolean}
       */ _this53.isOpen = false;
            return _this53;
        }
        _createClass(Datepicker, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.modal.destroy();
                    $(this.modalEl).remove();
                    this.destroySelects();
                    this.el.M_Datepicker = undefined;
                }
            },
            {
                key: "destroySelects",
                value: function destroySelects() {
                    var oldYearSelect = this.calendarEl.querySelector('.orig-select-year');
                    if (oldYearSelect) M.FormSelect.getInstance(oldYearSelect).destroy();
                    var oldMonthSelect = this.calendarEl.querySelector('.orig-select-month');
                    if (oldMonthSelect) M.FormSelect.getInstance(oldMonthSelect).destroy();
                }
            },
            {
                key: "_insertHTMLIntoDOM",
                value: function _insertHTMLIntoDOM() {
                    if (this.options.showClearBtn) {
                        $(this.clearBtn).css({
                            visibility: ''
                        });
                        this.clearBtn.innerHTML = this.options.i18n.clear;
                    }
                    this.doneBtn.innerHTML = this.options.i18n.done;
                    this.cancelBtn.innerHTML = this.options.i18n.cancel;
                    if (this.options.container) this.$modalEl.appendTo(this.options.container);
                    else this.$modalEl.insertBefore(this.el);
                }
            },
            {
                key: "_setupModal",
                value: function _setupModal() {
                    var _this54 = this;
                    this.modalEl.id = 'modal-' + this.id;
                    this.modal = M.Modal.init(this.modalEl, {
                        onCloseEnd: function() {
                            _this54.isOpen = false;
                        }
                    });
                }
            },
            {
                key: "toString",
                value: function toString(format) {
                    var _this55 = this;
                    format = format || this.options.format;
                    if (!Datepicker._isDate(this.date)) return '';
                    var formatArray = format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
                    var formattedDate = formatArray.map(function(label) {
                        if (_this55.formats[label]) return _this55.formats[label]();
                        return label;
                    }).join('');
                    return formattedDate;
                }
            },
            {
                key: "setDate",
                value: function setDate(date, preventOnSelect) {
                    if (!date) {
                        this.date = null;
                        this._renderDateDisplay();
                        return this.draw();
                    }
                    if (typeof date === 'string') date = new Date(Date.parse(date));
                    if (!Datepicker._isDate(date)) return;
                    var min = this.options.minDate, max = this.options.maxDate;
                    if (Datepicker._isDate(min) && date < min) date = min;
                    else if (Datepicker._isDate(max) && date > max) date = max;
                    this.date = new Date(date.getTime());
                    this._renderDateDisplay();
                    Datepicker._setToStartOfDay(this.date);
                    this.gotoDate(this.date);
                    if (!preventOnSelect && typeof this.options.onSelect === 'function') this.options.onSelect.call(this, this.date);
                }
            },
            {
                key: "setInputValue",
                value: function setInputValue() {
                    this.el.value = this.toString();
                    this.$el.trigger('change', {
                        firedBy: this
                    });
                }
            },
            {
                key: "_renderDateDisplay",
                value: function _renderDateDisplay() {
                    var displayDate = Datepicker._isDate(this.date) ? this.date : new Date();
                    var i18n = this.options.i18n;
                    var day = i18n.weekdaysShort[displayDate.getDay()];
                    var month = i18n.monthsShort[displayDate.getMonth()];
                    var date = displayDate.getDate();
                    this.yearTextEl.innerHTML = displayDate.getFullYear();
                    this.dateTextEl.innerHTML = day + ", " + month + " " + date;
                }
            },
            {
                key: "gotoDate",
                value: function gotoDate(date) {
                    var newCalendar = true;
                    if (!Datepicker._isDate(date)) return;
                    if (this.calendars) {
                        var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), visibleDate = date.getTime();
                        // get the end of the month
                        lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
                        lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
                        newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
                    }
                    if (newCalendar) this.calendars = [
                        {
                            month: date.getMonth(),
                            year: date.getFullYear()
                        }
                    ];
                    this.adjustCalendars();
                }
            },
            {
                key: "adjustCalendars",
                value: function adjustCalendars() {
                    this.calendars[0] = this.adjustCalendar(this.calendars[0]);
                    this.draw();
                }
            },
            {
                key: "adjustCalendar",
                value: function adjustCalendar(calendar) {
                    if (calendar.month < 0) {
                        calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
                        calendar.month += 12;
                    }
                    if (calendar.month > 11) {
                        calendar.year += Math.floor(Math.abs(calendar.month) / 12);
                        calendar.month -= 12;
                    }
                    return calendar;
                }
            },
            {
                key: "nextMonth",
                value: function nextMonth() {
                    this.calendars[0].month++;
                    this.adjustCalendars();
                }
            },
            {
                key: "prevMonth",
                value: function prevMonth() {
                    this.calendars[0].month--;
                    this.adjustCalendars();
                }
            },
            {
                key: "render",
                value: function render(year, month, randId) {
                    var opts = this.options, now = new Date(), days = Datepicker._getDaysInMonth(year, month), before = new Date(year, month, 1).getDay(), data = [], row = [];
                    Datepicker._setToStartOfDay(now);
                    if (opts.firstDay > 0) {
                        before -= opts.firstDay;
                        if (before < 0) before += 7;
                    }
                    var previousMonth = month === 0 ? 11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth = month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : year, daysInPreviousMonth = Datepicker._getDaysInMonth(yearOfPreviousMonth, previousMonth);
                    var cells = days + before, after = cells;
                    while(after > 7)after -= 7;
                    cells += 7 - after;
                    var isWeekSelected = false;
                    for(var i = 0, r = 0; i < cells; i++){
                        var day = new Date(year, month, 1 + (i - before)), isSelected = Datepicker._isDate(this.date) ? Datepicker._compareDates(day, this.date) : false, isToday = Datepicker._compareDates(day, now), hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false, isEmpty = i < before || i >= days + before, dayNumber = 1 + (i - before), monthNumber = month, yearNumber = year, isStartRange = opts.startRange && Datepicker._compareDates(opts.startRange, day), isEndRange = opts.endRange && Datepicker._compareDates(opts.endRange, day), isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && Datepicker._isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
                        if (isEmpty) {
                            if (i < before) {
                                dayNumber = daysInPreviousMonth + dayNumber;
                                monthNumber = previousMonth;
                                yearNumber = yearOfPreviousMonth;
                            } else {
                                dayNumber = dayNumber - days;
                                monthNumber = nextMonth;
                                yearNumber = yearOfNextMonth;
                            }
                        }
                        var dayConfig = {
                            day: dayNumber,
                            month: monthNumber,
                            year: yearNumber,
                            hasEvent: hasEvent,
                            isSelected: isSelected,
                            isToday: isToday,
                            isDisabled: isDisabled,
                            isEmpty: isEmpty,
                            isStartRange: isStartRange,
                            isEndRange: isEndRange,
                            isInRange: isInRange,
                            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths
                        };
                        row.push(this.renderDay(dayConfig));
                        if (++r === 7) {
                            data.push(this.renderRow(row, opts.isRTL, isWeekSelected));
                            row = [];
                            r = 0;
                            isWeekSelected = false;
                        }
                    }
                    return this.renderTable(opts, data, randId);
                }
            },
            {
                key: "renderDay",
                value: function renderDay(opts) {
                    var arr = [];
                    var ariaSelected = 'false';
                    if (opts.isEmpty) {
                        if (opts.showDaysInNextAndPreviousMonths) {
                            arr.push('is-outside-current-month');
                            arr.push('is-selection-disabled');
                        } else return '<td class="is-empty"></td>';
                    }
                    if (opts.isDisabled) arr.push('is-disabled');
                    if (opts.isToday) arr.push('is-today');
                    if (opts.isSelected) {
                        arr.push('is-selected');
                        ariaSelected = 'true';
                    }
                    if (opts.hasEvent) arr.push('has-event');
                    if (opts.isInRange) arr.push('is-inrange');
                    if (opts.isStartRange) arr.push('is-startrange');
                    if (opts.isEndRange) arr.push('is-endrange');
                    return "<td data-day=\"" + opts.day + "\" class=\"" + arr.join(' ') + "\" aria-selected=\"" + ariaSelected + "\">" + ("<button class=\"datepicker-day-button\" type=\"button\" data-year=\"" + opts.year + "\" data-month=\"" + opts.month + "\" data-day=\"" + opts.day + "\">" + opts.day + "</button>") + '</td>';
                }
            },
            {
                key: "renderRow",
                value: function renderRow(days, isRTL, isRowSelected) {
                    return '<tr class="datepicker-row' + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
                }
            },
            {
                key: "renderTable",
                value: function renderTable(opts, data, randId) {
                    return '<div class="datepicker-table-wrapper"><table cellpadding="0" cellspacing="0" class="datepicker-table" role="grid" aria-labelledby="' + randId + '">' + this.renderHead(opts) + this.renderBody(data) + '</table></div>';
                }
            },
            {
                key: "renderHead",
                value: function renderHead(opts) {
                    var i = void 0, arr = [];
                    for(i = 0; i < 7; i++)arr.push("<th scope=\"col\"><abbr title=\"" + this.renderDayName(opts, i) + "\">" + this.renderDayName(opts, i, true) + "</abbr></th>");
                    return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
                }
            },
            {
                key: "renderBody",
                value: function renderBody(rows) {
                    return '<tbody>' + rows.join('') + '</tbody>';
                }
            },
            {
                key: "renderTitle",
                value: function renderTitle(instance, c, year, month, refYear, randId) {
                    var i = void 0, j = void 0, arr = void 0, opts = this.options, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html = '<div id="' + randId + '" class="datepicker-controls" role="heading" aria-live="assertive">', monthHtml = void 0, yearHtml = void 0, prev = true, next = true;
                    for(arr = [], i = 0; i < 12; i++)arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : '') + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? 'disabled="disabled"' : '') + '>' + opts.i18n.months[i] + '</option>');
                    monthHtml = '<select class="datepicker-select orig-select-month" tabindex="-1">' + arr.join('') + '</select>';
                    if ($.isArray(opts.yearRange)) {
                        i = opts.yearRange[0];
                        j = opts.yearRange[1] + 1;
                    } else {
                        i = year - opts.yearRange;
                        j = 1 + year + opts.yearRange;
                    }
                    for(arr = []; i < j && i <= opts.maxYear; i++)if (i >= opts.minYear) arr.push("<option value=\"" + i + "\" " + (i === year ? 'selected="selected"' : '') + ">" + i + "</option>");
                    yearHtml = "<select class=\"datepicker-select orig-select-year\" tabindex=\"-1\">" + arr.join('') + "</select>";
                    var leftArrow = '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"/><path d="M0-.5h24v24H0z" fill="none"/></svg>';
                    html += "<button class=\"month-prev" + (prev ? '' : ' is-disabled') + "\" type=\"button\">" + leftArrow + "</button>";
                    html += '<div class="selects-container">';
                    if (opts.showMonthAfterYear) html += yearHtml + monthHtml;
                    else html += monthHtml + yearHtml;
                    html += '</div>';
                    if (isMinYear && (month === 0 || opts.minMonth >= month)) prev = false;
                    if (isMaxYear && (month === 11 || opts.maxMonth <= month)) next = false;
                    var rightArrow = '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"/><path d="M0-.25h24v24H0z" fill="none"/></svg>';
                    html += "<button class=\"month-next" + (next ? '' : ' is-disabled') + "\" type=\"button\">" + rightArrow + "</button>";
                    return html += '</div>';
                }
            },
            {
                key: "draw",
                value: function draw(force) {
                    if (!this.isOpen && !force) return;
                    var opts = this.options, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html = '', randId = void 0;
                    if (this._y <= minYear) {
                        this._y = minYear;
                        if (!isNaN(minMonth) && this._m < minMonth) this._m = minMonth;
                    }
                    if (this._y >= maxYear) {
                        this._y = maxYear;
                        if (!isNaN(maxMonth) && this._m > maxMonth) this._m = maxMonth;
                    }
                    randId = 'datepicker-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);
                    for(var c = 0; c < 1; c++){
                        this._renderDateDisplay();
                        html += this.renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId);
                    }
                    this.destroySelects();
                    this.calendarEl.innerHTML = html;
                    // Init Materialize Select
                    var yearSelect = this.calendarEl.querySelector('.orig-select-year');
                    var monthSelect = this.calendarEl.querySelector('.orig-select-month');
                    M.FormSelect.init(yearSelect, {
                        classes: 'select-year',
                        dropdownOptions: {
                            container: document.body,
                            constrainWidth: false
                        }
                    });
                    M.FormSelect.init(monthSelect, {
                        classes: 'select-month',
                        dropdownOptions: {
                            container: document.body,
                            constrainWidth: false
                        }
                    });
                    // Add change handlers for select
                    yearSelect.addEventListener('change', this._handleYearChange.bind(this));
                    monthSelect.addEventListener('change', this._handleMonthChange.bind(this));
                    if (typeof this.options.onDraw === 'function') this.options.onDraw(this);
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
                    this._handleInputClickBound = this._handleInputClick.bind(this);
                    this._handleInputChangeBound = this._handleInputChange.bind(this);
                    this._handleCalendarClickBound = this._handleCalendarClick.bind(this);
                    this._finishSelectionBound = this._finishSelection.bind(this);
                    this._handleMonthChange = this._handleMonthChange.bind(this);
                    this._closeBound = this.close.bind(this);
                    this.el.addEventListener('click', this._handleInputClickBound);
                    this.el.addEventListener('keydown', this._handleInputKeydownBound);
                    this.el.addEventListener('change', this._handleInputChangeBound);
                    this.calendarEl.addEventListener('click', this._handleCalendarClickBound);
                    this.doneBtn.addEventListener('click', this._finishSelectionBound);
                    this.cancelBtn.addEventListener('click', this._closeBound);
                    if (this.options.showClearBtn) {
                        this._handleClearClickBound = this._handleClearClick.bind(this);
                        this.clearBtn.addEventListener('click', this._handleClearClickBound);
                    }
                }
            },
            {
                key: "_setupVariables",
                value: function _setupVariables() {
                    var _this56 = this;
                    this.$modalEl = $(Datepicker._template);
                    this.modalEl = this.$modalEl[0];
                    this.calendarEl = this.modalEl.querySelector('.datepicker-calendar');
                    this.yearTextEl = this.modalEl.querySelector('.year-text');
                    this.dateTextEl = this.modalEl.querySelector('.date-text');
                    if (this.options.showClearBtn) this.clearBtn = this.modalEl.querySelector('.datepicker-clear');
                    this.doneBtn = this.modalEl.querySelector('.datepicker-done');
                    this.cancelBtn = this.modalEl.querySelector('.datepicker-cancel');
                    this.formats = {
                        d: function() {
                            return _this56.date.getDate();
                        },
                        dd: function() {
                            var d = _this56.date.getDate();
                            return (d < 10 ? '0' : '') + d;
                        },
                        ddd: function() {
                            return _this56.options.i18n.weekdaysShort[_this56.date.getDay()];
                        },
                        dddd: function() {
                            return _this56.options.i18n.weekdays[_this56.date.getDay()];
                        },
                        m: function() {
                            return _this56.date.getMonth() + 1;
                        },
                        mm: function() {
                            var m = _this56.date.getMonth() + 1;
                            return (m < 10 ? '0' : '') + m;
                        },
                        mmm: function() {
                            return _this56.options.i18n.monthsShort[_this56.date.getMonth()];
                        },
                        mmmm: function() {
                            return _this56.options.i18n.months[_this56.date.getMonth()];
                        },
                        yy: function() {
                            return ('' + _this56.date.getFullYear()).slice(2);
                        },
                        yyyy: function() {
                            return _this56.date.getFullYear();
                        }
                    };
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('click', this._handleInputClickBound);
                    this.el.removeEventListener('keydown', this._handleInputKeydownBound);
                    this.el.removeEventListener('change', this._handleInputChangeBound);
                    this.calendarEl.removeEventListener('click', this._handleCalendarClickBound);
                }
            },
            {
                key: "_handleInputClick",
                value: function _handleInputClick() {
                    this.open();
                }
            },
            {
                key: "_handleInputKeydown",
                value: function _handleInputKeydown(e) {
                    if (e.which === M.keys.ENTER) {
                        e.preventDefault();
                        this.open();
                    }
                }
            },
            {
                key: "_handleCalendarClick",
                value: function _handleCalendarClick(e) {
                    if (!this.isOpen) return;
                    var $target = $(e.target);
                    if (!$target.hasClass('is-disabled')) {
                        if ($target.hasClass('datepicker-day-button') && !$target.hasClass('is-empty') && !$target.parent().hasClass('is-disabled')) {
                            this.setDate(new Date(e.target.getAttribute('data-year'), e.target.getAttribute('data-month'), e.target.getAttribute('data-day')));
                            if (this.options.autoClose) this._finishSelection();
                        } else if ($target.closest('.month-prev').length) this.prevMonth();
                        else if ($target.closest('.month-next').length) this.nextMonth();
                    }
                }
            },
            {
                key: "_handleClearClick",
                value: function _handleClearClick() {
                    this.date = null;
                    this.setInputValue();
                    this.close();
                }
            },
            {
                key: "_handleMonthChange",
                value: function _handleMonthChange(e) {
                    this.gotoMonth(e.target.value);
                }
            },
            {
                key: "_handleYearChange",
                value: function _handleYearChange(e) {
                    this.gotoYear(e.target.value);
                }
            },
            {
                key: "gotoMonth",
                value: function gotoMonth(month) {
                    if (!isNaN(month)) {
                        this.calendars[0].month = parseInt(month, 10);
                        this.adjustCalendars();
                    }
                }
            },
            {
                key: "gotoYear",
                value: function gotoYear(year) {
                    if (!isNaN(year)) {
                        this.calendars[0].year = parseInt(year, 10);
                        this.adjustCalendars();
                    }
                }
            },
            {
                key: "_handleInputChange",
                value: function _handleInputChange(e) {
                    var date = void 0;
                    // Prevent change event from being fired when triggered by the plugin
                    if (e.firedBy === this) return;
                    if (this.options.parse) date = this.options.parse(this.el.value, this.options.format);
                    else date = new Date(Date.parse(this.el.value));
                    if (Datepicker._isDate(date)) this.setDate(date);
                }
            },
            {
                key: "renderDayName",
                value: function renderDayName(opts, day, abbr) {
                    day += opts.firstDay;
                    while(day >= 7)day -= 7;
                    return abbr ? opts.i18n.weekdaysAbbrev[day] : opts.i18n.weekdays[day];
                }
            },
            {
                key: "_finishSelection",
                value: function _finishSelection() {
                    this.setInputValue();
                    this.close();
                }
            },
            {
                key: "open",
                value: function open() {
                    if (this.isOpen) return;
                    this.isOpen = true;
                    if (typeof this.options.onOpen === 'function') this.options.onOpen.call(this);
                    this.draw();
                    this.modal.open();
                    return this;
                }
            },
            {
                key: "close",
                value: function close() {
                    if (!this.isOpen) return;
                    this.isOpen = false;
                    if (typeof this.options.onClose === 'function') this.options.onClose.call(this);
                    this.modal.close();
                    return this;
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Datepicker.__proto__ || Object.getPrototypeOf(Datepicker), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "_isDate",
                value: function _isDate(obj) {
                    return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
                }
            },
            {
                key: "_isWeekend",
                value: function _isWeekend(date) {
                    var day = date.getDay();
                    return day === 0 || day === 6;
                }
            },
            {
                key: "_setToStartOfDay",
                value: function _setToStartOfDay(date) {
                    if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);
                }
            },
            {
                key: "_getDaysInMonth",
                value: function _getDaysInMonth(year, month) {
                    return [
                        31,
                        Datepicker._isLeapYear(year) ? 29 : 28,
                        31,
                        30,
                        31,
                        30,
                        31,
                        31,
                        30,
                        31,
                        30,
                        31
                    ][month];
                }
            },
            {
                key: "_isLeapYear",
                value: function _isLeapYear(year) {
                    // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
                    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
                }
            },
            {
                key: "_compareDates",
                value: function _compareDates(a, b) {
                    // weak date comparison (use setToStartOfDay(date) to ensure correct result)
                    return a.getTime() === b.getTime();
                }
            },
            {
                key: "_setToStartOfDay",
                value: function _setToStartOfDay(date) {
                    if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Datepicker;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Datepicker;
    }(Component);
    Datepicker1._template = [
        '<div class= "modal datepicker-modal">',
        '<div class="modal-content datepicker-container">',
        '<div class="datepicker-date-display">',
        '<span class="year-text"></span>',
        '<span class="date-text"></span>',
        '</div>',
        '<div class="datepicker-calendar-container">',
        '<div class="datepicker-calendar"></div>',
        '<div class="datepicker-footer">',
        '<button class="btn-flat datepicker-clear waves-effect" style="visibility: hidden;" type="button"></button>',
        '<div class="confirmation-btns">',
        '<button class="btn-flat datepicker-cancel waves-effect" type="button"></button>',
        '<button class="btn-flat datepicker-done waves-effect" type="button"></button>',
        '</div>',
        '</div>',
        '</div>',
        '</div>',
        '</div>'
    ].join('');
    M.Datepicker = Datepicker1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Datepicker1, 'datepicker', 'M_Datepicker');
})(cash);
(function($) {
    var _defaults = {
        dialRadius: 135,
        outerRadius: 105,
        innerRadius: 70,
        tickRadius: 20,
        duration: 350,
        container: null,
        defaultTime: 'now',
        fromNow: 0,
        showClearBtn: false,
        // internationalization
        i18n: {
            cancel: 'Cancel',
            clear: 'Clear',
            done: 'Ok'
        },
        autoClose: false,
        twelveHour: true,
        vibrate: true,
        // Callbacks
        onOpenStart: null,
        onOpenEnd: null,
        onCloseStart: null,
        onCloseEnd: null,
        onSelect: null
    };
    /**
   * @class
   *
   */ var Timepicker1 = function(_Component16) {
        _inherits(Timepicker, _Component16);
        function Timepicker(el, options) {
            _classCallCheck(this, Timepicker);
            var _this57 = _possibleConstructorReturn(this, (Timepicker.__proto__ || Object.getPrototypeOf(Timepicker)).call(this, Timepicker, el, options));
            _this57.el.M_Timepicker = _this57;
            _this57.options = $.extend({
            }, Timepicker.defaults, options);
            _this57.id = M.guid();
            _this57._insertHTMLIntoDOM();
            _this57._setupModal();
            _this57._setupVariables();
            _this57._setupEventHandlers();
            _this57._clockSetup();
            _this57._pickerSetup();
            return _this57;
        }
        _createClass(Timepicker, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.modal.destroy();
                    $(this.modalEl).remove();
                    this.el.M_Timepicker = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
                    this._handleInputClickBound = this._handleInputClick.bind(this);
                    this._handleClockClickStartBound = this._handleClockClickStart.bind(this);
                    this._handleDocumentClickMoveBound = this._handleDocumentClickMove.bind(this);
                    this._handleDocumentClickEndBound = this._handleDocumentClickEnd.bind(this);
                    this.el.addEventListener('click', this._handleInputClickBound);
                    this.el.addEventListener('keydown', this._handleInputKeydownBound);
                    this.plate.addEventListener('mousedown', this._handleClockClickStartBound);
                    this.plate.addEventListener('touchstart', this._handleClockClickStartBound);
                    $(this.spanHours).on('click', this.showView.bind(this, 'hours'));
                    $(this.spanMinutes).on('click', this.showView.bind(this, 'minutes'));
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('click', this._handleInputClickBound);
                    this.el.removeEventListener('keydown', this._handleInputKeydownBound);
                }
            },
            {
                key: "_handleInputClick",
                value: function _handleInputClick() {
                    this.open();
                }
            },
            {
                key: "_handleInputKeydown",
                value: function _handleInputKeydown(e) {
                    if (e.which === M.keys.ENTER) {
                        e.preventDefault();
                        this.open();
                    }
                }
            },
            {
                key: "_handleClockClickStart",
                value: function _handleClockClickStart(e) {
                    e.preventDefault();
                    var clockPlateBR = this.plate.getBoundingClientRect();
                    var offset = {
                        x: clockPlateBR.left,
                        y: clockPlateBR.top
                    };
                    this.x0 = offset.x + this.options.dialRadius;
                    this.y0 = offset.y + this.options.dialRadius;
                    this.moved = false;
                    var clickPos = Timepicker._Pos(e);
                    this.dx = clickPos.x - this.x0;
                    this.dy = clickPos.y - this.y0;
                    // Set clock hands
                    this.setHand(this.dx, this.dy, false);
                    // Mousemove on document
                    document.addEventListener('mousemove', this._handleDocumentClickMoveBound);
                    document.addEventListener('touchmove', this._handleDocumentClickMoveBound);
                    // Mouseup on document
                    document.addEventListener('mouseup', this._handleDocumentClickEndBound);
                    document.addEventListener('touchend', this._handleDocumentClickEndBound);
                }
            },
            {
                key: "_handleDocumentClickMove",
                value: function _handleDocumentClickMove(e) {
                    e.preventDefault();
                    var clickPos = Timepicker._Pos(e);
                    var x = clickPos.x - this.x0;
                    var y = clickPos.y - this.y0;
                    this.moved = true;
                    this.setHand(x, y, false, true);
                }
            },
            {
                key: "_handleDocumentClickEnd",
                value: function _handleDocumentClickEnd(e) {
                    var _this58 = this;
                    e.preventDefault();
                    document.removeEventListener('mouseup', this._handleDocumentClickEndBound);
                    document.removeEventListener('touchend', this._handleDocumentClickEndBound);
                    var clickPos = Timepicker._Pos(e);
                    var x = clickPos.x - this.x0;
                    var y = clickPos.y - this.y0;
                    if (this.moved && x === this.dx && y === this.dy) this.setHand(x, y);
                    if (this.currentView === 'hours') this.showView('minutes', this.options.duration / 2);
                    else if (this.options.autoClose) {
                        $(this.minutesView).addClass('timepicker-dial-out');
                        setTimeout(function() {
                            _this58.done();
                        }, this.options.duration / 2);
                    }
                    if (typeof this.options.onSelect === 'function') this.options.onSelect.call(this, this.hours, this.minutes);
                    // Unbind mousemove event
                    document.removeEventListener('mousemove', this._handleDocumentClickMoveBound);
                    document.removeEventListener('touchmove', this._handleDocumentClickMoveBound);
                }
            },
            {
                key: "_insertHTMLIntoDOM",
                value: function _insertHTMLIntoDOM() {
                    this.$modalEl = $(Timepicker._template);
                    this.modalEl = this.$modalEl[0];
                    this.modalEl.id = 'modal-' + this.id;
                    // Append popover to input by default
                    var containerEl = document.querySelector(this.options.container);
                    if (this.options.container && !!containerEl) this.$modalEl.appendTo(containerEl);
                    else this.$modalEl.insertBefore(this.el);
                }
            },
            {
                key: "_setupModal",
                value: function _setupModal() {
                    var _this59 = this;
                    this.modal = M.Modal.init(this.modalEl, {
                        onOpenStart: this.options.onOpenStart,
                        onOpenEnd: this.options.onOpenEnd,
                        onCloseStart: this.options.onCloseStart,
                        onCloseEnd: function() {
                            if (typeof _this59.options.onCloseEnd === 'function') _this59.options.onCloseEnd.call(_this59);
                            _this59.isOpen = false;
                        }
                    });
                }
            },
            {
                key: "_setupVariables",
                value: function _setupVariables() {
                    this.currentView = 'hours';
                    this.vibrate = navigator.vibrate ? 'vibrate' : navigator.webkitVibrate ? 'webkitVibrate' : null;
                    this._canvas = this.modalEl.querySelector('.timepicker-canvas');
                    this.plate = this.modalEl.querySelector('.timepicker-plate');
                    this.hoursView = this.modalEl.querySelector('.timepicker-hours');
                    this.minutesView = this.modalEl.querySelector('.timepicker-minutes');
                    this.spanHours = this.modalEl.querySelector('.timepicker-span-hours');
                    this.spanMinutes = this.modalEl.querySelector('.timepicker-span-minutes');
                    this.spanAmPm = this.modalEl.querySelector('.timepicker-span-am-pm');
                    this.footer = this.modalEl.querySelector('.timepicker-footer');
                    this.amOrPm = 'PM';
                }
            },
            {
                key: "_pickerSetup",
                value: function _pickerSetup() {
                    var $clearBtn = $("<button class=\"btn-flat timepicker-clear waves-effect\" style=\"visibility: hidden;\" type=\"button\" tabindex=\"" + (this.options.twelveHour ? '3' : '1') + "\">" + this.options.i18n.clear + "</button>").appendTo(this.footer).on('click', this.clear.bind(this));
                    if (this.options.showClearBtn) $clearBtn.css({
                        visibility: ''
                    });
                    var confirmationBtnsContainer = $('<div class="confirmation-btns"></div>');
                    $('<button class="btn-flat timepicker-close waves-effect" type="button" tabindex="' + (this.options.twelveHour ? '3' : '1') + '">' + this.options.i18n.cancel + '</button>').appendTo(confirmationBtnsContainer).on('click', this.close.bind(this));
                    $('<button class="btn-flat timepicker-close waves-effect" type="button" tabindex="' + (this.options.twelveHour ? '3' : '1') + '">' + this.options.i18n.done + '</button>').appendTo(confirmationBtnsContainer).on('click', this.done.bind(this));
                    confirmationBtnsContainer.appendTo(this.footer);
                }
            },
            {
                key: "_clockSetup",
                value: function _clockSetup() {
                    if (this.options.twelveHour) {
                        this.$amBtn = $('<div class="am-btn">AM</div>');
                        this.$pmBtn = $('<div class="pm-btn">PM</div>');
                        this.$amBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);
                        this.$pmBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);
                    }
                    this._buildHoursView();
                    this._buildMinutesView();
                    this._buildSVGClock();
                }
            },
            {
                key: "_buildSVGClock",
                value: function _buildSVGClock() {
                    // Draw clock hands and others
                    var dialRadius = this.options.dialRadius;
                    var tickRadius = this.options.tickRadius;
                    var diameter = dialRadius * 2;
                    var svg = Timepicker._createSVGEl('svg');
                    svg.setAttribute('class', 'timepicker-svg');
                    svg.setAttribute('width', diameter);
                    svg.setAttribute('height', diameter);
                    var g = Timepicker._createSVGEl('g');
                    g.setAttribute('transform', 'translate(' + dialRadius + ',' + dialRadius + ')');
                    var bearing = Timepicker._createSVGEl('circle');
                    bearing.setAttribute('class', 'timepicker-canvas-bearing');
                    bearing.setAttribute('cx', 0);
                    bearing.setAttribute('cy', 0);
                    bearing.setAttribute('r', 4);
                    var hand = Timepicker._createSVGEl('line');
                    hand.setAttribute('x1', 0);
                    hand.setAttribute('y1', 0);
                    var bg = Timepicker._createSVGEl('circle');
                    bg.setAttribute('class', 'timepicker-canvas-bg');
                    bg.setAttribute('r', tickRadius);
                    g.appendChild(hand);
                    g.appendChild(bg);
                    g.appendChild(bearing);
                    svg.appendChild(g);
                    this._canvas.appendChild(svg);
                    this.hand = hand;
                    this.bg = bg;
                    this.bearing = bearing;
                    this.g = g;
                }
            },
            {
                key: "_buildHoursView",
                value: function _buildHoursView() {
                    var $tick = $('<div class="timepicker-tick"></div>');
                    // Hours view
                    if (this.options.twelveHour) for(var i = 1; i < 13; i += 1){
                        var tick = $tick.clone();
                        var radian = i / 6 * Math.PI;
                        var radius = this.options.outerRadius;
                        tick.css({
                            left: this.options.dialRadius + Math.sin(radian) * radius - this.options.tickRadius + 'px',
                            top: this.options.dialRadius - Math.cos(radian) * radius - this.options.tickRadius + 'px'
                        });
                        tick.html(i === 0 ? '00' : i);
                        this.hoursView.appendChild(tick[0]);
                    // tick.on(mousedownEvent, mousedown);
                    }
                    else for(var _i2 = 0; _i2 < 24; _i2 += 1){
                        var _tick = $tick.clone();
                        var _radian = _i2 / 6 * Math.PI;
                        var inner = _i2 > 0 && _i2 < 13;
                        var _radius = inner ? this.options.innerRadius : this.options.outerRadius;
                        _tick.css({
                            left: this.options.dialRadius + Math.sin(_radian) * _radius - this.options.tickRadius + 'px',
                            top: this.options.dialRadius - Math.cos(_radian) * _radius - this.options.tickRadius + 'px'
                        });
                        _tick.html(_i2 === 0 ? '00' : _i2);
                        this.hoursView.appendChild(_tick[0]);
                    // tick.on(mousedownEvent, mousedown);
                    }
                }
            },
            {
                key: "_buildMinutesView",
                value: function _buildMinutesView() {
                    var $tick = $('<div class="timepicker-tick"></div>');
                    // Minutes view
                    for(var i = 0; i < 60; i += 5){
                        var tick = $tick.clone();
                        var radian = i / 30 * Math.PI;
                        tick.css({
                            left: this.options.dialRadius + Math.sin(radian) * this.options.outerRadius - this.options.tickRadius + 'px',
                            top: this.options.dialRadius - Math.cos(radian) * this.options.outerRadius - this.options.tickRadius + 'px'
                        });
                        tick.html(Timepicker._addLeadingZero(i));
                        this.minutesView.appendChild(tick[0]);
                    }
                }
            },
            {
                key: "_handleAmPmClick",
                value: function _handleAmPmClick(e) {
                    var $btnClicked = $(e.target);
                    this.amOrPm = $btnClicked.hasClass('am-btn') ? 'AM' : 'PM';
                    this._updateAmPmView();
                }
            },
            {
                key: "_updateAmPmView",
                value: function _updateAmPmView() {
                    if (this.options.twelveHour) {
                        this.$amBtn.toggleClass('text-primary', this.amOrPm === 'AM');
                        this.$pmBtn.toggleClass('text-primary', this.amOrPm === 'PM');
                    }
                }
            },
            {
                key: "_updateTimeFromInput",
                value: function _updateTimeFromInput() {
                    // Get the time
                    var value = ((this.el.value || this.options.defaultTime || '') + '').split(':');
                    if (this.options.twelveHour && !(typeof value[1] === 'undefined')) {
                        if (value[1].toUpperCase().indexOf('AM') > 0) this.amOrPm = 'AM';
                        else this.amOrPm = 'PM';
                        value[1] = value[1].replace('AM', '').replace('PM', '');
                    }
                    if (value[0] === 'now') {
                        var now = new Date(+new Date() + this.options.fromNow);
                        value = [
                            now.getHours(),
                            now.getMinutes()
                        ];
                        if (this.options.twelveHour) this.amOrPm = value[0] >= 12 && value[0] < 24 ? 'PM' : 'AM';
                    }
                    this.hours = +value[0] || 0;
                    this.minutes = +value[1] || 0;
                    this.spanHours.innerHTML = this.hours;
                    this.spanMinutes.innerHTML = Timepicker._addLeadingZero(this.minutes);
                    this._updateAmPmView();
                }
            },
            {
                key: "showView",
                value: function showView(view, delay) {
                    view === 'minutes' && $(this.hoursView).css('visibility');
                    var isHours = view === 'hours', nextView = isHours ? this.hoursView : this.minutesView, hideView = isHours ? this.minutesView : this.hoursView;
                    this.currentView = view;
                    $(this.spanHours).toggleClass('text-primary', isHours);
                    $(this.spanMinutes).toggleClass('text-primary', !isHours);
                    // Transition view
                    hideView.classList.add('timepicker-dial-out');
                    $(nextView).css('visibility', 'visible').removeClass('timepicker-dial-out');
                    // Reset clock hand
                    this.resetClock(delay);
                    // After transitions ended
                    clearTimeout(this.toggleViewTimer);
                    this.toggleViewTimer = setTimeout(function() {
                        $(hideView).css('visibility', 'hidden');
                    }, this.options.duration);
                }
            },
            {
                key: "resetClock",
                value: function resetClock(delay) {
                    var view = this.currentView, value = this[view], isHours = view === 'hours', unit = Math.PI / (isHours ? 6 : 30), radian = value * unit, radius = isHours && value > 0 && value < 13 ? this.options.innerRadius : this.options.outerRadius, x = Math.sin(radian) * radius, y = -Math.cos(radian) * radius, self = this;
                    if (delay) {
                        $(this.canvas).addClass('timepicker-canvas-out');
                        setTimeout(function() {
                            $(self.canvas).removeClass('timepicker-canvas-out');
                            self.setHand(x, y);
                        }, delay);
                    } else this.setHand(x, y);
                }
            },
            {
                key: "setHand",
                value: function setHand(x, y, roundBy5) {
                    var _this60 = this;
                    var radian = Math.atan2(x, -y), isHours = this.currentView === 'hours', unit = Math.PI / (isHours || roundBy5 ? 6 : 30), z = Math.sqrt(x * x + y * y), inner = isHours && z < (this.options.outerRadius + this.options.innerRadius) / 2, radius = inner ? this.options.innerRadius : this.options.outerRadius;
                    if (this.options.twelveHour) radius = this.options.outerRadius;
                    // Radian should in range [0, 2PI]
                    if (radian < 0) radian = Math.PI * 2 + radian;
                    // Get the round value
                    var value = Math.round(radian / unit);
                    // Get the round radian
                    radian = value * unit;
                    // Correct the hours or minutes
                    if (this.options.twelveHour) {
                        if (isHours) {
                            if (value === 0) value = 12;
                        } else {
                            if (roundBy5) value *= 5;
                            if (value === 60) value = 0;
                        }
                    } else if (isHours) {
                        if (value === 12) value = 0;
                        value = inner ? value === 0 ? 12 : value : value === 0 ? 0 : value + 12;
                    } else {
                        if (roundBy5) value *= 5;
                        if (value === 60) value = 0;
                    }
                    // Once hours or minutes changed, vibrate the device
                    if (this[this.currentView] !== value) {
                        if (this.vibrate && this.options.vibrate) // Do not vibrate too frequently
                        {
                            if (!this.vibrateTimer) {
                                navigator[this.vibrate](10);
                                this.vibrateTimer = setTimeout(function() {
                                    _this60.vibrateTimer = null;
                                }, 100);
                            }
                        }
                    }
                    this[this.currentView] = value;
                    if (isHours) this['spanHours'].innerHTML = value;
                    else this['spanMinutes'].innerHTML = Timepicker._addLeadingZero(value);
                    // Set clock hand and others' position
                    var cx1 = Math.sin(radian) * (radius - this.options.tickRadius), cy1 = -Math.cos(radian) * (radius - this.options.tickRadius), cx2 = Math.sin(radian) * radius, cy2 = -Math.cos(radian) * radius;
                    this.hand.setAttribute('x2', cx1);
                    this.hand.setAttribute('y2', cy1);
                    this.bg.setAttribute('cx', cx2);
                    this.bg.setAttribute('cy', cy2);
                }
            },
            {
                key: "open",
                value: function open() {
                    if (this.isOpen) return;
                    this.isOpen = true;
                    this._updateTimeFromInput();
                    this.showView('hours');
                    this.modal.open();
                }
            },
            {
                key: "close",
                value: function close() {
                    if (!this.isOpen) return;
                    this.isOpen = false;
                    this.modal.close();
                }
            },
            {
                key: "done",
                value: function done(e, clearValue) {
                    // Set input value
                    var last = this.el.value;
                    var value = clearValue ? '' : Timepicker._addLeadingZero(this.hours) + ':' + Timepicker._addLeadingZero(this.minutes);
                    this.time = value;
                    if (!clearValue && this.options.twelveHour) value = value + " " + this.amOrPm;
                    this.el.value = value;
                    // Trigger change event
                    if (value !== last) this.$el.trigger('change');
                    this.close();
                    this.el.focus();
                }
            },
            {
                key: "clear",
                value: function clear() {
                    this.done(null, true);
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Timepicker.__proto__ || Object.getPrototypeOf(Timepicker), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "_addLeadingZero",
                value: function _addLeadingZero(num) {
                    return (num < 10 ? '0' : '') + num;
                }
            },
            {
                key: "_createSVGEl",
                value: function _createSVGEl(name) {
                    var svgNS = 'http://www.w3.org/2000/svg';
                    return document.createElementNS(svgNS, name);
                }
            },
            {
                key: "_Pos",
                value: function _Pos(e) {
                    if (e.targetTouches && e.targetTouches.length >= 1) return {
                        x: e.targetTouches[0].clientX,
                        y: e.targetTouches[0].clientY
                    };
                    // mouse event
                    return {
                        x: e.clientX,
                        y: e.clientY
                    };
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Timepicker;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Timepicker;
    }(Component);
    Timepicker1._template = [
        '<div class= "modal timepicker-modal">',
        '<div class="modal-content timepicker-container">',
        '<div class="timepicker-digital-display">',
        '<div class="timepicker-text-container">',
        '<div class="timepicker-display-column">',
        '<span class="timepicker-span-hours text-primary"></span>',
        ':',
        '<span class="timepicker-span-minutes"></span>',
        '</div>',
        '<div class="timepicker-display-column timepicker-display-am-pm">',
        '<div class="timepicker-span-am-pm"></div>',
        '</div>',
        '</div>',
        '</div>',
        '<div class="timepicker-analog-display">',
        '<div class="timepicker-plate">',
        '<div class="timepicker-canvas"></div>',
        '<div class="timepicker-dial timepicker-hours"></div>',
        '<div class="timepicker-dial timepicker-minutes timepicker-dial-out"></div>',
        '</div>',
        '<div class="timepicker-footer"></div>',
        '</div>',
        '</div>',
        '</div>'
    ].join('');
    M.Timepicker = Timepicker1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Timepicker1, 'timepicker', 'M_Timepicker');
})(cash);
(function($) {
    var _defaults = {
    };
    /**
   * @class
   *
   */ var CharacterCounter1 = function(_Component17) {
        _inherits(CharacterCounter, _Component17);
        /**
     * Construct CharacterCounter instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function CharacterCounter(el, options) {
            _classCallCheck(this, CharacterCounter);
            var _this61 = _possibleConstructorReturn(this, (CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter)).call(this, CharacterCounter, el, options));
            _this61.el.M_CharacterCounter = _this61;
            /**
       * Options for the character counter
       */ _this61.options = $.extend({
            }, CharacterCounter.defaults, options);
            _this61.isInvalid = false;
            _this61.isValidLength = false;
            _this61._setupCounter();
            _this61._setupEventHandlers();
            return _this61;
        }
        _createClass(CharacterCounter, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.el.CharacterCounter = undefined;
                    this._removeCounter();
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleUpdateCounterBound = this.updateCounter.bind(this);
                    this.el.addEventListener('focus', this._handleUpdateCounterBound, true);
                    this.el.addEventListener('input', this._handleUpdateCounterBound, true);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('focus', this._handleUpdateCounterBound, true);
                    this.el.removeEventListener('input', this._handleUpdateCounterBound, true);
                }
            },
            {
                key: "_setupCounter",
                value: function _setupCounter() {
                    this.counterEl = document.createElement('span');
                    $(this.counterEl).addClass('character-counter').css({
                        float: 'right',
                        'font-size': '12px',
                        height: 1
                    });
                    this.$el.parent().append(this.counterEl);
                }
            },
            {
                key: "_removeCounter",
                value: function _removeCounter() {
                    $(this.counterEl).remove();
                }
            },
            {
                key: "updateCounter",
                value: function updateCounter() {
                    var maxLength = +this.$el.attr('data-length'), actualLength = this.el.value.length;
                    this.isValidLength = actualLength <= maxLength;
                    var counterString = actualLength;
                    if (maxLength) {
                        counterString += '/' + maxLength;
                        this._validateInput();
                    }
                    $(this.counterEl).html(counterString);
                }
            },
            {
                key: "_validateInput",
                value: function _validateInput() {
                    if (this.isValidLength && this.isInvalid) {
                        this.isInvalid = false;
                        this.$el.removeClass('invalid');
                    } else if (!this.isValidLength && !this.isInvalid) {
                        this.isInvalid = true;
                        this.$el.removeClass('valid');
                        this.$el.addClass('invalid');
                    }
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_CharacterCounter;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return CharacterCounter;
    }(Component);
    M.CharacterCounter = CharacterCounter1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(CharacterCounter1, 'characterCounter', 'M_CharacterCounter');
})(cash);
(function($) {
    var _defaults = {
        duration: 200,
        dist: -100,
        shift: 0,
        padding: 0,
        numVisible: 5,
        fullWidth: false,
        indicators: false,
        noWrap: false,
        onCycleTo: null // Callback for when a new slide is cycled to.
    };
    /**
   * @class
   *
   */ var Carousel1 = function(_Component18) {
        _inherits(Carousel, _Component18);
        /**
     * Construct Carousel instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Carousel(el3, options) {
            _classCallCheck(this, Carousel);
            var _this62 = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, Carousel, el3, options));
            _this62.el.M_Carousel = _this62;
            /**
       * Options for the carousel
       * @member Carousel#options
       * @prop {Number} duration
       * @prop {Number} dist
       * @prop {Number} shift
       * @prop {Number} padding
       * @prop {Number} numVisible
       * @prop {Boolean} fullWidth
       * @prop {Boolean} indicators
       * @prop {Boolean} noWrap
       * @prop {Function} onCycleTo
       */ _this62.options = $.extend({
            }, Carousel.defaults, options);
            // Setup
            _this62.hasMultipleSlides = _this62.$el.find('.carousel-item').length > 1;
            _this62.showIndicators = _this62.options.indicators && _this62.hasMultipleSlides;
            _this62.noWrap = _this62.options.noWrap || !_this62.hasMultipleSlides;
            _this62.pressed = false;
            _this62.dragged = false;
            _this62.offset = _this62.target = 0;
            _this62.images = [];
            _this62.itemWidth = _this62.$el.find('.carousel-item').first().innerWidth();
            _this62.itemHeight = _this62.$el.find('.carousel-item').first().innerHeight();
            _this62.dim = _this62.itemWidth * 2 + _this62.options.padding || 1; // Make sure dim is non zero for divisions.
            _this62._autoScrollBound = _this62._autoScroll.bind(_this62);
            _this62._trackBound = _this62._track.bind(_this62);
            // Full Width carousel setup
            if (_this62.options.fullWidth) {
                _this62.options.dist = 0;
                _this62._setCarouselHeight();
                // Offset fixed items when indicators.
                if (_this62.showIndicators) _this62.$el.find('.carousel-fixed-item').addClass('with-indicators');
            }
            // Iterate through slides
            _this62.$indicators = $('<ul class="indicators"></ul>');
            _this62.$el.find('.carousel-item').each(function(el, i) {
                _this62.images.push(el);
                if (_this62.showIndicators) {
                    var $indicator = $('<li class="indicator-item"></li>');
                    // Add active to first by default.
                    if (i === 0) $indicator[0].classList.add('active');
                    _this62.$indicators.append($indicator);
                }
            });
            if (_this62.showIndicators) _this62.$el.append(_this62.$indicators);
            _this62.count = _this62.images.length;
            // Cap numVisible at count
            _this62.options.numVisible = Math.min(_this62.count, _this62.options.numVisible);
            // Setup cross browser string
            _this62.xform = 'transform';
            [
                'webkit',
                'Moz',
                'O',
                'ms'
            ].every(function(prefix) {
                var e = prefix + 'Transform';
                if (typeof document.body.style[e] !== 'undefined') {
                    _this62.xform = e;
                    return false;
                }
                return true;
            });
            _this62._setupEventHandlers();
            _this62._scroll(_this62.offset);
            return _this62;
        }
        _createClass(Carousel, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.el.M_Carousel = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    var _this63 = this;
                    this._handleCarouselTapBound = this._handleCarouselTap.bind(this);
                    this._handleCarouselDragBound = this._handleCarouselDrag.bind(this);
                    this._handleCarouselReleaseBound = this._handleCarouselRelease.bind(this);
                    this._handleCarouselClickBound = this._handleCarouselClick.bind(this);
                    if (typeof window.ontouchstart !== 'undefined') {
                        this.el.addEventListener('touchstart', this._handleCarouselTapBound);
                        this.el.addEventListener('touchmove', this._handleCarouselDragBound);
                        this.el.addEventListener('touchend', this._handleCarouselReleaseBound);
                    }
                    this.el.addEventListener('mousedown', this._handleCarouselTapBound);
                    this.el.addEventListener('mousemove', this._handleCarouselDragBound);
                    this.el.addEventListener('mouseup', this._handleCarouselReleaseBound);
                    this.el.addEventListener('mouseleave', this._handleCarouselReleaseBound);
                    this.el.addEventListener('click', this._handleCarouselClickBound);
                    if (this.showIndicators && this.$indicators) {
                        this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);
                        this.$indicators.find('.indicator-item').each(function(el, i) {
                            el.addEventListener('click', _this63._handleIndicatorClickBound);
                        });
                    }
                    // Resize
                    var throttledResize = M.throttle(this._handleResize, 200);
                    this._handleThrottledResizeBound = throttledResize.bind(this);
                    window.addEventListener('resize', this._handleThrottledResizeBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    var _this64 = this;
                    if (typeof window.ontouchstart !== 'undefined') {
                        this.el.removeEventListener('touchstart', this._handleCarouselTapBound);
                        this.el.removeEventListener('touchmove', this._handleCarouselDragBound);
                        this.el.removeEventListener('touchend', this._handleCarouselReleaseBound);
                    }
                    this.el.removeEventListener('mousedown', this._handleCarouselTapBound);
                    this.el.removeEventListener('mousemove', this._handleCarouselDragBound);
                    this.el.removeEventListener('mouseup', this._handleCarouselReleaseBound);
                    this.el.removeEventListener('mouseleave', this._handleCarouselReleaseBound);
                    this.el.removeEventListener('click', this._handleCarouselClickBound);
                    if (this.showIndicators && this.$indicators) this.$indicators.find('.indicator-item').each(function(el, i) {
                        el.removeEventListener('click', _this64._handleIndicatorClickBound);
                    });
                    window.removeEventListener('resize', this._handleThrottledResizeBound);
                }
            },
            {
                key: "_handleCarouselTap",
                value: function _handleCarouselTap(e) {
                    // Fixes firefox draggable image bug
                    if (e.type === 'mousedown' && $(e.target).is('img')) e.preventDefault();
                    this.pressed = true;
                    this.dragged = false;
                    this.verticalDragged = false;
                    this.reference = this._xpos(e);
                    this.referenceY = this._ypos(e);
                    this.velocity = this.amplitude = 0;
                    this.frame = this.offset;
                    this.timestamp = Date.now();
                    clearInterval(this.ticker);
                    this.ticker = setInterval(this._trackBound, 100);
                }
            },
            {
                key: "_handleCarouselDrag",
                value: function _handleCarouselDrag(e) {
                    var x = void 0, y = void 0, delta = void 0, deltaY = void 0;
                    if (this.pressed) {
                        x = this._xpos(e);
                        y = this._ypos(e);
                        delta = this.reference - x;
                        deltaY = Math.abs(this.referenceY - y);
                        if (deltaY < 30 && !this.verticalDragged) // If vertical scrolling don't allow dragging.
                        {
                            if (delta > 2 || delta < -2) {
                                this.dragged = true;
                                this.reference = x;
                                this._scroll(this.offset + delta);
                            }
                        } else if (this.dragged) {
                            // If dragging don't allow vertical scroll.
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        } else // Vertical scrolling.
                        this.verticalDragged = true;
                    }
                    if (this.dragged) {
                        // If dragging don't allow vertical scroll.
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                }
            },
            {
                key: "_handleCarouselRelease",
                value: function _handleCarouselRelease(e) {
                    if (this.pressed) this.pressed = false;
                    else return;
                    clearInterval(this.ticker);
                    this.target = this.offset;
                    if (this.velocity > 10 || this.velocity < -10) {
                        this.amplitude = 0.9 * this.velocity;
                        this.target = this.offset + this.amplitude;
                    }
                    this.target = Math.round(this.target / this.dim) * this.dim;
                    // No wrap of items.
                    if (this.noWrap) {
                        if (this.target >= this.dim * (this.count - 1)) this.target = this.dim * (this.count - 1);
                        else if (this.target < 0) this.target = 0;
                    }
                    this.amplitude = this.target - this.offset;
                    this.timestamp = Date.now();
                    requestAnimationFrame(this._autoScrollBound);
                    if (this.dragged) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    return false;
                }
            },
            {
                key: "_handleCarouselClick",
                value: function _handleCarouselClick(e) {
                    // Disable clicks if carousel was dragged.
                    if (this.dragged) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    } else if (!this.options.fullWidth) {
                        var clickedIndex = $(e.target).closest('.carousel-item').index();
                        var diff = this._wrap(this.center) - clickedIndex;
                        // Disable clicks if carousel was shifted by click
                        if (diff !== 0) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        this._cycleTo(clickedIndex);
                    }
                }
            },
            {
                key: "_handleIndicatorClick",
                value: function _handleIndicatorClick(e) {
                    e.stopPropagation();
                    var indicator = $(e.target).closest('.indicator-item');
                    if (indicator.length) this._cycleTo(indicator.index());
                }
            },
            {
                key: "_handleResize",
                value: function _handleResize(e) {
                    if (this.options.fullWidth) {
                        this.itemWidth = this.$el.find('.carousel-item').first().innerWidth();
                        this.imageHeight = this.$el.find('.carousel-item.active').height();
                        this.dim = this.itemWidth * 2 + this.options.padding;
                        this.offset = this.center * 2 * this.itemWidth;
                        this.target = this.offset;
                        this._setCarouselHeight(true);
                    } else this._scroll();
                }
            },
            {
                key: "_setCarouselHeight",
                value: function _setCarouselHeight(imageOnly) {
                    var _this65 = this;
                    var firstSlide = this.$el.find('.carousel-item.active').length ? this.$el.find('.carousel-item.active').first() : this.$el.find('.carousel-item').first();
                    var firstImage = firstSlide.find('img').first();
                    if (firstImage.length) {
                        if (firstImage[0].complete) {
                            // If image won't trigger the load event
                            var imageHeight = firstImage.height();
                            if (imageHeight > 0) this.$el.css('height', imageHeight + 'px');
                            else {
                                // If image still has no height, use the natural dimensions to calculate
                                var naturalWidth = firstImage[0].naturalWidth;
                                var naturalHeight = firstImage[0].naturalHeight;
                                var adjustedHeight = this.$el.width() / naturalWidth * naturalHeight;
                                this.$el.css('height', adjustedHeight + 'px');
                            }
                        } else // Get height when image is loaded normally
                        firstImage.one('load', function(el, i) {
                            _this65.$el.css('height', el.offsetHeight + 'px');
                        });
                    } else if (!imageOnly) {
                        var slideHeight = firstSlide.height();
                        this.$el.css('height', slideHeight + 'px');
                    }
                }
            },
            {
                key: "_xpos",
                value: function _xpos(e) {
                    // touch event
                    if (e.targetTouches && e.targetTouches.length >= 1) return e.targetTouches[0].clientX;
                    // mouse event
                    return e.clientX;
                }
            },
            {
                key: "_ypos",
                value: function _ypos(e) {
                    // touch event
                    if (e.targetTouches && e.targetTouches.length >= 1) return e.targetTouches[0].clientY;
                    // mouse event
                    return e.clientY;
                }
            },
            {
                key: "_wrap",
                value: function _wrap(x) {
                    return x >= this.count ? x % this.count : x < 0 ? this._wrap(this.count + x % this.count) : x;
                }
            },
            {
                key: "_track",
                value: function _track() {
                    var now = void 0, elapsed = void 0, delta = void 0, v = void 0;
                    now = Date.now();
                    elapsed = now - this.timestamp;
                    this.timestamp = now;
                    delta = this.offset - this.frame;
                    this.frame = this.offset;
                    v = 1000 * delta / (1 + elapsed);
                    this.velocity = 0.8 * v + 0.2 * this.velocity;
                }
            },
            {
                key: "_autoScroll",
                value: function _autoScroll() {
                    var elapsed = void 0, delta = void 0;
                    if (this.amplitude) {
                        elapsed = Date.now() - this.timestamp;
                        delta = this.amplitude * Math.exp(-elapsed / this.options.duration);
                        if (delta > 2 || delta < -2) {
                            this._scroll(this.target - delta);
                            requestAnimationFrame(this._autoScrollBound);
                        } else this._scroll(this.target);
                    }
                }
            },
            {
                key: "_scroll",
                value: function _scroll(x) {
                    var _this66 = this;
                    // Track scrolling state
                    if (!this.$el.hasClass('scrolling')) this.el.classList.add('scrolling');
                    if (this.scrollingTimeout != null) window.clearTimeout(this.scrollingTimeout);
                    this.scrollingTimeout = window.setTimeout(function() {
                        _this66.$el.removeClass('scrolling');
                    }, this.options.duration);
                    // Start actual scroll
                    var i = void 0, half = void 0, delta = void 0, dir = void 0, tween = void 0, el = void 0, alignment = void 0, zTranslation = void 0, tweenedOpacity = void 0, centerTweenedOpacity = void 0;
                    var lastCenter = this.center;
                    var numVisibleOffset = 1 / this.options.numVisible;
                    this.offset = typeof x === 'number' ? x : this.offset;
                    this.center = Math.floor((this.offset + this.dim / 2) / this.dim);
                    delta = this.offset - this.center * this.dim;
                    dir = delta < 0 ? 1 : -1;
                    tween = -dir * delta * 2 / this.dim;
                    half = this.count >> 1;
                    if (this.options.fullWidth) {
                        alignment = 'translateX(0)';
                        centerTweenedOpacity = 1;
                    } else {
                        alignment = 'translateX(' + (this.el.clientWidth - this.itemWidth) / 2 + 'px) ';
                        alignment += 'translateY(' + (this.el.clientHeight - this.itemHeight) / 2 + 'px)';
                        centerTweenedOpacity = 1 - numVisibleOffset * tween;
                    }
                    // Set indicator active
                    if (this.showIndicators) {
                        var diff = this.center % this.count;
                        var activeIndicator = this.$indicators.find('.indicator-item.active');
                        if (activeIndicator.index() !== diff) {
                            activeIndicator.removeClass('active');
                            this.$indicators.find('.indicator-item').eq(diff)[0].classList.add('active');
                        }
                    }
                    // center
                    // Don't show wrapped items.
                    if (!this.noWrap || this.center >= 0 && this.center < this.count) {
                        el = this.images[this._wrap(this.center)];
                        // Add active class to center item.
                        if (!$(el).hasClass('active')) {
                            this.$el.find('.carousel-item').removeClass('active');
                            el.classList.add('active');
                        }
                        var transformString = alignment + " translateX(" + -delta / 2 + "px) translateX(" + dir * this.options.shift * tween * i + "px) translateZ(" + this.options.dist * tween + "px)";
                        this._updateItemStyle(el, centerTweenedOpacity, 0, transformString);
                    }
                    for(i = 1; i <= half; ++i){
                        // right side
                        if (this.options.fullWidth) {
                            zTranslation = this.options.dist;
                            tweenedOpacity = i === half && delta < 0 ? 1 - tween : 1;
                        } else {
                            zTranslation = this.options.dist * (i * 2 + tween * dir);
                            tweenedOpacity = 1 - numVisibleOffset * (i * 2 + tween * dir);
                        }
                        // Don't show wrapped items.
                        if (!this.noWrap || this.center + i < this.count) {
                            el = this.images[this._wrap(this.center + i)];
                            var _transformString = alignment + " translateX(" + (this.options.shift + (this.dim * i - delta) / 2) + "px) translateZ(" + zTranslation + "px)";
                            this._updateItemStyle(el, tweenedOpacity, -i, _transformString);
                        }
                        // left side
                        if (this.options.fullWidth) {
                            zTranslation = this.options.dist;
                            tweenedOpacity = i === half && delta > 0 ? 1 - tween : 1;
                        } else {
                            zTranslation = this.options.dist * (i * 2 - tween * dir);
                            tweenedOpacity = 1 - numVisibleOffset * (i * 2 - tween * dir);
                        }
                        // Don't show wrapped items.
                        if (!this.noWrap || this.center - i >= 0) {
                            el = this.images[this._wrap(this.center - i)];
                            var _transformString2 = alignment + " translateX(" + (-this.options.shift + (-this.dim * i - delta) / 2) + "px) translateZ(" + zTranslation + "px)";
                            this._updateItemStyle(el, tweenedOpacity, -i, _transformString2);
                        }
                    }
                    // center
                    // Don't show wrapped items.
                    if (!this.noWrap || this.center >= 0 && this.center < this.count) {
                        el = this.images[this._wrap(this.center)];
                        var _transformString3 = alignment + " translateX(" + -delta / 2 + "px) translateX(" + dir * this.options.shift * tween + "px) translateZ(" + this.options.dist * tween + "px)";
                        this._updateItemStyle(el, centerTweenedOpacity, 0, _transformString3);
                    }
                    // onCycleTo callback
                    var $currItem = this.$el.find('.carousel-item').eq(this._wrap(this.center));
                    if (lastCenter !== this.center && typeof this.options.onCycleTo === 'function') this.options.onCycleTo.call(this, $currItem[0], this.dragged);
                    // One time callback
                    if (typeof this.oneTimeCallback === 'function') {
                        this.oneTimeCallback.call(this, $currItem[0], this.dragged);
                        this.oneTimeCallback = null;
                    }
                }
            },
            {
                key: "_updateItemStyle",
                value: function _updateItemStyle(el, opacity, zIndex, transform) {
                    el.style[this.xform] = transform;
                    el.style.zIndex = zIndex;
                    el.style.opacity = opacity;
                    el.style.visibility = 'visible';
                }
            },
            {
                key: "_cycleTo",
                value: function _cycleTo(n, callback) {
                    var diff = this.center % this.count - n;
                    // Account for wraparound.
                    if (!this.noWrap) {
                        if (diff < 0) {
                            if (Math.abs(diff + this.count) < Math.abs(diff)) diff += this.count;
                        } else if (diff > 0) {
                            if (Math.abs(diff - this.count) < diff) diff -= this.count;
                        }
                    }
                    this.target = this.dim * Math.round(this.offset / this.dim);
                    // Next
                    if (diff < 0) this.target += this.dim * Math.abs(diff);
                    else if (diff > 0) this.target -= this.dim * diff;
                    // Set one time callback
                    if (typeof callback === 'function') this.oneTimeCallback = callback;
                    // Scroll
                    if (this.offset !== this.target) {
                        this.amplitude = this.target - this.offset;
                        this.timestamp = Date.now();
                        requestAnimationFrame(this._autoScrollBound);
                    }
                }
            },
            {
                key: "next",
                value: function next(n) {
                    if (n === undefined || isNaN(n)) n = 1;
                    var index = this.center + n;
                    if (index >= this.count || index < 0) {
                        if (this.noWrap) return;
                        index = this._wrap(index);
                    }
                    this._cycleTo(index);
                }
            },
            {
                key: "prev",
                value: function prev(n) {
                    if (n === undefined || isNaN(n)) n = 1;
                    var index = this.center - n;
                    if (index >= this.count || index < 0) {
                        if (this.noWrap) return;
                        index = this._wrap(index);
                    }
                    this._cycleTo(index);
                }
            },
            {
                key: "set",
                value: function set(n, callback) {
                    if (n === undefined || isNaN(n)) n = 0;
                    if (n > this.count || n < 0) {
                        if (this.noWrap) return;
                        n = this._wrap(n);
                    }
                    this._cycleTo(n, callback);
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Carousel.__proto__ || Object.getPrototypeOf(Carousel), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Carousel;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Carousel;
    }(Component);
    M.Carousel = Carousel1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Carousel1, 'carousel', 'M_Carousel');
})(cash);
(function($) {
    var _defaults = {
        onOpen: undefined,
        onClose: undefined
    };
    /**
   * @class
   *
   */ var TapTarget1 = function(_Component19) {
        _inherits(TapTarget, _Component19);
        /**
     * Construct TapTarget instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function TapTarget(el, options) {
            _classCallCheck(this, TapTarget);
            var _this67 = _possibleConstructorReturn(this, (TapTarget.__proto__ || Object.getPrototypeOf(TapTarget)).call(this, TapTarget, el, options));
            _this67.el.M_TapTarget = _this67;
            /**
       * Options for the select
       * @member TapTarget#options
       * @prop {Function} onOpen - Callback function called when feature discovery is opened
       * @prop {Function} onClose - Callback function called when feature discovery is closed
       */ _this67.options = $.extend({
            }, TapTarget.defaults, options);
            _this67.isOpen = false;
            // setup
            _this67.$origin = $('#' + _this67.$el.attr('data-target'));
            _this67._setup();
            _this67._calculatePositioning();
            _this67._setupEventHandlers();
            return _this67;
        }
        _createClass(TapTarget, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this.el.TapTarget = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleDocumentClickBound = this._handleDocumentClick.bind(this);
                    this._handleTargetClickBound = this._handleTargetClick.bind(this);
                    this._handleOriginClickBound = this._handleOriginClick.bind(this);
                    this.el.addEventListener('click', this._handleTargetClickBound);
                    this.originEl.addEventListener('click', this._handleOriginClickBound);
                    // Resize
                    var throttledResize = M.throttle(this._handleResize, 200);
                    this._handleThrottledResizeBound = throttledResize.bind(this);
                    window.addEventListener('resize', this._handleThrottledResizeBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('click', this._handleTargetClickBound);
                    this.originEl.removeEventListener('click', this._handleOriginClickBound);
                    window.removeEventListener('resize', this._handleThrottledResizeBound);
                }
            },
            {
                key: "_handleTargetClick",
                value: function _handleTargetClick(e) {
                    this.open();
                }
            },
            {
                key: "_handleOriginClick",
                value: function _handleOriginClick(e) {
                    this.close();
                }
            },
            {
                key: "_handleResize",
                value: function _handleResize(e) {
                    this._calculatePositioning();
                }
            },
            {
                key: "_handleDocumentClick",
                value: function _handleDocumentClick(e) {
                    if (!$(e.target).closest('.tap-target-wrapper').length) {
                        this.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            },
            {
                key: "_setup",
                value: function _setup() {
                    // Creating tap target
                    this.wrapper = this.$el.parent()[0];
                    this.waveEl = $(this.wrapper).find('.tap-target-wave')[0];
                    this.originEl = $(this.wrapper).find('.tap-target-origin')[0];
                    this.contentEl = this.$el.find('.tap-target-content')[0];
                    // Creating wrapper
                    if (!$(this.wrapper).hasClass('.tap-target-wrapper')) {
                        this.wrapper = document.createElement('div');
                        this.wrapper.classList.add('tap-target-wrapper');
                        this.$el.before($(this.wrapper));
                        this.wrapper.append(this.el);
                    }
                    // Creating content
                    if (!this.contentEl) {
                        this.contentEl = document.createElement('div');
                        this.contentEl.classList.add('tap-target-content');
                        this.$el.append(this.contentEl);
                    }
                    // Creating foreground wave
                    if (!this.waveEl) {
                        this.waveEl = document.createElement('div');
                        this.waveEl.classList.add('tap-target-wave');
                        // Creating origin
                        if (!this.originEl) {
                            this.originEl = this.$origin.clone(true, true);
                            this.originEl.addClass('tap-target-origin');
                            this.originEl.removeAttr('id');
                            this.originEl.removeAttr('style');
                            this.originEl = this.originEl[0];
                            this.waveEl.append(this.originEl);
                        }
                        this.wrapper.append(this.waveEl);
                    }
                }
            },
            {
                key: "_calculatePositioning",
                value: function _calculatePositioning() {
                    // Element or parent is fixed position?
                    var isFixed = this.$origin.css('position') === 'fixed';
                    if (!isFixed) {
                        var parents = this.$origin.parents();
                        for(var i = 0; i < parents.length; i++){
                            isFixed = $(parents[i]).css('position') == 'fixed';
                            if (isFixed) break;
                        }
                    }
                    // Calculating origin
                    var originWidth = this.$origin.outerWidth();
                    var originHeight = this.$origin.outerHeight();
                    var originTop = isFixed ? this.$origin.offset().top - M.getDocumentScrollTop() : this.$origin.offset().top;
                    var originLeft = isFixed ? this.$origin.offset().left - M.getDocumentScrollLeft() : this.$origin.offset().left;
                    // Calculating screen
                    var windowWidth = window.innerWidth;
                    var windowHeight = window.innerHeight;
                    var centerX = windowWidth / 2;
                    var centerY = windowHeight / 2;
                    var isLeft = originLeft <= centerX;
                    var isRight = originLeft > centerX;
                    var isTop = originTop <= centerY;
                    var isBottom = originTop > centerY;
                    var isCenterX = originLeft >= windowWidth * 0.25 && originLeft <= windowWidth * 0.75;
                    // Calculating tap target
                    var tapTargetWidth = this.$el.outerWidth();
                    var tapTargetHeight = this.$el.outerHeight();
                    var tapTargetTop = originTop + originHeight / 2 - tapTargetHeight / 2;
                    var tapTargetLeft = originLeft + originWidth / 2 - tapTargetWidth / 2;
                    var tapTargetPosition = isFixed ? 'fixed' : 'absolute';
                    // Calculating content
                    var tapTargetTextWidth = isCenterX ? tapTargetWidth : tapTargetWidth / 2 + originWidth;
                    var tapTargetTextHeight = tapTargetHeight / 2;
                    var tapTargetTextTop = isTop ? tapTargetHeight / 2 : 0;
                    var tapTargetTextBottom = 0;
                    var tapTargetTextLeft = isLeft && !isCenterX ? tapTargetWidth / 2 - originWidth : 0;
                    var tapTargetTextRight = 0;
                    var tapTargetTextPadding = originWidth;
                    var tapTargetTextAlign = isBottom ? 'bottom' : 'top';
                    // Calculating wave
                    var tapTargetWaveWidth = originWidth > originHeight ? originWidth * 2 : originWidth * 2;
                    var tapTargetWaveHeight = tapTargetWaveWidth;
                    var tapTargetWaveTop = tapTargetHeight / 2 - tapTargetWaveHeight / 2;
                    var tapTargetWaveLeft = tapTargetWidth / 2 - tapTargetWaveWidth / 2;
                    // Setting tap target
                    var tapTargetWrapperCssObj = {
                    };
                    tapTargetWrapperCssObj.top = isTop ? tapTargetTop + 'px' : '';
                    tapTargetWrapperCssObj.right = isRight ? windowWidth - tapTargetLeft - tapTargetWidth + 'px' : '';
                    tapTargetWrapperCssObj.bottom = isBottom ? windowHeight - tapTargetTop - tapTargetHeight + 'px' : '';
                    tapTargetWrapperCssObj.left = isLeft ? tapTargetLeft + 'px' : '';
                    tapTargetWrapperCssObj.position = tapTargetPosition;
                    $(this.wrapper).css(tapTargetWrapperCssObj);
                    // Setting content
                    $(this.contentEl).css({
                        width: tapTargetTextWidth + 'px',
                        height: tapTargetTextHeight + 'px',
                        top: tapTargetTextTop + 'px',
                        right: tapTargetTextRight + 'px',
                        bottom: tapTargetTextBottom + 'px',
                        left: tapTargetTextLeft + 'px',
                        padding: tapTargetTextPadding + 'px',
                        verticalAlign: tapTargetTextAlign
                    });
                    // Setting wave
                    $(this.waveEl).css({
                        top: tapTargetWaveTop + 'px',
                        left: tapTargetWaveLeft + 'px',
                        width: tapTargetWaveWidth + 'px',
                        height: tapTargetWaveHeight + 'px'
                    });
                }
            },
            {
                key: "open",
                value: function open() {
                    if (this.isOpen) return;
                    // onOpen callback
                    if (typeof this.options.onOpen === 'function') this.options.onOpen.call(this, this.$origin[0]);
                    this.isOpen = true;
                    this.wrapper.classList.add('open');
                    document.body.addEventListener('click', this._handleDocumentClickBound, true);
                    document.body.addEventListener('touchend', this._handleDocumentClickBound);
                }
            },
            {
                key: "close",
                value: function close() {
                    if (!this.isOpen) return;
                    // onClose callback
                    if (typeof this.options.onClose === 'function') this.options.onClose.call(this, this.$origin[0]);
                    this.isOpen = false;
                    this.wrapper.classList.remove('open');
                    document.body.removeEventListener('click', this._handleDocumentClickBound, true);
                    document.body.removeEventListener('touchend', this._handleDocumentClickBound);
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(TapTarget.__proto__ || Object.getPrototypeOf(TapTarget), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_TapTarget;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return TapTarget;
    }(Component);
    M.TapTarget = TapTarget1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(TapTarget1, 'tapTarget', 'M_TapTarget');
})(cash);
(function($) {
    var _defaults = {
        classes: '',
        dropdownOptions: {
        }
    };
    /**
   * @class
   *
   */ var FormSelect1 = function(_Component20) {
        _inherits(FormSelect, _Component20);
        /**
     * Construct FormSelect instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function FormSelect(el, options) {
            _classCallCheck(this, FormSelect);
            // Don't init if browser default version
            var _this68 = _possibleConstructorReturn(this, (FormSelect.__proto__ || Object.getPrototypeOf(FormSelect)).call(this, FormSelect, el, options));
            if (_this68.$el.hasClass('browser-default')) return _possibleConstructorReturn(_this68);
            _this68.el.M_FormSelect = _this68;
            /**
       * Options for the select
       * @member FormSelect#options
       */ _this68.options = $.extend({
            }, FormSelect.defaults, options);
            _this68.isMultiple = _this68.$el.prop('multiple');
            // Setup
            _this68.el.tabIndex = -1;
            _this68._keysSelected = {
            };
            _this68._valueDict = {
            }; // Maps key to original and generated option element.
            _this68._setupDropdown();
            _this68._setupEventHandlers();
            return _this68;
        }
        _createClass(FormSelect, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this._removeDropdown();
                    this.el.M_FormSelect = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    var _this69 = this;
                    this._handleSelectChangeBound = this._handleSelectChange.bind(this);
                    this._handleOptionClickBound = this._handleOptionClick.bind(this);
                    this._handleInputClickBound = this._handleInputClick.bind(this);
                    $(this.dropdownOptions).find('li:not(.optgroup)').each(function(el) {
                        el.addEventListener('click', _this69._handleOptionClickBound);
                    });
                    this.el.addEventListener('change', this._handleSelectChangeBound);
                    this.input.addEventListener('click', this._handleInputClickBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    var _this70 = this;
                    $(this.dropdownOptions).find('li:not(.optgroup)').each(function(el) {
                        el.removeEventListener('click', _this70._handleOptionClickBound);
                    });
                    this.el.removeEventListener('change', this._handleSelectChangeBound);
                    this.input.removeEventListener('click', this._handleInputClickBound);
                }
            },
            {
                key: "_handleSelectChange",
                value: function _handleSelectChange(e) {
                    this._setValueToInput();
                }
            },
            {
                key: "_handleOptionClick",
                value: function _handleOptionClick(e) {
                    e.preventDefault();
                    var option = $(e.target).closest('li')[0];
                    var key = option.id;
                    if (!$(option).hasClass('disabled') && !$(option).hasClass('optgroup') && key.length) {
                        var selected = true;
                        if (this.isMultiple) {
                            // Deselect placeholder option if still selected.
                            var placeholderOption = $(this.dropdownOptions).find('li.disabled.selected');
                            if (placeholderOption.length) {
                                placeholderOption.removeClass('selected');
                                placeholderOption.find('input[type="checkbox"]').prop('checked', false);
                                this._toggleEntryFromArray(placeholderOption[0].id);
                            }
                            selected = this._toggleEntryFromArray(key);
                        } else {
                            $(this.dropdownOptions).find('li').removeClass('selected');
                            $(option).toggleClass('selected', selected);
                        }
                        // Set selected on original select option
                        // Only trigger if selected state changed
                        var prevSelected = $(this._valueDict[key].el).prop('selected');
                        if (prevSelected !== selected) {
                            $(this._valueDict[key].el).prop('selected', selected);
                            this.$el.trigger('change');
                        }
                    }
                    e.stopPropagation();
                }
            },
            {
                key: "_handleInputClick",
                value: function _handleInputClick() {
                    if (this.dropdown && this.dropdown.isOpen) {
                        this._setValueToInput();
                        this._setSelectedStates();
                    }
                }
            },
            {
                key: "_setupDropdown",
                value: function _setupDropdown() {
                    var _this71 = this;
                    this.wrapper = document.createElement('div');
                    $(this.wrapper).addClass('select-wrapper ' + this.options.classes);
                    this.$el.before($(this.wrapper));
                    this.wrapper.appendChild(this.el);
                    if (this.el.disabled) this.wrapper.classList.add('disabled');
                    // Create dropdown
                    this.$selectOptions = this.$el.children('option, optgroup');
                    this.dropdownOptions = document.createElement('ul');
                    this.dropdownOptions.id = "select-options-" + M.guid();
                    $(this.dropdownOptions).addClass('dropdown-content select-dropdown ' + (this.isMultiple ? 'multiple-select-dropdown' : ''));
                    // Create dropdown structure.
                    if (this.$selectOptions.length) this.$selectOptions.each(function(el4) {
                        if ($(el4).is('option')) {
                            // Direct descendant option.
                            var optionEl = void 0;
                            if (_this71.isMultiple) optionEl = _this71._appendOptionWithIcon(_this71.$el, el4, 'multiple');
                            else optionEl = _this71._appendOptionWithIcon(_this71.$el, el4);
                            _this71._addOptionToValueDict(el4, optionEl);
                        } else if ($(el4).is('optgroup')) {
                            // Optgroup.
                            var selectOptions = $(el4).children('option');
                            $(_this71.dropdownOptions).append($('<li class="optgroup"><span>' + el4.getAttribute('label') + '</span></li>')[0]);
                            selectOptions.each(function(el) {
                                var optionEl = _this71._appendOptionWithIcon(_this71.$el, el, 'optgroup-option');
                                _this71._addOptionToValueDict(el, optionEl);
                            });
                        }
                    });
                    this.$el.after(this.dropdownOptions);
                    // Add input dropdown
                    this.input = document.createElement('input');
                    $(this.input).addClass('select-dropdown dropdown-trigger');
                    this.input.setAttribute('type', 'text');
                    this.input.setAttribute('readonly', 'true');
                    this.input.setAttribute('data-target', this.dropdownOptions.id);
                    if (this.el.disabled) $(this.input).prop('disabled', 'true');
                    this.$el.before(this.input);
                    this._setValueToInput();
                    // Add caret
                    var dropdownIcon = $('<svg class="caret" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
                    this.$el.before(dropdownIcon[0]);
                    // Initialize dropdown
                    if (!this.el.disabled) {
                        var dropdownOptions = $.extend({
                        }, this.options.dropdownOptions);
                        // Add callback for centering selected option when dropdown content is scrollable
                        dropdownOptions.onOpenEnd = function(el) {
                            var selectedOption = $(_this71.dropdownOptions).find('.selected').first();
                            if (selectedOption.length) {
                                // Focus selected option in dropdown
                                M.keyDown = true;
                                _this71.dropdown.focusedIndex = selectedOption.index();
                                _this71.dropdown._focusFocusedItem();
                                M.keyDown = false;
                                // Handle scrolling to selected option
                                if (_this71.dropdown.isScrollable) {
                                    var scrollOffset = selectedOption[0].getBoundingClientRect().top - _this71.dropdownOptions.getBoundingClientRect().top; // scroll to selected option
                                    scrollOffset -= _this71.dropdownOptions.clientHeight / 2; // center in dropdown
                                    _this71.dropdownOptions.scrollTop = scrollOffset;
                                }
                            }
                        };
                        if (this.isMultiple) dropdownOptions.closeOnClick = false;
                        this.dropdown = M.Dropdown.init(this.input, dropdownOptions);
                    }
                    // Add initial selections
                    this._setSelectedStates();
                }
            },
            {
                key: "_addOptionToValueDict",
                value: function _addOptionToValueDict(el, optionEl) {
                    var index = Object.keys(this._valueDict).length;
                    var key = this.dropdownOptions.id + index;
                    var obj = {
                    };
                    optionEl.id = key;
                    obj.el = el;
                    obj.optionEl = optionEl;
                    this._valueDict[key] = obj;
                }
            },
            {
                key: "_removeDropdown",
                value: function _removeDropdown() {
                    $(this.wrapper).find('.caret').remove();
                    $(this.input).remove();
                    $(this.dropdownOptions).remove();
                    $(this.wrapper).before(this.$el);
                    $(this.wrapper).remove();
                }
            },
            {
                key: "_appendOptionWithIcon",
                value: function _appendOptionWithIcon(select, option, type) {
                    // Add disabled attr if disabled
                    var disabledClass = option.disabled ? 'disabled ' : '';
                    var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : '';
                    var multipleCheckbox = this.isMultiple ? "<label><input type=\"checkbox\"" + disabledClass + "\"/><span>" + option.innerHTML + "</span></label>" : option.innerHTML;
                    var liEl = $('<li></li>');
                    var spanEl = $('<span></span>');
                    spanEl.html(multipleCheckbox);
                    liEl.addClass(disabledClass + " " + optgroupClass);
                    liEl.append(spanEl);
                    // add icons
                    var iconUrl = option.getAttribute('data-icon');
                    if (!!iconUrl) {
                        var imgEl = $("<img alt=\"\" src=\"" + iconUrl + "\">");
                        liEl.prepend(imgEl);
                    }
                    // Check for multiple type.
                    $(this.dropdownOptions).append(liEl[0]);
                    return liEl[0];
                }
            },
            {
                key: "_toggleEntryFromArray",
                value: function _toggleEntryFromArray(key) {
                    var notAdded = !this._keysSelected.hasOwnProperty(key);
                    var $optionLi = $(this._valueDict[key].optionEl);
                    if (notAdded) this._keysSelected[key] = true;
                    else delete this._keysSelected[key];
                    $optionLi.toggleClass('selected', notAdded);
                    // Set checkbox checked value
                    $optionLi.find('input[type="checkbox"]').prop('checked', notAdded);
                    // use notAdded instead of true (to detect if the option is selected or not)
                    $optionLi.prop('selected', notAdded);
                    return notAdded;
                }
            },
            {
                key: "_setValueToInput",
                value: function _setValueToInput() {
                    var values = [];
                    var options = this.$el.find('option');
                    options.each(function(el) {
                        if ($(el).prop('selected')) {
                            var text = $(el).text();
                            values.push(text);
                        }
                    });
                    if (!values.length) {
                        var firstDisabled = this.$el.find('option:disabled').eq(0);
                        if (firstDisabled.length && firstDisabled[0].value === '') values.push(firstDisabled.text());
                    }
                    this.input.value = values.join(', ');
                }
            },
            {
                key: "_setSelectedStates",
                value: function _setSelectedStates() {
                    this._keysSelected = {
                    };
                    for(var key in this._valueDict){
                        var option = this._valueDict[key];
                        var optionIsSelected = $(option.el).prop('selected');
                        $(option.optionEl).find('input[type="checkbox"]').prop('checked', optionIsSelected);
                        if (optionIsSelected) {
                            this._activateOption($(this.dropdownOptions), $(option.optionEl));
                            this._keysSelected[key] = true;
                        } else $(option.optionEl).removeClass('selected');
                    }
                }
            },
            {
                key: "_activateOption",
                value: function _activateOption(collection, newOption) {
                    if (newOption) {
                        if (!this.isMultiple) collection.find('li.selected').removeClass('selected');
                        var option = $(newOption);
                        option.addClass('selected');
                    }
                }
            },
            {
                key: "getSelectedValues",
                value: function getSelectedValues() {
                    var selectedValues = [];
                    for(var key in this._keysSelected)selectedValues.push(this._valueDict[key].el.value);
                    return selectedValues;
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(FormSelect.__proto__ || Object.getPrototypeOf(FormSelect), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_FormSelect;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return FormSelect;
    }(Component);
    M.FormSelect = FormSelect1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(FormSelect1, 'formSelect', 'M_FormSelect');
})(cash);
(function($, anim) {
    var _defaults = {
    };
    /**
   * @class
   *
   */ var Range1 = function(_Component21) {
        _inherits(Range, _Component21);
        /**
     * Construct Range instance
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */ function Range(el, options) {
            _classCallCheck(this, Range);
            var _this72 = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, Range, el, options));
            _this72.el.M_Range = _this72;
            /**
       * Options for the range
       * @member Range#options
       */ _this72.options = $.extend({
            }, Range.defaults, options);
            _this72._mousedown = false;
            // Setup
            _this72._setupThumb();
            _this72._setupEventHandlers();
            return _this72;
        }
        _createClass(Range, [
            {
                key: "destroy",
                /**
       * Teardown component
       */ value: function destroy() {
                    this._removeEventHandlers();
                    this._removeThumb();
                    this.el.M_Range = undefined;
                }
            },
            {
                key: "_setupEventHandlers",
                value: function _setupEventHandlers() {
                    this._handleRangeChangeBound = this._handleRangeChange.bind(this);
                    this._handleRangeMousedownTouchstartBound = this._handleRangeMousedownTouchstart.bind(this);
                    this._handleRangeInputMousemoveTouchmoveBound = this._handleRangeInputMousemoveTouchmove.bind(this);
                    this._handleRangeMouseupTouchendBound = this._handleRangeMouseupTouchend.bind(this);
                    this._handleRangeBlurMouseoutTouchleaveBound = this._handleRangeBlurMouseoutTouchleave.bind(this);
                    this.el.addEventListener('change', this._handleRangeChangeBound);
                    this.el.addEventListener('mousedown', this._handleRangeMousedownTouchstartBound);
                    this.el.addEventListener('touchstart', this._handleRangeMousedownTouchstartBound);
                    this.el.addEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);
                    this.el.addEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);
                    this.el.addEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);
                    this.el.addEventListener('mouseup', this._handleRangeMouseupTouchendBound);
                    this.el.addEventListener('touchend', this._handleRangeMouseupTouchendBound);
                    this.el.addEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);
                    this.el.addEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);
                    this.el.addEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);
                }
            },
            {
                key: "_removeEventHandlers",
                value: function _removeEventHandlers() {
                    this.el.removeEventListener('change', this._handleRangeChangeBound);
                    this.el.removeEventListener('mousedown', this._handleRangeMousedownTouchstartBound);
                    this.el.removeEventListener('touchstart', this._handleRangeMousedownTouchstartBound);
                    this.el.removeEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);
                    this.el.removeEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);
                    this.el.removeEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);
                    this.el.removeEventListener('mouseup', this._handleRangeMouseupTouchendBound);
                    this.el.removeEventListener('touchend', this._handleRangeMouseupTouchendBound);
                    this.el.removeEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);
                    this.el.removeEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);
                    this.el.removeEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);
                }
            },
            {
                key: "_handleRangeChange",
                value: function _handleRangeChange() {
                    $(this.value).html(this.$el.val());
                    if (!$(this.thumb).hasClass('active')) this._showRangeBubble();
                    var offsetLeft = this._calcRangeOffset();
                    $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
                }
            },
            {
                key: "_handleRangeMousedownTouchstart",
                value: function _handleRangeMousedownTouchstart(e) {
                    // Set indicator value
                    $(this.value).html(this.$el.val());
                    this._mousedown = true;
                    this.$el.addClass('active');
                    if (!$(this.thumb).hasClass('active')) this._showRangeBubble();
                    if (e.type !== 'input') {
                        var offsetLeft = this._calcRangeOffset();
                        $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
                    }
                }
            },
            {
                key: "_handleRangeInputMousemoveTouchmove",
                value: function _handleRangeInputMousemoveTouchmove() {
                    if (this._mousedown) {
                        if (!$(this.thumb).hasClass('active')) this._showRangeBubble();
                        var offsetLeft = this._calcRangeOffset();
                        $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
                        $(this.value).html(this.$el.val());
                    }
                }
            },
            {
                key: "_handleRangeMouseupTouchend",
                value: function _handleRangeMouseupTouchend() {
                    this._mousedown = false;
                    this.$el.removeClass('active');
                }
            },
            {
                key: "_handleRangeBlurMouseoutTouchleave",
                value: function _handleRangeBlurMouseoutTouchleave() {
                    if (!this._mousedown) {
                        var paddingLeft = parseInt(this.$el.css('padding-left'));
                        var marginLeft = 7 + paddingLeft + 'px';
                        if ($(this.thumb).hasClass('active')) {
                            anim.remove(this.thumb);
                            anim({
                                targets: this.thumb,
                                height: 0,
                                width: 0,
                                top: 10,
                                easing: 'easeOutQuad',
                                marginLeft: marginLeft,
                                duration: 100
                            });
                        }
                        $(this.thumb).removeClass('active');
                    }
                }
            },
            {
                key: "_setupThumb",
                value: function _setupThumb() {
                    this.thumb = document.createElement('span');
                    this.value = document.createElement('span');
                    $(this.thumb).addClass('thumb');
                    $(this.value).addClass('value');
                    $(this.thumb).append(this.value);
                    this.$el.after(this.thumb);
                }
            },
            {
                key: "_removeThumb",
                value: function _removeThumb() {
                    $(this.thumb).remove();
                }
            },
            {
                key: "_showRangeBubble",
                value: function _showRangeBubble() {
                    var paddingLeft = parseInt($(this.thumb).parent().css('padding-left'));
                    var marginLeft = -7 + paddingLeft + 'px'; // TODO: fix magic number?
                    anim.remove(this.thumb);
                    anim({
                        targets: this.thumb,
                        height: 30,
                        width: 30,
                        top: -30,
                        marginLeft: marginLeft,
                        duration: 300,
                        easing: 'easeOutQuint'
                    });
                }
            },
            {
                key: "_calcRangeOffset",
                value: function _calcRangeOffset() {
                    var width = this.$el.width() - 15;
                    var max = parseFloat(this.$el.attr('max')) || 100; // Range default max
                    var min = parseFloat(this.$el.attr('min')) || 0; // Range default min
                    var percent = (parseFloat(this.$el.val()) - min) / (max - min);
                    return percent * width;
                }
            }
        ], [
            {
                key: "init",
                value: function init(els, options) {
                    return _get(Range.__proto__ || Object.getPrototypeOf(Range), "init", this).call(this, this, els, options);
                }
            },
            {
                key: "getInstance",
                value: function getInstance(el) {
                    var domElem = !!el.jquery ? el[0] : el;
                    return domElem.M_Range;
                }
            },
            {
                key: "defaults",
                get: function() {
                    return _defaults;
                }
            }
        ]);
        return Range;
    }(Component);
    M.Range = Range1;
    if (M.jQueryLoaded) M.initializeJqueryWrapper(Range1, 'range', 'M_Range');
    Range1.init($('input[type=range]'));
})(cash, M.anime);

},{}],"ggD5y":[function(require,module,exports) {
var _start = require("./start");
const $ = require('jquery');
const d3 = require('d3');
var counterContext;
$(function() {
    console.log(_start);
    _start.initCmeans();
    _start.initGraph();
    $('#animspeed').on('change', function() {
        _start.animspeed = 100 + (100 - Number($("#animspeed").val())) * 15;
        timerfuncs();
    });
    d3.select("#iterate").on("wheel", function() {
        document.getElementById("lblStatus").style.display = "block";
        document.getElementById("lblStatus").innerHTML = "Rendering plot...";
        setTimeout(function() {
            _start.cmeansLoop();
            _start.animate();
        }, 100);
    }).on("click", function() {
        document.getElementById("lblStatus").style.display = "block";
        document.getElementById("lblStatus").innerHTML = "Rendering plot...";
        setTimeout(function() {
            _start.cmeansLoop();
            _start.animate();
        }, 100);
    });
    d3.select("#setparams").on("click", function() {
        _start.c = Number($("#noofc").val());
        _start.m = Number($("#mValue").val());
        _start.thresh = Number($("#threshold").val());
        _start.numDataPoints = Number($("#noofpoints").val());
        _start.animspeed = 100 + (100 - Number($("#animspeed").val())) * 15;
        _start.distFunc = Number($("#distFuncSel").val());
        $("#plot").empty();
        _start.initCmeans();
        _start.initGraph();
    });
    d3.select("#checktimer").on("click", function() {
        timerfuncs();
    });
});
function timerfuncs() {
    clearInterval(counterContext);
    if ($('#checktimer').is(':checked')) {
        $('.csbutt').addClass('disabled');
        document.getElementById("lblStatus").style.display = "none";
        counterContext = setInterval(function() {
            _start.cmeansLoop();
            _start.animate();
        }, _start.animspeed + 150 + 10);
    } else $('.csbutt').removeClass('disabled');
}

},{"jquery":"bE6My","./start":"lRlSR","d3":"aBLff"}],"lRlSR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initCmeans", ()=>initCmeans
);
parcelHelpers.export(exports, "initGraph", ()=>initGraph
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "cmeansLoop", ()=>cmeansLoop
);
parcelHelpers.export(exports, "animate", ()=>animate
);
parcelHelpers.export(exports, "dataset", ()=>dataset
);
parcelHelpers.export(exports, "numDataPoints", ()=>numDataPoints
);
parcelHelpers.export(exports, "maxRange", ()=>maxRange
);
parcelHelpers.export(exports, "xScale", ()=>xScale
);
parcelHelpers.export(exports, "yScale", ()=>yScale
);
parcelHelpers.export(exports, "svg", ()=>svg
);
parcelHelpers.export(exports, "xAxis", ()=>xAxis
);
parcelHelpers.export(exports, "yAxis", ()=>yAxis
);
parcelHelpers.export(exports, "centroidRadius", ()=>centroidRadius
);
parcelHelpers.export(exports, "pointRadius", ()=>pointRadius
);
parcelHelpers.export(exports, "m", ()=>m
);
parcelHelpers.export(exports, "thresh", ()=>thresh
);
parcelHelpers.export(exports, "distFunc", ()=>distFunc
);
parcelHelpers.export(exports, "canvas_width", ()=>canvas_width
);
parcelHelpers.export(exports, "canvas_height", ()=>canvas_height
);
parcelHelpers.export(exports, "padding", ()=>padding
);
parcelHelpers.export(exports, "animspeed", ()=>animspeed
);
parcelHelpers.export(exports, "c", ()=>c
);
parcelHelpers.export(exports, "u", ()=>u
);
parcelHelpers.export(exports, "V", ()=>V
);
parcelHelpers.export(exports, "choosefile", ()=>choosefile
);
const d3 = require('d3');
// Setup data
var dataset = []; // Initialize empty array
var numDataPoints = 400; // Number of dummy data points
var maxRange = /*Math.random() * */ 1000; // Max range of new values
var xScale;
var yScale;
var svg;
var xAxis;
var yAxis;
var centroidRadius = 7;
var pointRadius = 2;
var m = 2; //fuziness control
var thresh = 0.5; //threshold
var distFunc = 1;
// Setup settings for graphic
var canvas_width = 420;
var canvas_height = 420;
var padding = 30; // for chart edges
var animspeed = 250;
//  Setup C-means
var c = 3; //No. of clusters
var u = []; //Membership function
var V = []; //Cluster centres
var choosefile = 0;
function initCmeans() {
    u = [];
    V = [];
    dataset = [];
    if (choosefile == 0) {
        //random dataset
        for(var i = 0; i < numDataPoints; i++){
            var newNumber1 = Math.floor(Math.random() * maxRange); // New random integer
            var newNumber2 = Math.floor(Math.random() * maxRange); // New random integer
            dataset.push([
                newNumber1,
                newNumber2
            ]); // Add new number to array
        }
        //Generate u
        for(var i = 0; i < dataset.length; i++){
            var tempRandom = [];
            var tempTotal = 0;
            for(var noOfClusters = 0; noOfClusters < c; noOfClusters++){
                tempRandom[noOfClusters] = Math.random(); //Randomly assign u
                tempTotal += tempRandom[noOfClusters]; //Keep a tab of the total sum
            }
            for(var noOfClusters = 0; noOfClusters < c; noOfClusters++)tempRandom[noOfClusters] /= tempTotal; //Normalize so that sum of all membership values = 1
            u[i] = tempRandom; //push value to u
        }
    } else //getfromimage
    for(var t = 0; t < picD.length; t++){
        u[t] = [
            picU[t][0],
            picU[t][1],
            picU[t][2]
        ];
        dataset[t] = [
            picD[t][0],
            picD[t][1]
        ];
    }
    //Generate cluster centres
    for(var i = 0; i < c; i++)V[i] = [
        Math.floor(Math.random() * maxRange),
        Math.floor(Math.random() * maxRange)
    ]; //Randomly initialize cluster centers
}
function initGraph() {
    document.getElementById("objStat").style.display = "none";
    var graphdata = V.concat(dataset);
    // Create scale functions
    xScale = d3.scale.linear() // xScale is width of graphic
    .domain([
        0,
        d3.max(graphdata, function(d) {
            return d[0]; // input domain
        })
    ]).range([
        padding,
        canvas_width - padding /** 2*/ 
    ]); // output range
    yScale = d3.scale.linear() // yScale is height of graphic
    .domain([
        0,
        d3.max(graphdata, function(d) {
            return d[1]; // input domain
        })
    ]).range([
        canvas_height - padding,
        padding
    ]); // remember y starts on top going down so we flip
    // Define X axis
    xAxis = d3.svg.axis().scale(xScale).orient("bottom").ticks(maxRange / 200 + 5);
    // Define Y axis
    yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(maxRange / 200 + 5);
    // Create SVG element
    svg = d3.select("#plot") // This is where we put our vis
    .append("svg").attr("width", canvas_width).attr("height", canvas_height);
    // Create Circles
    svg.selectAll("circle").data(graphdata).enter().append("circle") // Add circle svg
    .attr("cx", function(d) {
        return xScale(d[0]); // Circle's X
    }).attr("cy", function(d) {
        return yScale(d[1]);
    }).attr("r", function(d, i) {
        return i < c ? centroidRadius : pointRadius;
    }) // radius
    .attr("fill", function(d, i) {
        return i == 0 ? "#f00" : i == 1 ? "#0f0" : i == 2 ? "#00f" : "rgb(" + Math.ceil(255 * u[i - 3][0]) + "," + Math.ceil(255 * u[i - 3][1]) + "," + Math.ceil(255 * u[i - 3][2]) + ")";
    });
    // Add to X axis
    svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + (canvas_height - padding) + ")").call(xAxis);
    // Add to Y axis
    svg.append("g").attr("class", "y axis").attr("transform", "translate(" + padding + ",0)").call(yAxis);
}
function dist(vec1, vec2, indexdata, indexcentroid, choice) {
    if (choice == 1) {
        //Euclidean distance
        var N = vec1.length;
        var d = 0;
        for(var i = 0; i < N; i++)d += Math.pow(vec1[i] - vec2[i], 2);
        d = Math.sqrt(d);
        return d;
    } else if (choice == 2) {
        //phasor difference
        var r = Math.abs(Math.sqrt(Math.pow(vec1[0], 2) + Math.pow(vec1[1], 2)) - Math.sqrt(Math.pow(vec2[0], 2) + Math.pow(vec2[1], 2)));
        var theta = Math.abs(Math.atan(vec1[1] / vec1[0]) - Math.atan(vec2[1] / vec2[0]));
        return r + theta;
    } else if (choice == 3) //city block distance
    return Math.abs(vec1[0] - vec2[0]) + Math.abs(vec1[1] - vec2[1]);
    else if (choice == 4) //chromatic
    return 1 - u[indexdata][indexcentroid] + u[indexdata][(indexcentroid + 1) % 3] + u[indexdata][(indexcentroid + 2) % 3];
}
function cmeansLoop() {
    //update V - Cluster Centres
    var num = 0;
    var den = 0;
    var oldV = [];
    for(var t = 0; t < V.length; t++)oldV[t] = [
        V[t][0],
        V[t][1]
    ];
    for(var i = 0; i < c; i++){
        num = 0;
        den = 0;
        for(var k = 0; k < dataset.length; k++){
            num += Math.pow(u[k][i], m) * dataset[k][0];
            den += Math.pow(u[k][i], m);
        }
        //if(!isNan(num/den))
        V[i][0] = num / den;
        num = 0;
        den = 0;
        for(var k = 0; k < dataset.length; k++){
            num += Math.pow(u[k][i], m) * dataset[k][1];
            den += Math.pow(u[k][i], m);
        }
        //if(!isNan(num/den))
        V[i][1] = num / den;
    }
    //update u - membership values
    for(var i = 0; i < c; i++)for(var k = 0; k < dataset.length; k++){
        num = 0;
        den = 0;
        num = Math.pow(dist(dataset[k], V[i], k, i, distFunc), 2 / (m - 1));
        for(var j = 0; j < c; j++)den += 1 / Math.pow(dist(dataset[k], V[j], k, j, distFunc), 2 / (m - 1));
        if (!isNaN(Math.pow(num * den, -1))) u[k][i] = Math.pow(num * den, -1);
    //if(isNaN(u[k][i])) u[k][i]=0;
    }
    // calculate obj. func. value
    var J = 0;
    for(var i = 0; i < c; i++)for(var k = 0; k < dataset.length; k++)J += Math.pow(u[k][i], m) * Math.pow(dist(dataset[k], V[i], k, i, distFunc), 2);
    var tempT = 0;
    for(var count = 0; count < c; count++)tempT += dist(oldV[count], V[count], count, count, distFunc == 4 ? 1 : distFunc);
    if (tempT < thresh) document.getElementById("Jval").innerHTML = "Objective function value: " + J + "<br>Change in cluster location: <span style='color:red'>" + tempT + "</span><br><span style='color:green'>Converged!</span>";
    else document.getElementById("Jval").innerHTML = "Objective function value: " + J + "<br>Change in cluster location: <span style='color:red'>" + tempT + "</span>";
    document.getElementById("objStat").style.display = "block";
/*	
    //addition
    memNew = [];
    //update membership loc
    for(var i=0; i<numDataPoints; i++)
        memNew.push([xMem(i), yMem(i)]);
    //end of addition
    //*/ }
function animate() {
    // Update scale domain
    //addition
    //var graphdata = V.concat(memNew);
    var graphdata = V.concat(dataset);
    xScale.domain([
        0,
        d3.max(graphdata, function(d) {
            return d[0];
        })
    ]);
    yScale.domain([
        0,
        d3.max(graphdata, function(d) {
            return d[1];
        })
    ]);
    var temp = -1;
    var temp2 = -1;
    // Update circles
    svg.selectAll("circle").data(graphdata) // Update with new data
    .transition() // Transition from old to new
    .duration(animspeed) // Length of animation
    .each("start", function() {
        d3.select(this) // 'this' means the current element
        // .attr("fill", "red")  // Change color
        .attr("r", function(d, i) {
            ++temp2;
            return temp2 < c ? centroidRadius + 1 : pointRadius;
        }); // Change size
    }).delay(function(d, i) {
        return 0; /* i / graphdata.length * (animspeed/5); */  // Dynamic delay (i.e. each item delays a little longer)
    })//.ease("linear")  // Transition easing - default 'variable' (i.e. has acceleration), also: 'circle', 'elastic', 'bounce', 'linear'
    .attr("cx", function(d) {
        return xScale(d[0]); // Circle's X
    }).attr("cy", function(d) {
        return yScale(d[1]); // Circle's Y
    }).each("end", function() {
        d3.select(this) // 'this' means the current element
        .transition().duration(150).attr("fill", function(d, i) {
            ++temp;
            if (isNaN(d3.select(this).attr("cx"))) return "rgba(0,0,0,0)";
            //if(isNaN($(this).cx) || isNaN($(this).cy)) return "rgba(0,0,0,0)";
            return temp == 0 ? "#f00" : temp == 1 ? "#0f0" : temp == 2 ? "#00f" : "rgb(" + Math.ceil(255 * u[temp - 3][0]) + "," + Math.ceil(255 * u[temp - 3][1]) + "," + Math.ceil(255 * u[temp - 3][2]) + ")";
        }) // Change color
        .attr("r", function(d, i) {
            return temp < c ? centroidRadius : pointRadius;
        }); // Change size
        if (temp == numDataPoints + c - 1) {
            document.getElementById("lblStatus").innerHTML = "Rendering complete";
            setTimeout(function() {
                document.getElementById("lblStatus").style.display = "none";
            }, 100);
        }
    });
    // Update X Axis
    svg.select(".x.axis").transition().duration(animspeed).call(xAxis);
    // Update Y Axis
    svg.select(".y.axis").transition().duration(animspeed).call(yAxis);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV","d3":"aBLff"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"aBLff":[function(require,module,exports) {
!function() {
    var d3 = {
        version: "3.5.17"
    };
    var d3_arraySlice = [].slice, d3_array = function(list) {
        return d3_arraySlice.call(list);
    };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) try {
        d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e1) {
        d3_array = function(list) {
            var i = list.length, array = new Array(i);
            while(i--)array[i] = list[i];
            return array;
        };
    }
    if (!Date.now) Date.now = function() {
        return +new Date();
    };
    if (d3_document) try {
        d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error1) {
        var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
        d3_element_prototype.setAttribute = function(name, value) {
            d3_element_setAttribute.call(this, name, value + "");
        };
        d3_element_prototype.setAttributeNS = function(space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "");
        };
        d3_style_prototype.setProperty = function(name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
        };
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while(++i < n)if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while(++i < n)if ((b = array[i]) != null && a > b) a = b;
        } else {
            while(++i < n)if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while(++i < n)if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
        }
        return a;
    };
    d3.max = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while(++i < n)if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while(++i < n)if ((b = array[i]) != null && b > a) a = b;
        } else {
            while(++i < n)if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while(++i < n)if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
        }
        return a;
    };
    d3.extent = function(array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while(++i < n)if ((b = array[i]) != null && b >= b) {
                a = c = b;
                break;
            }
            while(++i < n)if ((b = array[i]) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        } else {
            while(++i < n)if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = c = b;
                break;
            }
            while(++i < n)if ((b = f.call(array, array[i], i)) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        }
        return [
            a,
            c
        ];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function(array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while(++i < n)if (d3_numeric(a = +array[i])) s += a;
        } else {
            while(++i < n)if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
        }
        return s;
    };
    d3.mean = function(array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while(++i < n)if (d3_numeric(a = d3_number(array[i]))) s += a;
            else --j;
        } else {
            while(++i < n)if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a;
            else --j;
        }
        if (j) return s / j;
    };
    d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function(array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while(++i < n)if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
        } else {
            while(++i < n)if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
        }
        if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), 0.5);
    };
    d3.variance = function(array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while(++i < n)if (d3_numeric(a = d3_number(array[i]))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
            }
        } else {
            while(++i < n)if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
            }
        }
        if (j > 1) return s / (j - 1);
    };
    d3.deviation = function() {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while(lo < hi){
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0) lo = mid + 1;
                    else hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while(lo < hi){
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0) hi = mid;
                    else lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2) i0 = 0;
        }
        var m = i1 - i0, t, i;
        while(m){
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function(array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while(i--)permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function(array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while(i < n)pairs[i] = [
            p0 = p1,
            p1 = array[++i]
        ];
        return pairs;
    };
    d3.transpose = function(matrix) {
        if (!(n = matrix.length)) return [];
        for(var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m;)for(var j = -1, n, row = transpose[i] = new Array(n); ++j < n;)row[j] = matrix[j][i];
        return transpose;
    };
    function d3_transposeLength(d) {
        return d.length;
    }
    d3.zip = function() {
        return d3.transpose(arguments);
    };
    d3.keys = function(map) {
        var keys = [];
        for(var key in map)keys.push(key);
        return keys;
    };
    d3.values = function(map) {
        var values = [];
        for(var key in map)values.push(map[key]);
        return values;
    };
    d3.entries = function(map) {
        var entries = [];
        for(var key in map)entries.push({
            key: key,
            value: map[key]
        });
        return entries;
    };
    d3.merge = function(arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while(++i < n)j += arrays[i].length;
        merged = new Array(j);
        while(--n >= 0){
            array = arrays[n];
            m = array.length;
            while(--m >= 0)merged[--j] = array[m];
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity) throw new Error("infinite range");
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0) while((j = start + step * ++i) > stop)range.push(j / k);
        else while((j = start + step * ++i) < stop)range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while(x * k % 1)k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for(var key in properties)Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
        });
    }
    d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) object.forEach(function(key, value) {
            map.set(key, value);
        });
        else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1) while(++i < n)map.set(i, object[i]);
            else while(++i < n)map.set(f.call(object, o = object[i], i), o);
        } else for(var key1 in object)map.set(key1, object[key1]);
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = "__proto__", d3_map_zero = "\x00";
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
            return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
            var values = [];
            for(var key in this._)values.push(this._[key]);
            return values;
        },
        entries: function() {
            var entries = [];
            for(var key in this._)entries.push({
                key: d3_map_unescape(key),
                value: this._[key]
            });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for(var key in this._)f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for(var key in this._)keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for(var key in this._)++size;
        return size;
    }
    function d3_map_empty() {
        for(var key in this._)return false;
        return true;
    }
    d3.nest = function() {
        var nest = {
        }, keys = [], sortKeys = [], sortValues, rollup;
        function map1(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue1, object, setter, valuesByKey = new d3_Map(), values1;
            while(++i < n)if (values1 = valuesByKey.get(keyValue1 = key(object = array[i]))) values1.push(object);
            else valuesByKey.set(keyValue1, [
                object
            ]);
            if (mapType) {
                object = mapType();
                setter = function(keyValue, values) {
                    object.set(keyValue, map1(mapType, values, depth));
                };
            } else {
                object = {
                };
                setter = function(keyValue, values) {
                    object[keyValue] = map1(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length) return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function(key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function(a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function(array, mapType) {
            return map1(mapType, array, 0);
        };
        nest.entries = function(array) {
            return entries(map1(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function(order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function(f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function(array) {
        var set = new d3_Set();
        if (array) for(var i = 0, n = array.length; i < n; ++i)set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for(var key in this._)f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {
    };
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function(target, source) {
        var i = 1, n = arguments.length, method;
        while(++i < n)target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object) return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for(var i = 0, n = d3_vendorPrefixes.length; i < n; ++i){
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object) return prefixName;
        }
    }
    var d3_vendorPrefixes = [
        "webkit",
        "ms",
        "moz",
        "Moz",
        "o",
        "O"
    ];
    function d3_noop() {
    }
    d3.dispatch = function() {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while(++i < n)dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {
    }
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null) {
                for(type in this)if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while(++i < n)if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
                on: listener
            }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while(s = e.sourceEvent)e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while(++i < n)dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
            return function(e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally{
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {
    }.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
    } : function(object, prototype) {
        for(var property in prototype)object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function(s, n) {
        return n.querySelector(s);
    }, d3_selectAll = function(s, n) {
        return n.querySelectorAll(s);
    }, d3_selectMatches = function(n1, s1) {
        var d3_selectMatcher = n1.matches || n1[d3_vendorSymbol(n1, "matchesSelector")];
        d3_selectMatches = function(n, s) {
            return d3_selectMatcher.call(n, s);
        };
        return d3_selectMatches(n1, s1);
    };
    if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function() {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for(var j = -1, m = this.length; ++j < m;){
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for(var i = -1, n = group.length; ++i < n;)if (node = group[i]) {
                subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
            } else subgroup.push(null);
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for(var j = -1, m = this.length; ++j < m;){
            for(var group = this[j], i = -1, n = group.length; ++i < n;)if (node = group[i]) {
                subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                subgroup.parentNode = node;
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
    var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: d3_nsXhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for(value in name)this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name);
            else this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local);
            else this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
    }
    d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while(++i < n)if (!value.contains(name[i])) return false;
                } else {
                    value = node.getAttribute("class");
                    while(++i < n)if (!d3_selection_classedRe(name[i]).test(value)) return false;
                }
                return true;
            }
            for(value in name)this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
    }
    function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while(++i < n)name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while(++i < n)name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else node.setAttribute("class", d3_collapse(c.replace(re, " ")));
        };
    }
    d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for(priority in name)this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name);
            else this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for(value in name)this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name];
            else this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        } : value == null ? function() {
            this.textContent = "";
        } : function() {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
            this.innerHTML = "";
        } : function() {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
    }
    d3_selectionPrototype.data = function(value, key) {
        var i1 = -1, n2 = this.length, group1, node1;
        if (!arguments.length) {
            value = new Array(n2 = (group1 = this[0]).length);
            while(++i1 < n2)if (node1 = group1[i1]) value[i1] = node1.__data__;
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for(i = -1; ++i < n;)if (node = group[i]) {
                    if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) exitNodes[i] = node;
                    else nodeByKeyValue.set(keyValue, node);
                    keyValues[i] = keyValue;
                }
                for(i = -1; ++i < m;){
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) enterNodes[i] = d3_selection_dataNode(nodeData);
                    else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for(i = -1; ++i < n;)if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) exitNodes[i] = group[i];
            } else {
                for(i = -1; ++i < n0;){
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else enterNodes[i] = d3_selection_dataNode(nodeData);
                }
                for(; i < m; ++i)enterNodes[i] = d3_selection_dataNode(groupData[i]);
                for(; i < n; ++i)exitNodes[i] = group[i];
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === "function") while(++i1 < n2)bind(group1 = this[i1], value.call(group1, group1.parentNode.__data__, i1));
        else while(++i1 < n2)bind(group1 = this[i1], value);
        update.enter = function() {
            return enter;
        };
        update.exit = function() {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return {
            __data__: data
        };
    }
    d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
    };
    d3_selectionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for(var j = 0, m = this.length; j < m; j++){
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for(var i = 0, n = group.length; i < n; i++)if ((node = group[i]) && filter.call(node, node.__data__, i, j)) subgroup.push(node);
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function() {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function() {
        for(var j = -1, m = this.length; ++j < m;){
            for(var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;)if (node = group[i]) {
                if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                next = node;
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for(var j = -1, m = this.length; ++j < m;)this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length) comparator = d3_ascending;
        return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for(var j = 0, m = groups.length; j < m; j++){
            for(var group = groups[j], i = 0, n = group.length, node; i < n; i++)if (node = group[i]) callback(node, i, j);
        }
        return groups;
    }
    d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function() {
        return !this.node();
    };
    d3_selectionPrototype.node = function() {
        for(var j = 0, m = this.length; j < m; j++)for(var group = this[j], i = 0, n = group.length; i < n; i++){
            var node = group[i];
            if (node) return node;
        }
        return null;
    };
    d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for(var j = -1, m = this.length; ++j < m;){
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for(var i = -1, n = group.length; ++i < n;)if (node = group[i]) {
                subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                subnode.__data__ = node.__data__;
            } else subgroup.push(null);
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0) j0 = j, i0 = 0;
            if (i >= i0) i0 = i + 1;
            while(!(node = group[i0]) && ++i0 < n);
            return node;
        };
    }
    d3.select = function(node) {
        var group;
        if (typeof node === "string") {
            group = [
                d3_select(node, d3_document)
            ];
            group.parentNode = d3_document.documentElement;
        } else {
            group = [
                node
            ];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([
            group
        ]);
    };
    d3.selectAll = function(nodes) {
        var group;
        if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        } else {
            group = d3_array(nodes);
            group.parentNode = null;
        }
        return d3_selection([
            group
        ]);
    };
    d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== "string") {
                if (n < 2) listener = false;
                for(capture in type)this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name1 = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
        if (i > 0) type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter) type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name1];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name1];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name1] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for(var name in this)if (match = name.match(re)) {
                var l = this[name];
                this.removeEventListener(match[1], l, l.$);
                delete this[name];
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    if (d3_document) d3_selection_onFilters.forEach(function(k) {
        if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
    function d3_selection_onListener(listener, argumentz) {
        return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally{
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) l.call(target, e);
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function() {
                    w.on(click, null);
                };
                w.on(click, function() {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches) e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select("body").append("svg").style({
                        position: "absolute",
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: "none"
                    }, "important");
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;
            else point.x = e.clientX, point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [
                point.x,
                point.y
            ];
        }
        var rect = container.getBoundingClientRect();
        return [
            e.clientX - rect.left - container.clientLeft,
            e.clientY - rect.top - container.clientTop
        ];
    }
    d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches) for(var i = 0, n = touches.length, touch; i < n; ++i){
            if ((touch = touches[i]).identifier === identifier) return d3_mousePoint(container, touch);
        }
    };
    d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function() {
                var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [
                        dragOffset.x - position0[0],
                        dragOffset.y - position0[1]
                    ];
                } else dragOffset = [
                    0,
                    0
                ];
                dispatch({
                    type: "dragstart"
                });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1) return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: "drag",
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId)) return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged);
                    dispatch({
                        type: "dragend"
                    });
                }
            };
        }
        drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, "on");
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function(container, touches) {
        if (arguments.length < 2) touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var ε = 0.000001, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var ρ1 = Math.SQRT2, ρ2 = 2, ρ4 = 4;
    d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < ε2) {
            S = Math.log(w1 / w0) / ρ1;
            i = function(t) {
                return [
                    ux0 + t * dx,
                    uy0 + t * dy,
                    w0 * Math.exp(ρ1 * t * S)
                ];
            };
        } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / ρ1;
            i = function(t) {
                var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ1 * s + r0) - d3_sinh(r0));
                return [
                    ux0 + u * dx,
                    uy0 + u * dy,
                    w0 * coshr0 / d3_cosh(ρ1 * s + r0)
                ];
            };
        }
        i.duration = S * 1000;
        return i;
    };
    d3.behavior.zoom = function() {
        var view = {
            x: 0,
            y: 0,
            k: 1
        }, translate0, center0, center, size = [
            960,
            500
        ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
        }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return d3.event.wheelDelta;
        }, "mousewheel") : (d3_behavior_zoomDelta = function() {
            return -d3.event.detail;
        }, "MozMousePixelScroll");
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
            g.each(function() {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) d3.select(this).transition().each("start.zoom", function() {
                    view = this.__chart__ || {
                        x: 0,
                        y: 0,
                        k: 1
                    };
                    zoomstarted(dispatch);
                }).tween("zoom:zoom", function() {
                    var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([
                        (cx - view.x) / view.k,
                        (cy - view.y) / view.k,
                        dx / view.k
                    ], [
                        (cx - view1.x) / view1.k,
                        (cy - view1.y) / view1.k,
                        dx / view1.k
                    ]);
                    return function(t) {
                        var l = i(t), k = dx / l[2];
                        this.__chart__ = view = {
                            x: cx - l[0] * k,
                            y: cy - l[1] * k,
                            k: k
                        };
                        zoomed(dispatch);
                    };
                }).each("interrupt.zoom", function() {
                    zoomended(dispatch);
                }).each("end.zoom", function() {
                    zoomended(dispatch);
                });
                else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function(_) {
            if (!arguments.length) return [
                view.x,
                view.y
            ];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function(_) {
            if (!arguments.length) return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function(_) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.center = function(_) {
            if (!arguments.length) return center;
            center = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.size = function(_) {
            if (!arguments.length) return size;
            size = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.duration = function(_) {
            if (!arguments.length) return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [
                (p[0] - view.x) / view.k,
                (p[1] - view.y) / view.k
            ];
        }
        function point(l) {
            return [
                l[0] * view.k + view.x,
                l[1] * view.k + view.y
            ];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
                return (x - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
                return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
                type: "zoomstart"
            });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: "zoom",
                scale: view.k,
                translate: [
                    view.x,
                    view.y
                ]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming) dispatch({
                type: "zoomend"
            }), center0 = null;
        }
        function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {
            }, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function(t) {
                    if (t.identifier in locations0) locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for(var i = 0, n = changed.length; i < n; ++i)locations0[changed[i].identifier] = null;
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for(var i = 0, n = touches.length; i < n; ++i, l1 = null){
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0) break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [
                        (p0[0] + p1[0]) / 2,
                        (p0[1] + p1[1]) / 2
                    ];
                    l0 = [
                        (l0[0] + l1[0]) / 2,
                        (l0[1] + l1[1]) / 2
                    ];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for(var i = 0, n = changed.length; i < n; ++i)delete locations0[changed[i].identifier];
                    for(var identifier in locations0)return void relocate();
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer);
            else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 0.002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
    };
    var d3_behavior_zoomInfinity = [
        0,
        Infinity
    ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() {
    }
    d3_color.prototype.toString = function() {
        return this.rgb() + "";
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function(k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function(k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h1, s, l) {
        var m1, m2;
        h1 = isNaN(h1) ? 0 : (h1 %= 360) < 0 ? h1 + 360 : h1;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360) h -= 360;
            else if (h < 0) h += 360;
            if (h < 60) return m1 + (m2 - m1) * h / 60;
            if (h < 180) return m2;
            if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h1 + 120), vv(h1), vv(h1 - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h)) h = 0;
        if (isNaN(c)) c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b) return new d3_rgb(i, i, i);
        if (r && r < i) r = i;
        if (g && g < i) g = i;
        if (b && b < i) b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function(k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
            m2 = m1[2].split(",");
            switch(m1[1]){
                case "hsl":
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                case "rgb":
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
            }
        }
        if (color = d3_rgb_names.get(format)) return rgb(color.r, color.g, color.b);
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max) h = (b - r) / d + 2;
            else h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X), y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y), z = d3_xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback1) {
        var xhr = {
        }, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {
        }, request1 = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request1) && /^(http(s)?:)?\/\//.test(url)) request1 = new XDomainRequest();
        "onload" in request1 ? request1.onload = request1.onerror = respond : request1.onreadystatechange = function() {
            request1.readyState > 3 && respond();
        };
        function respond() {
            var status = request1.status, result;
            if (!status && d3_xhrHasResponse(request1) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request1);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else dispatch.error.call(xhr, request1);
        }
        request1.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request1);
            } finally{
                d3.event = o;
            }
        };
        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name];
            else headers[name] = value + "";
            return xhr;
        };
        xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function(value) {
            response = value;
            return xhr;
        };
        [
            "get",
            "post"
        ].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [
                    method
                ].concat(d3_array(arguments)));
            };
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
            request1.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request1.setRequestHeader) for(var name in headers)request1.setRequestHeader(name, headers[name]);
            if (mimeType != null && request1.overrideMimeType) request1.overrideMimeType(mimeType);
            if (responseType != null) request1.responseType = responseType;
            if (callback != null) xhr.on("error", callback).on("load", function(request) {
                callback(null, request);
            });
            dispatch.beforesend.call(xhr, request1);
            request1.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function() {
            request1.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback1 == null ? xhr : xhr.get(d3_xhr_fixCallback(callback1));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
    }
    d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function(request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row1, i2) {
                if (o) return o(row1, i2 - 1);
                var a = new Function("d", "return {" + row1.map(function(name, i) {
                    return JSON.stringify(name) + ": d[" + i + "]";
                }).join(",") + "}");
                o = f ? function(row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function(text, f) {
            var EOL = {
            }, EOF = {
            }, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N) return EOF;
                if (eol) return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while((i++) < N)if (text.charCodeAt(i) === 34) {
                        if (text.charCodeAt(i + 1) !== 34) break;
                        ++i;
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10) ++I;
                    } else if (c === 10) eol = true;
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while(I < N){
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10) eol = true;
                    else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10) ++I, ++k;
                    } else if (c !== delimiterCode) continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while((t = token()) !== EOF){
                var a = [];
                while(t !== EOL && t !== EOF){
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null) continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
                for(var field in row)if (!fieldSet.has(field)) fields.push(fieldSet.add(field));
            });
            return [
                fields.map(formatValue).join(delimiter)
            ].concat(rows.map(function(row) {
                return fields.map(function(field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join("\n");
        };
        dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(",", "text/csv");
    d3.tsv = d3.dsv("	", "text/tab-separated-values");
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
        setTimeout(callback, 17);
    };
    d3.timer = function() {
        d3_timer.apply(this, arguments);
    };
    function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) delay = 0;
        if (n < 3) then = Date.now();
        var time = then + delay, timer = {
            c: callback,
            t: time,
            n: null
        };
        if (d3_timer_queueTail) d3_timer_queueTail.n = timer;
        else d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
        return timer;
    }
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now(), timer = d3_timer_queueHead;
        while(timer){
            if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
            timer = timer.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while(t1)if (t1.c) {
            if (t1.t < time) time = t1.t;
            t1 = (t0 = t1).n;
        } else t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [
        "y",
        "z",
        "a",
        "f",
        "p",
        "n",
        "µ",
        "m",
        "",
        "k",
        "M",
        "G",
        "T",
        "P",
        "E",
        "Z",
        "Y"
    ].map(d3_formatPrefix);
    d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value = +value) {
            if (value < 0) value *= -1;
            if (precision) value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(0.000000000001 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d1, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function(d) {
                return d / k;
            } : function(d) {
                return d * k;
            },
            symbol: d1
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
            var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
            while(i > 0 && g > 0){
                if (length + g + 1 > width) g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width) break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
            }
            return t.reverse().join(locale_thousands);
        } : d3_identity;
        return function(specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
            if (precision) precision = +precision.substring(1);
            if (zfill || fill === "0" && align === "=") {
                zfill = fill = "0";
                align = "=";
            }
            switch(type){
                case "n":
                    comma = true;
                    type = "g";
                    break;
                case "%":
                    scale = 100;
                    suffix = "%";
                    type = "f";
                    break;
                case "p":
                    scale = 100;
                    suffix = "%";
                    type = "r";
                    break;
                case "b":
                case "o":
                case "x":
                case "X":
                    if (symbol === "#") prefix = "0" + type.toLowerCase();
                case "c":
                    exponent = false;
                case "d":
                    integer = true;
                    precision = 0;
                    break;
                case "s":
                    scale = -1;
                    type = "r";
                    break;
            }
            if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == "r" && !precision) type = "g";
            if (precision != null) {
                if (type == "g") precision = Math.max(1, Math.min(21, precision));
                else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function(value) {
                var fullSuffix = suffix;
                if (integer && value % 1) return "";
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else value *= scale;
                value = type(value, precision);
                var i = value.lastIndexOf("."), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf("e") : -1;
                    if (j < 0) before = value, after = "";
                    else before = value.substring(0, j), after = value.substring(j);
                } else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma) before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function(x) {
            return x.toString(2);
        },
        c: function(x) {
            return String.fromCharCode(x);
        },
        o: function(x) {
            return x.toString(8);
        },
        x: function(x) {
            return x.toString(16);
        },
        X: function(x) {
            return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
            return x.toPrecision(p);
        },
        e: function(x, p) {
            return x.toExponential(p);
        },
        f: function(x, p) {
            return x.toFixed(p);
        },
        r: function(x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 0.000000000000001), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + "";
    }
    var d3_time = d3.time = {
    }, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function() {
            return this._.getUTCDate();
        },
        getDay: function() {
            return this._.getUTCDay();
        },
        getFullYear: function() {
            return this._.getUTCFullYear();
        },
        getHours: function() {
            return this._.getUTCHours();
        },
        getMilliseconds: function() {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
            return this._.getUTCMinutes();
        },
        getMonth: function() {
            return this._.getUTCMonth();
        },
        getSeconds: function() {
            return this._.getUTCSeconds();
        },
        getTime: function() {
            return this._.getTime();
        },
        getTimezoneOffset: function() {
            return 0;
        },
        valueOf: function() {
            return this._.valueOf();
        },
        setDate: function() {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) while(time < t1){
                if (!(number(time) % dt)) times.push(new Date(+time));
                step(time, 1);
            }
            else while(time < t1)times.push(new Date(+time)), step(time, 1);
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally{
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc1 = local.utc = d3_time_interval_utc(local);
        utc1.floor = utc1;
        utc1.round = d3_time_interval_utc(round);
        utc1.ceil = d3_time_interval_utc(ceil);
        utc1.offset = d3_time_interval_utc(offset);
        utc1.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function(date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally{
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function(date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2000, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function(date, offset) {
        date.setDate(date.getDate() + offset);
    }, function(date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 60000) / 86400000);
    };
    [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
    ].forEach(function(day1, i) {
        i = 7 - i;
        var interval = d3_time[day1] = d3_time_interval(function(date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function(date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day1 + "s"] = interval.range;
        d3_time[day1 + "s"].utc = interval.utc.range;
        d3_time[day1 + "OfYear"] = function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while(++i < n)if (template.charCodeAt(i) === 37) {
                    string.push(template.slice(j, i));
                    if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                    if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                    string.push(c);
                    j = i + 1;
                }
                string.push(template.slice(j, i));
                return string.join("");
            }
            format.parse = function(string) {
                var d = {
                    y: 1900,
                    m: 0,
                    d: 1,
                    H: 0,
                    M: 0,
                    S: 0,
                    L: 0,
                    Z: null
                }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length) return null;
                if ("p" in d) d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ("j" in d) date.setFullYear(d.y, 0, d.j);
                else if ("W" in d || "U" in d) {
                    if (!("w" in d)) d.w = "W" in d ? 1 : 0;
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function() {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while(i < n){
                if (j >= m) return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0) return -1;
                } else if (c != string.charCodeAt(j++)) return -1;
            }
            return j;
        }
        d3_time_format.utc = function(template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally{
                    d3_date = Date;
                }
            }
            format.parse = function(string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally{
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function(d) {
                return locale_shortDays[d.getDay()];
            },
            A: function(d) {
                return locale_days[d.getDay()];
            },
            b: function(d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function(d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function(d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function(d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function(d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function(d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function(d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function(d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function(d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function(d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function(d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function(d) {
                return d.getDay();
            },
            W: function(d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 10000, p, 4);
            },
            Z: d3_time_zone,
            "%": function() {
                return "%";
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
    }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while(++i < n)map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2000);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while(++i < n)formats[i][0] = this(formats[i][0]);
        return function(date) {
            var i = 0, f = formats[i];
            while(!f[1](date))f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function(locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [
            3
        ],
        currency: [
            "$",
            ""
        ],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: [
            "AM",
            "PM"
        ],
        days: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ],
        shortDays: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ],
        months: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ],
        shortMonths: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {
    };
    function d3_adder() {
    }
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s) this.t += d3_adderTemp.t;
            else this.s = d3_adderTemp.t;
        },
        reset: function() {
            this.s = this.t = 0;
        },
        valueOf: function() {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) d3_geo_streamObjectType[object.type](object, listener);
        else d3_geo_streamGeometry(object, listener);
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
            var features = object.features, i = -1, n = features.length;
            while(++i < n)d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
            listener.sphere();
        },
        Point: function(object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while(++i < n)object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while(++i < n)d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while(++i < n)d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while(++i < n)d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while(++i < n)coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while(++i < n)d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function() {
            d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * π + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function(λ, φ) {
            d3_geo_area.point = nextPoint;
            λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            φ = φ * d3_radians / 2 + π / 4;
            var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
            nextPoint(λ00, φ00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
        return [
            cosφ * Math.cos(λ),
            cosφ * Math.sin(λ),
            Math.sin(φ)
        ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0]
        ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [
            vector[0] * k,
            vector[1] * k,
            vector[2] * k
        ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [
            Math.atan2(cartesian[1], cartesian[0]),
            d3_asin(cartesian[2])
        ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
    }
    d3.geo.bounds = (function() {
        var λ01, φ0, λ11, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range1;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dλSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function() {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0) λ01 = -(λ11 = 180), φ0 = -(φ1 = 90);
                else if (dλSum > ε) φ1 = 90;
                else if (dλSum < -ε) φ0 = -90;
                range1[0] = λ01, range1[1] = λ11;
            }
        };
        function point(λ, φ) {
            ranges.push(range1 = [
                λ01 = λ,
                λ11 = λ
            ]);
            if (φ < φ0) φ0 = φ;
            if (φ > φ1) φ1 = φ;
        }
        function linePoint(λ, φ) {
            var p = d3_geo_cartesian([
                λ * d3_radians,
                φ * d3_radians
            ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [
                    normal[1],
                    -normal[0],
                    0
                ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
                if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = inflection[1] * d3_degrees;
                    if (φi > φ1) φ1 = φi;
                } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = -inflection[1] * d3_degrees;
                    if (φi < φ0) φ0 = φi;
                } else {
                    if (φ < φ0) φ0 = φ;
                    if (φ > φ1) φ1 = φ;
                }
                if (antimeridian) {
                    if (λ < λ_) {
                        if (angle(λ01, λ) > angle(λ01, λ11)) λ11 = λ;
                    } else if (angle(λ, λ11) > angle(λ01, λ11)) λ01 = λ;
                } else if (λ11 >= λ01) {
                    if (λ < λ01) λ01 = λ;
                    if (λ > λ11) λ11 = λ;
                } else {
                    if (λ > λ_) {
                        if (angle(λ01, λ) > angle(λ01, λ11)) λ11 = λ;
                    } else if (angle(λ, λ11) > angle(λ01, λ11)) λ01 = λ;
                }
            } else point(λ, φ);
            p0 = p, λ_ = λ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range1[0] = λ01, range1[1] = λ11;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(λ, φ) {
            if (p0) {
                var dλ = λ - λ_;
                dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
            } else λ__ = λ, φ__ = φ;
            d3_geo_area.point(λ, φ);
            linePoint(λ, φ);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(λ__, φ__);
            d3_geo_area.lineEnd();
            if (abs(dλSum) > ε) λ01 = -(λ11 = 180);
            range1[0] = λ01, range1[1] = λ11;
            p0 = null;
        }
        function angle(λ0, λ1) {
            return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
            φ1 = λ11 = -(λ01 = φ0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for(var i = 1, a = ranges[0], b, merged = [
                    a
                ]; i < n; ++i){
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                    } else merged.push(a = b);
                }
                var best = -Infinity, dλ;
                for(var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i){
                    b = merged[i];
                    if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ01 = b[0], λ11 = a[1];
                }
            }
            ranges = range1 = null;
            return λ01 === Infinity || φ0 === Infinity ? [
                [
                    NaN,
                    NaN
                ],
                [
                    NaN,
                    NaN
                ]
            ] : [
                [
                    λ01,
                    φ0
                ],
                [
                    λ11,
                    φ1
                ]
            ];
        };
    })();
    d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < ε2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < ε2) return [
                NaN,
                NaN
            ];
        }
        return [
            Math.atan2(y, x) * d3_degrees,
            d3_asin(z / Math.sqrt(m)) * d3_degrees
        ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var λ00, φ00, x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ00 = λ, φ00 = φ;
            d3_geo_centroid.point = nextPoint;
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
            nextPoint(λ00, φ00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function(segment) {
            if ((n = segment.length - 1) <= 0) return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for(var i = 0; i < n; ++i)listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length) return;
        for(var i3 = 0, entry = clipStartInside, n3 = clip.length; i3 < n3; ++i3)clip[i3].e = entry = !entry;
        var start = subject[0], points, point;
        while(true){
            var current = start, isSubject = true;
            while(current.v)if ((current = current.n) === start) return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) for(var i3 = 0, n3 = points.length; i3 < n3; ++i3)listener.point((point = points[i3])[0], point[1]);
                    else interpolate(current.x, current.n.x, 1, listener);
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for(var i3 = points.length - 1; i3 >= 0; --i3)listener.point((point = points[i3])[0], point[1]);
                    } else interpolate(current.x, current.p.x, -1, listener);
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            }while (!current.v)
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length)) return;
        var n, i = 0, a = array[0], b;
        while(++i < n){
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point1,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function() {
                    clip.point = point1;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function() {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point1(λ, φ) {
                var point = rotate(λ, φ);
                if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
            }
            function pointLine(λ, φ) {
                var point = rotate(λ, φ);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point1;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(λ, φ) {
                ring.push([
                    λ,
                    φ
                ]);
                var point = rotate(λ, φ);
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n) return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while(++i < n)listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function() {
                lines.push(line = []);
            },
            point: function(λ, φ) {
                line.push([
                    λ,
                    φ
                ]);
            },
            lineEnd: d3_noop,
            buffer: function() {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function() {
                if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [
        -π,
        -π / 2
    ]);
    function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
        return {
            lineStart: function() {
                listener.lineStart();
                clean = 1;
            },
            point: function(λ1, φ1) {
                var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
                if (abs(dλ - π) < ε) {
                    listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    listener.point(λ1, φ0);
                    clean = 0;
                } else if (sλ0 !== sλ1 && dλ >= π) {
                    if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
                    if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
                    φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    clean = 0;
                }
                listener.point(λ0 = λ1, φ0 = φ1);
                sλ0 = sλ1;
            },
            lineEnd: function() {
                listener.lineEnd();
                λ0 = φ0 = NaN;
            },
            clean: function() {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
            φ = direction * halfπ;
            listener.point(-π, φ);
            listener.point(0, φ);
            listener.point(π, φ);
            listener.point(π, 0);
            listener.point(π, -φ);
            listener.point(0, -φ);
            listener.point(-π, -φ);
            listener.point(-π, 0);
            listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
            var s = from[0] < to[0] ? π : -π;
            φ = direction * s / 2;
            listener.point(-s, φ);
            listener.point(0, φ);
            listener.point(s, φ);
        } else listener.point(to[0], to[1]);
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [
            Math.sin(meridian),
            -Math.cos(meridian),
            0
        ], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for(var i = 0, n = polygon.length; i < n; ++i){
            var ring = polygon[i], m = ring.length;
            if (!m) continue;
            var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
            while(true){
                if (j === m) j = 0;
                point = ring[j];
                var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
                d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
                polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
                if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) winding += antimeridian ^ dλ >= 0 ? 1 : -1;
                }
                if (!j++) break;
                λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
            }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        function visible(λ, φ) {
            return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function(λ, φ) {
                    var point1 = [
                        λ,
                        φ
                    ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code1(λ, φ) : v ? code1(λ + (λ < 0 ? π : -π), φ) : 0;
                    if (!point0 && (v00 = v0 = v)) listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ε;
                            point1[1] += ε;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function() {
                    if (v0) listener.lineEnd();
                    point0 = null;
                },
                clean: function() {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [
                1,
                0,
                0
            ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0) return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two) return q;
            var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
            if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
            var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
            if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
            if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [
                    q,
                    d3_geo_spherical(q1)
                ];
            }
        }
        function code1(λ, φ) {
            var r = smallRadius ? radius : π - radius, code = 0;
            if (λ < -r) code |= 1;
            else if (λ > r) code |= 2;
            if (φ < -r) code |= 4;
            else if (φ > r) code |= 8;
            return code;
        }
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [
            0,
            -radius
        ] : [
            -π,
            radius - π
        ]);
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0) return;
            r /= dx;
            if (dx < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dx > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0) return;
            r /= dx;
            if (dx < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dx > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0) return;
            r /= dy;
            if (dy < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dy > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0) return;
            r /= dy;
            if (dy < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dy > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            if (t0 > 0) line.a = {
                x: ax + t0 * dx,
                y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
                x: ax + t1 * dx,
                y: ay + t1 * dy
            };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1000000000;
    d3.geo.clipExtent = function() {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
            stream: function(output) {
                if (stream) stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
            },
            extent: function(_) {
                if (!arguments.length) return [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream) stream.valid = false, stream = null;
                return clipExtent;
            }
        };
        return clipExtent.extent([
            [
                0,
                0
            ],
            [
                960,
                500
            ]
        ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        function corner(p, direction) {
            return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
        return function(listener1) {
            var listener_ = listener1, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    listener1 = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function() {
                    listener1 = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([
                        x0,
                        y1
                    ]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener1.polygonStart();
                        if (inside) {
                            listener1.lineStart();
                            interpolate(null, null, 1, listener1);
                            listener1.lineEnd();
                        }
                        if (visible) d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener1);
                        listener1.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for(var i = 0; i < n; ++i)for(var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j){
                    b = v[j];
                    if (a[1] <= y) {
                        if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                    } else if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                    a = b;
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) do listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                while ((a = (a + direction + 4) % 4) !== a1)
                else listener.point(to[0], to[1]);
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y)) listener1.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon) polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_) bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_) listener1.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon) ring.push([
                    x,
                    y
                ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener1.lineStart();
                        listener1.point(x, y);
                    }
                } else if (v && v_) listener1.point(x, y);
                else {
                    var l = {
                        a: {
                            x: x_,
                            y: y_
                        },
                        b: {
                            x: x,
                            y: y
                        }
                    };
                    if (clipLine(l)) {
                        if (!v_) {
                            listener1.lineStart();
                            listener1.point(l.a.x, l.a.y);
                        }
                        listener1.point(l.b.x, l.b.y);
                        if (!v) listener1.lineEnd();
                        clean = false;
                    } else if (v) {
                        listener1.lineStart();
                        listener1.point(x, y);
                        clean = false;
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
    }
    function d3_geo_conic(projectAt) {
        var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
        p.parallels = function(_) {
            if (!arguments.length) return [
                φ0 / π * 180,
                φ1 / π * 180
            ];
            return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
            var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
            return [
                ρ * Math.sin(λ *= n),
                ρ0 - ρ * Math.cos(λ)
            ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = ρ0 - y;
            return [
                Math.atan2(x, ρ0_y) / n,
                d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))
            ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([
            96,
            0
        ]).center([
            -0.6,
            38.7
        ]).parallels([
            29.5,
            45.5
        ]).scale(1070);
    };
    d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([
            154,
            0
        ]).center([
            -2,
            58.5
        ]).parallels([
            55,
            65
        ]);
        var hawaii = d3.geo.conicEqualArea().rotate([
            157,
            0
        ]).center([
            -3,
            19.9
        ]).parallels([
            8,
            18
        ]);
        var point, pointStream = {
            point: function(x, y) {
                point = [
                    x,
                    y
                ];
            }
        }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function(coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function(x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function() {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function() {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function() {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function() {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function() {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function(_) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function(_) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * 0.35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([
                [
                    x - 0.455 * k,
                    y - 0.238 * k
                ],
                [
                    x + 0.455 * k,
                    y + 0.238 * k
                ]
            ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([
                x - 0.307 * k,
                y + 0.201 * k
            ]).clipExtent([
                [
                    x - 0.425 * k + ε,
                    y + 0.12 * k + ε
                ],
                [
                    x - 0.214 * k - ε,
                    y + 0.234 * k - ε
                ]
            ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([
                x - 0.205 * k,
                y + 0.212 * k
            ]).clipExtent([
                [
                    x - 0.214 * k + ε,
                    y + 0.166 * k + ε
                ],
                [
                    x - 0.115 * k - ε,
                    y + 0.234 * k - ε
                ]
            ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
    };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function(x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function() {
                if (buffer.length) {
                    var result = buffer.join("");
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push("Z");
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var δ2 = 0.5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample1(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(λ, φ) {
                var c = d3_geo_cartesian([
                    λ,
                    φ
                ]), p = project(λ, φ);
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(λ, φ) {
                linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * δ2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample1.precision = function(_) {
            if (!arguments.length) return Math.sqrt(δ2);
            maxDepth = (δ2 = _ * _) > 0 && 16;
            return resample1;
        };
        return resample1;
    }
    d3.geo.path = function() {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function(object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [
                d3_geo_centroidX2 / d3_geo_centroidZ2,
                d3_geo_centroidY2 / d3_geo_centroidZ2
            ] : d3_geo_centroidZ1 ? [
                d3_geo_centroidX1 / d3_geo_centroidZ1,
                d3_geo_centroidY1 / d3_geo_centroidZ1
            ] : d3_geo_centroidZ0 ? [
                d3_geo_centroidX0 / d3_geo_centroidZ0,
                d3_geo_centroidY0 / d3_geo_centroidZ0
            ] : [
                NaN,
                NaN
            ];
        };
        path.bounds = function(object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [
                [
                    d3_geo_pathBoundsX0,
                    d3_geo_pathBoundsY0
                ],
                [
                    d3_geo_pathBoundsX1,
                    d3_geo_pathBoundsY1
                ]
            ];
        };
        path.projection = function(_) {
            if (!arguments.length) return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function(_) {
            if (!arguments.length) return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function(_) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
            return project([
                x * d3_degrees,
                y * d3_degrees
            ]);
        });
        return function(stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function(methods) {
        return {
            stream: function(stream) {
                var transform = new d3_geo_transform(stream);
                for(var k in methods)transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function(x, y) {
            this.stream.point(x, y);
        },
        sphere: function() {
            this.stream.sphere();
        },
        lineStart: function() {
            this.stream.lineStart();
        },
        lineEnd: function() {
            this.stream.lineEnd();
        },
        polygonStart: function() {
            this.stream.polygonStart();
        },
        polygonEnd: function() {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function() {
                stream.sphere();
            },
            lineStart: function() {
                stream.lineStart();
            },
            lineEnd: function() {
                stream.lineEnd();
            },
            polygonStart: function() {
                stream.polygonStart();
            },
            polygonEnd: function() {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
            x = project(x, y);
            return [
                x[0] * k + δx,
                δy - x[1] * k
            ];
        }), k = 150, x1 = 480, y1 = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [
                point[0] * k + δx,
                δy - point[1] * k
            ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
            return point && [
                point[0] * d3_degrees,
                point[1] * d3_degrees
            ];
        }
        projection.stream = function(output) {
            if (stream) stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function(_) {
            if (!arguments.length) return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function(_) {
            if (!arguments.length) return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function(_) {
            if (!arguments.length) return k;
            k = +_;
            return reset();
        };
        projection.translate = function(_) {
            if (!arguments.length) return [
                x1,
                y1
            ];
            x1 = +_[0];
            y1 = +_[1];
            return reset();
        };
        projection.center = function(_) {
            if (!arguments.length) return [
                λ * d3_degrees,
                φ * d3_degrees
            ];
            λ = _[0] % 360 * d3_radians;
            φ = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function(_) {
            if (!arguments.length) return [
                δλ * d3_degrees,
                δφ * d3_degrees,
                δγ * d3_degrees
            ];
            δλ = _[0] % 360 * d3_radians;
            δφ = _[1] % 360 * d3_radians;
            δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
            var center = project(λ, φ);
            δx = x1 - center[0] * k;
            δy = y1 + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream) stream.valid = false, stream = null;
            return projection;
        }
        return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(λ, φ) {
        return [
            λ,
            φ
        ];
    }
    (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(λ, φ) {
        return [
            λ > π ? λ - τ : λ < -π ? λ + τ : λ,
            φ
        ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
            return λ += δλ, [
                λ > π ? λ - τ : λ < -π ? λ + τ : λ,
                φ
            ];
        };
    }
    function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
    }
    function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
            return [
                Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ),
                d3_asin(k * cosδγ + y * sinδγ)
            ];
        }
        rotation.invert = function(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
            return [
                Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ),
                d3_asin(k * cosδφ - x * sinδφ)
            ];
        };
        return rotation;
    }
    d3.geo.circle = function() {
        var origin = [
            0,
            0
        ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function(x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: "Polygon",
                coordinates: [
                    ring
                ]
            };
        }
        circle.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return circle;
        };
        circle.angle = function(x) {
            if (!arguments.length) return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function(_) {
            if (!arguments.length) return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function(from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to) from += direction * τ;
            } else {
                from = radius + direction * τ;
                to = radius - 0.5 * step;
            }
            for(var point, t = from; direction > 0 ? t > to : t < to; t -= step)listener.point((point = d3_geo_spherical([
                cr,
                -sr * Math.cos(t),
                -sr * Math.sin(t)
            ]))[0], point[1]);
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
    }
    d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
    };
    d3.geo.graticule = function() {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                return abs(x % DX) > ε;
            }).map(x2)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                return abs(y % DY) > ε;
            }).map(y2));
        }
        graticule.lines = function() {
            return lines().map(function(coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [
                    X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))
                ]
            };
        };
        graticule.extent = function(_) {
            if (!arguments.length) return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
            if (!arguments.length) return [
                [
                    X0,
                    Y0
                ],
                [
                    X1,
                    Y1
                ]
            ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1) _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
            if (!arguments.length) return [
                [
                    x0,
                    y0
                ],
                [
                    x1,
                    y1
                ]
            ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1) _ = x0, x0 = x1, x1 = _;
            if (y0 > y1) _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function(_) {
            if (!arguments.length) return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
            if (!arguments.length) return [
                DX,
                DY
            ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function(_) {
            if (!arguments.length) return [
                dx,
                dy
            ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function(_) {
            if (!arguments.length) return precision;
            precision = +_;
            x2 = d3_geo_graticuleX(y0, y1, 90);
            y2 = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([
            [
                -180,
                -90 + ε
            ],
            [
                180,
                90 - ε
            ]
        ]).minorExtent([
            [
                -180,
                -80 - ε
            ],
            [
                180,
                80 + ε
            ]
        ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y3 = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
            return y3.map(function(y) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x3 = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
            return x3.map(function(x) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function() {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: "LineString",
                coordinates: [
                    source_ || source.apply(this, arguments),
                    target_ || target.apply(this, arguments)
                ]
            };
        }
        greatArc.distance = function() {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
            if (!arguments.length) return source;
            source = _, source_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.target = function(_) {
            if (!arguments.length) return target;
            target = _, target_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.precision = function() {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [
                Math.atan2(y, x) * d3_degrees,
                Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees
            ];
        } : function() {
            return [
                x0 * d3_degrees,
                y0 * d3_degrees
            ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function(λ, φ) {
            λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
            var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
            var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
            return [
                k * cosφ * Math.sin(λ),
                k * Math.sin(φ)
            ];
        }
        azimuthal.invert = function(x, y) {
            var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
            return [
                Math.atan2(x * sinc, ρ * cosc),
                Math.asin(ρ && y * sinc / ρ)
            ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
    }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
    });
    (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), t = function(φ) {
            return Math.tan(π / 4 + φ / 2);
        }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n) return d3_geo_mercator;
        function forward(λ, φ) {
            if (F > 0) {
                if (φ < -halfπ + ε) φ = -halfπ + ε;
            } else if (φ > halfπ - ε) φ = halfπ - ε;
            var ρ = F / Math.pow(t(φ), n);
            return [
                ρ * Math.sin(n * λ),
                F - ρ * Math.cos(n * λ)
            ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
            return [
                Math.atan2(x, ρ0_y) / n,
                2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ
            ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
        if (abs(n) < ε) return d3_geo_equirectangular;
        function forward(λ, φ) {
            var ρ = G - φ;
            return [
                ρ * Math.sin(n * λ),
                G - ρ * Math.cos(n * λ)
            ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = G - y;
            return [
                Math.atan2(x, ρ0_y) / n,
                G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)
            ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
    }, Math.atan);
    (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(λ, φ) {
        return [
            λ,
            Math.log(Math.tan(π / 4 + φ / 2))
        ];
    }
    d3_geo_mercator.invert = function(x, y) {
        return [
            x,
            2 * Math.atan(Math.exp(y)) - halfπ
        ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function() {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = π * scale(), t = translate();
                    clipExtent([
                        [
                            t[0] - k,
                            t[1] - k
                        ],
                        [
                            t[0] + k,
                            t[1] + k
                        ]
                    ]);
                }
            } else if (clipAuto) v = null;
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
    }, function(ρ) {
        return 2 * Math.atan(ρ);
    });
    (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(λ, φ) {
        return [
            Math.log(Math.tan(π / 4 + φ / 2)),
            -λ
        ];
    }
    d3_geo_transverseMercator.invert = function(x, y) {
        return [
            -y,
            2 * Math.atan(Math.exp(x)) - halfπ
        ];
    };
    (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function(_) {
            return _ ? center([
                -_[1],
                _[0]
            ]) : (_ = center(), [
                _[1],
                -_[0]
            ]);
        };
        projection.rotate = function(_) {
            return _ ? rotate([
                _[0],
                _[1],
                _.length > 2 ? _[2] + 90 : 90
            ]) : (_ = rotate(), [
                _[0],
                _[1],
                _[2] - 90
            ]);
        };
        return rotate([
            0,
            0,
            90
        ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {
    };
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length) return hull(vertices);
        function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for(i = 0; i < n; i++)points.push([
                +fx.call(this, data[i], i),
                +fy.call(this, data[i], i),
                i
            ]);
            points.sort(d3_geom_hullOrder);
            for(i = 0; i < n; i++)flippedPoints.push([
                points[i][0],
                -points[i][1]
            ]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for(i = upper.length - 1; i >= 0; --i)polygon.push(data[points[upper[i]][2]]);
            for(i = +skipLeft; i < lower.length - skipRight; ++i)polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [
            0,
            1
        ], hs = 2;
        for(var i = 2; i < n; i++){
            while(hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)--hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function() {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while(++i < n){
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * 0.5;
    };
    d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length) k = -1 / (6 * this.area());
        while(++i < n){
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [
            x * k,
            y * k
        ];
    };
    d3_geom_polygonPrototype.clip = function(subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while(++i < n){
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while(++j < m){
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) subject.push(d3_geom_polygonIntersect(c, d, a, b));
                c = d;
            }
            if (closed) subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [
            x1 + ua * x21,
            y1 + ua * y21
        ];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x: x,
            y: y
        }, previous = beach.P, next = beach.N, disappearing = [
            beach
        ];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while(lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε){
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while(rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε){
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for(iArc = 1; iArc < nArcs; ++iArc){
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while(node){
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > ε) node = node.L;
            else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > ε) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -ε) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -ε) {
                        lArc = node;
                        rArc = node.N;
                    } else lArc = rArc = node;
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while(iHalfEdge--){
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while(iCell--){
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while(iHalfEdge < nHalfEdges){
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                        x: x0,
                        y: abs(x2 - x0) < ε ? y2 : y1
                    } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                        x: abs(y2 - y1) < ε ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                        x: x1,
                        y: abs(x2 - x1) < ε ? y2 : y0
                    } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                        x: abs(y2 - y0) < ε ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2) return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while(node){
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L) node = node.L;
                else {
                    before = node.P;
                    break;
                }
            } else if (node.R) node = node.R;
            else {
                before = node;
                break;
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before) d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while(i--){
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb) return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
                if (!va) va = {
                    x: fx,
                    y: y0
                };
                else if (va.y >= y1) return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va) va = {
                    x: fx,
                    y: y1
                };
                else if (va.y < y0) return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va) va = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                    else if (va.y >= y1) return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va) va = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                    else if (va.y < y0) return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else if (ly < ry) {
                if (!va) va = {
                    x: x0,
                    y: fm * x0 + fb
                };
                else if (va.x >= x1) return;
                vb = {
                    x: x1,
                    y: fm * x1 + fb
                };
            } else {
                if (!va) va = {
                    x: x1,
                    y: fm * x1 + fb
                };
                else if (va.x < x0) return;
                vb = {
                    x: x0,
                    y: fm * x0 + fb
                };
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) edge.b = vertex;
        else edge.a = vertex;
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N) after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while(after.L)after = after.L;
                    after.L = node;
                } else after.R = node;
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while(parent && parent.C){
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left) next = right;
            else if (!right) next = left;
            else next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node) parent.L = next;
                else parent.R = next;
            } else this._ = next;
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._) break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            }while (!node.C)
            if (node) node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
        } else tree._ = q;
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
        } else tree._ = q;
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while(node.L)node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while(true){
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) d3_geom_voronoiRemoveBeach(circle.arc);
            else break;
        }
        if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points) return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                    var s = e.start();
                    return [
                        s.x,
                        s.y
                    ];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [
                    [
                        x0,
                        y1
                    ],
                    [
                        x1,
                        y1
                    ],
                    [
                        x1,
                        y0
                    ],
                    [
                        x0,
                        y0
                    ]
                ] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function(d, i) {
                return {
                    x: Math.round(fx(d, i) / ε) * ε,
                    y: Math.round(fy(d, i) / ε) * ε,
                    i: i
                };
            });
        }
        voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
                return edge.l && edge.r;
            }).map(function(edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while(++j < m){
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) triangles.push([
                        data[i],
                        data[s0.i],
                        data[s1.i]
                    ]);
                }
            });
            return triangles;
        };
        voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [
                [
                    0,
                    0
                ],
                _
            ]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [
        [
            -1000000,
            -1000000
        ],
        [
            1000000,
            1000000
        ]
    ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function(points, x11, y11, x21, y21) {
        var x4 = d3_geom_pointX, y4 = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x4 = d3_geom_quadtreeCompatX;
            y4 = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y21 = y11;
                x21 = x11;
                y11 = x11 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d2, fx = d3_functor(x4), fy = d3_functor(y4), xs, ys, i, n4, x1_, y1_, x2_, y2_;
            if (x11 != null) x1_ = x11, y1_ = y11, x2_ = x21, y2_ = y21;
            else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n4 = data.length;
                if (compat) for(i = 0; i < n4; ++i){
                    d2 = data[i];
                    if (d2.x < x1_) x1_ = d2.x;
                    if (d2.y < y1_) y1_ = d2.y;
                    if (d2.x > x2_) x2_ = d2.x;
                    if (d2.y > y2_) y2_ = d2.y;
                    xs.push(d2.x);
                    ys.push(d2.y);
                }
                else for(i = 0; i < n4; ++i){
                    var x_ = +fx(d2 = data[i], i), y_ = +fy(d2, i);
                    if (x_ < x1_) x1_ = x_;
                    if (y_ < y1_) y1_ = y_;
                    if (x_ > x2_) x2_ = x_;
                    if (y_ > y2_) y2_ = y_;
                    xs.push(x_);
                    ys.push(y_);
                }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx;
            else x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y)) return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < 0.01) insertChild(n, d, x, y, x1, y1, x2, y2);
                        else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else n.x = x, n.y = y, n.point = d;
                } else insertChild(n, d, x, y, x1, y1, x2, y2);
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right) x1 = xm;
                else x2 = xm;
                if (below) y1 = ym;
                else y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x11 == null) {
                while(++i < n4)insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                --i;
            } else data.forEach(root.add);
            xs = ys = data = d2 = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x4 = _, quadtree) : x4;
        };
        quadtree.y = function(_) {
            return arguments.length ? (y4 = _, quadtree) : y4;
        };
        quadtree.extent = function(_) {
            if (!arguments.length) return x11 == null ? null : [
                [
                    x11,
                    y11
                ],
                [
                    x21,
                    y21
                ]
            ];
            if (_ == null) x11 = y11 = x21 = y21 = null;
            else x11 = +_[0][0], y11 = +_[0][1], x21 = +_[1][0], y21 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function(_) {
            if (!arguments.length) return x11 == null ? null : [
                x21 - x11,
                y21 - y11
            ];
            if (_ == null) x11 = y11 = x21 = y21 = null;
            else x11 = y11 = 0, x21 = +_[0], y21 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym;
            for(var i = below << 1 | right, j = i + 4; i < j; ++i)if (node = children[i & 3]) switch(i & 3){
                case 0:
                    find(node, x1, y1, xm, ym);
                    break;
                case 1:
                    find(node, xm, y1, x2, ym);
                    break;
                case 2:
                    find(node, x1, ym, xm, y2);
                    break;
                case 3:
                    find(node, xm, ym, x2, y2);
                    break;
            }
        })(root, x0, y0, x3, y3);
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {
        }, c = {
        }, k;
        for(k in a)if (k in b) i[k] = d3_interpolate(a[k], b[k]);
        else c[k] = a[k];
        for(k in b)if (!(k in a)) c[k] = b[k];
        return function(t) {
            for(k in i)c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i4 = -1, s = [], q = [];
        a = a + "", b = b + "";
        while((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))){
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i4]) s[i4] += bs;
                else s[++i4] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i4]) s[i4] += bm;
                else s[++i4] = bm;
            } else {
                s[++i4] = null;
                q.push({
                    i: i4,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i4]) s[i4] += bs;
            else s[++i4] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
        }) : function() {
            return b;
        } : (b = q.length, function(t) {
            for(var i = 0, o; i < b; ++i)s[(o = q[i]).i] = o.x(t);
            return s.join("");
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while(--i >= 0 && !(f = d3.interpolators[i](a, b)));
        return f;
    }
    d3.interpolators = [
        function(a, b) {
            var t = typeof b;
            return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }
    ];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for(i = 0; i < n0; ++i)x.push(d3_interpolate(a[i], b[i]));
        for(; i < na; ++i)c[i] = a[i];
        for(; i < nb; ++i)c[i] = b[i];
        return function(t) {
            for(i = 0; i < n0; ++i)c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function(name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) p = 0.45;
        if (arguments.length) s = p / τ * Math.asin(1 / a);
        else a = 1, s = p / 4;
        return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
    }
    function d3_ease_back(s) {
        if (!s) s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180) bh -= 360;
        else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180) bh -= 360;
        else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function(string1) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string1);
    };
    function d3_transform(m) {
        var r0 = [
            m.a,
            m.b
        ], r1 = [
            m.c,
            m.d
        ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [
            m.e,
            m.f
        ];
        this.scale = [
            kx,
            ky
        ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + "," : "";
    }
    function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push("translate(", null, ",", null, ")");
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) s.push("translate(" + tb + ")");
    }
    function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
            if (ra - rb > 180) rb += 360;
            else if (rb - ra > 180) ra += 360;
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
    function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) q.push({
            i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
            x: d3_interpolateNumber(wa, wb)
        });
        else if (wb) s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
    function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] !== 1 || kb[1] !== 1) s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
    function d3_interpolateTransform(a, b) {
        var s = [], q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function(t) {
            var i = -1, n = q.length, o;
            while(++i < n)s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {
    };
    d3.layout.bundle = function() {
        return function(links) {
            var paths = [], i = -1, n = links.length;
            while(++i < n)paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [
            start
        ];
        while(start !== lca){
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while(end !== lca){
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while(parent != null){
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while(aNode === bNode){
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function() {
        var chord = {
        }, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {
            }, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while(++i < n){
                x = 0, j = -1;
                while(++j < n)x += matrix[i][j];
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) groupIndex.sort(function(a, b) {
                return sortGroups(groupSums[a], groupSums[b]);
            });
            if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
                d.sort(function(a, b) {
                    return sortSubgroups(matrix[i][a], matrix[i][b]);
                });
            });
            k = (τ - padding * n) / k;
            x = 0, i = -1;
            while(++i < n){
                x0 = x, j = -1;
                while(++j < n){
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + "-" + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: groupSums[di]
                };
                x += padding;
            }
            i = -1;
            while(++i < n){
                j = i - 1;
                while(++j < n){
                    var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                    if (source.value || target.value) chords.push(source.value < target.value ? {
                        source: target,
                        target: source
                    } : {
                        source: source,
                        target: target
                    });
                }
            }
            if (sortChords) resort();
        }
        function resort() {
            chords.sort(function(a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
        };
        chord.chords = function() {
            if (!chords) relayout();
            return chords;
        };
        chord.groups = function() {
            if (!groups) relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function() {
        var force = {
        }, event = d3.dispatch("start", "tick", "end"), timer, size1 = [
            1,
            1
        ], drag, alpha, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function() {
            if ((alpha *= 0.99) < 0.005) {
                timer = null;
                event.end({
                    type: "end",
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for(i = 0; i < m; ++i){
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : 0.5);
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size1[0] / 2;
                y = size1[1] / 2;
                i = -1;
                if (k) while(++i < n){
                    o = nodes[i];
                    o.x += (x - o.x) * k;
                    o.y += (y - o.y) * k;
                }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while(++i < n)if (!(o = nodes[i]).fixed) q.visit(repulse(o));
            }
            i = -1;
            while(++i < n){
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: "tick",
                alpha: alpha
            });
        };
        force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
        };
        force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
        };
        force.size = function(x) {
            if (!arguments.length) return size1;
            size1 = x;
            return force;
        };
        force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
        };
        force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.chargeDistance = function(x) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function(x) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) alpha = x;
                else {
                    timer.c = null, timer.t = NaN, timer = null;
                    event.end({
                        type: "end",
                        alpha: alpha = 0
                    });
                }
            } else if (x > 0) {
                event.start({
                    type: "start",
                    alpha: alpha = x
                });
                timer = d3_timer(force.tick);
            }
            return force;
        };
        force.start = function() {
            var i, n = nodes.length, m = links.length, w = size1[0], h = size1[1], neighbors, o1;
            for(i = 0; i < n; ++i){
                (o1 = nodes[i]).index = i;
                o1.weight = 0;
            }
            for(i = 0; i < m; ++i){
                o1 = links[i];
                if (typeof o1.source == "number") o1.source = nodes[o1.source];
                if (typeof o1.target == "number") o1.target = nodes[o1.target];
                ++o1.source.weight;
                ++o1.target.weight;
            }
            for(i = 0; i < n; ++i){
                o1 = nodes[i];
                if (isNaN(o1.x)) o1.x = position("x", w);
                if (isNaN(o1.y)) o1.y = position("y", h);
                if (isNaN(o1.px)) o1.px = o1.x;
                if (isNaN(o1.py)) o1.py = o1.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for(i = 0; i < m; ++i)distances[i] = +linkDistance.call(this, links[i], i);
            else for(i = 0; i < m; ++i)distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for(i = 0; i < m; ++i)strengths[i] = +linkStrength.call(this, links[i], i);
            else for(i = 0; i < m; ++i)strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for(i = 0; i < n; ++i)charges[i] = +charge.call(this, nodes[i], i);
            else for(i = 0; i < n; ++i)charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for(j = 0; j < n; ++j)neighbors[j] = [];
                    for(j = 0; j < m; ++j){
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while(++j < l)if (!isNaN(x = candidates[j][dimension])) return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function() {
            return force.alpha(0.1);
        };
        force.stop = function() {
            return force.alpha(0);
        };
        force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, "on");
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= -7;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= -5;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while(++i < n){
                c = nodes[i];
                if (c == null) continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - 0.5;
                quad.point.y += Math.random() - 0.5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [
                root
            ], nodes = [], node2;
            root.depth = 0;
            while((node2 = stack.pop()) != null){
                nodes.push(node2);
                if ((childs = children.call(hierarchy, node2, node2.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while(--n >= 0){
                        stack.push(child = childs[n]);
                        child.parent = node2;
                        child.depth = node2.depth + 1;
                    }
                    if (value) node2.value = 0;
                    node2.children = childs;
                } else {
                    if (value) node2.value = +value.call(hierarchy, node2, node2.depth) || 0;
                    delete node2.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var childs, parent;
                if (sort && (childs = node.children)) childs.sort(sort);
                if (value && (parent = node.parent)) parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function(root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function(node) {
                    if (node.children) node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var parent;
                    if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent) parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [
            node
        ];
        while((node = nodes.pop()) != null){
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while(--n >= 0)nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [
            node
        ], nodes2 = [];
        while((node = nodes.pop()) != null){
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while(++i < n)nodes.push(children[i]);
            }
        }
        while((node = nodes2.pop()) != null)callback(node);
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(), size = [
            1,
            1
        ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while(++i < n){
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while(++i < n)d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function() {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function(d, i) {
                return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                return values[j] - values[i];
            } : function(i, j) {
                return sort(data[i], data[j]);
            });
            index.forEach(function(i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function(_) {
            if (!arguments.length) return value;
            value = _;
            return pie;
        };
        pie.sort = function(_) {
            if (!arguments.length) return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function(_) {
            if (!arguments.length) return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {
    };
    d3.layout.stack = function() {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x5 = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length)) return data;
            var series = data.map(function(d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function(d) {
                return d.map(function(v, i) {
                    return [
                        x5.call(stack, v, i),
                        y.call(stack, v, i)
                    ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i5, j, o;
            for(j = 0; j < m; ++j){
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for(i5 = 1; i5 < n; ++i5)out.call(stack, series[i5][j], o += points[i5 - 1][j][1], points[i5][j][1]);
            }
            return data;
        }
        stack.values = function(x) {
            if (!arguments.length) return values;
            values = x;
            return stack;
        };
        stack.order = function(x) {
            if (!arguments.length) return order;
            order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function(x) {
            if (!arguments.length) return offset;
            offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function(z) {
            if (!arguments.length) return x5;
            x5 = z;
            return stack;
        };
        stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
        };
        stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for(i = 0; i < n; ++i){
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
            return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for(j = 0; j < m; ++j){
                for(i = 0, o = 0; i < n; i++)o += data[i][j][1];
                if (o > max) max = o;
                sums.push(o);
            }
            for(j = 0; j < m; ++j)y0[j] = (max - sums[j]) / 2;
            return y0;
        },
        wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for(j = 1; j < m; ++j){
                for(i = 0, s1 = 0; i < n; ++i)s1 += data[i][j][1];
                for(i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i){
                    for(k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k)s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0) o0 = o;
            }
            for(j = 0; j < m; ++j)y0[j] -= o0;
            return y0;
        },
        expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for(j = 0; j < m; ++j){
                for(i = 0, o = 0; i < n; i++)o += data[i][j][1];
                if (o) for(i = 0; i < n; i++)data[i][j][1] /= o;
                else for(i = 0; i < n; i++)data[i][j][1] = k;
            }
            for(j = 0; j < m; ++j)y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while(++j < m)y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for(; i < n; ++i)if ((k = array[i][1]) > v) {
            j = i;
            v = k;
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function() {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while(++i < m){
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while(++i < n){
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while(++x <= n)f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [
            d3.min(values),
            d3.max(values)
        ];
    }
    d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [
            1,
            1
        ], radius;
        function pack(d4, i) {
            var nodes = hierarchy.call(this, d4, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return pack;
        };
        pack.radius = function(_) {
            if (!arguments.length) return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
        };
        pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return 0.999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node3) {
        if (!(nodes = node3.children) || !(n = nodes.length)) return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for(i = 3; i < n; i++){
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for(j = b._pack_next; j !== b; j = j._pack_next, s1++)if (d3_layout_packIntersects(j, c)) {
                        isect = 1;
                        break;
                    }
                    if (isect == 1) for(k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++){
                        if (d3_layout_packIntersects(k, c)) break;
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);
                        else d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for(i = 0; i < n; i++){
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node3.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while(++i < n)d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = 0.5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
            1,
            1
        ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    if (node.x < left.x) left = node;
                    if (node.x > right.x) right = node;
                    if (node.depth > bottom.depth) bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                A: null,
                children: [
                    root0
                ]
            }, queue = [
                root1
            ], node1;
            while((node1 = queue.pop()) != null)for(var children = node1.children, child, i = 0, n = children.length; i < n; ++i)queue.push((children[i] = child = {
                _: children[i],
                parent: node1,
                children: (child = children[i].children) && child.slice() || [],
                A: null,
                a: null,
                z: 0,
                m: 0,
                c: 0,
                s: 0,
                t: null,
                i: i
            }).a = child);
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else v.z = midpoint;
            } else if (w) v.z = w.z + separation(v._, w._);
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while(vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip){
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
        };
        tree.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while(--i >= 0){
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
            1,
            1
        ], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [
            1,
            1
        ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = 0.5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while(++i < n){
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while((n = remaining.length) > 0){
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while(child = remaining.pop()){
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while(++i < n){
                if (!(r = row[i].area)) continue;
                if (r < rmin) rmin = r;
                if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy) v = rect.dy;
                while(++i < n){
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx) v = rect.dx;
                while(++i < n){
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value) root.dx = size[0], root.dy = size[1];
            else root.dx = root.dy = 0;
            if (stickies) hierarchy.revalue(root);
            scale([
                root
            ], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
        };
        treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [
                    p,
                    p,
                    p,
                    p
                ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [
                x,
                x,
                x,
                x
            ], padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function(µ, σ) {
            var n = arguments.length;
            if (n < 2) σ = 1;
            if (n < 1) µ = 0;
            return function() {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                }while (!r || r > 1)
                return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
                return Math.exp(random());
            };
        },
        bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
                return random() / m;
            };
        },
        irwinHall: function(m) {
            return function() {
                for(var s = 0, j = 0; j < m; j++)s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {
    };
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [
            start,
            stop
        ] : [
            stop,
            start
        ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function(x) {
                return Math.floor(x / step) * step;
            },
            ceil: function(x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while(++j <= k){
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function() {
        return d3_scale_linear([
            0,
            1
        ], [
            0,
            1
        ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null) m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= 0.15) step *= 10;
        else if (err <= 0.35) step *= 5;
        else if (err <= 0.75) step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === "s") {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = "f";
                format = d3.format(match.join(""));
                return function(d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join("");
        } else format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
    }
    d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([
            0,
            1
        ]), 10, true, [
            1,
            10
        ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for(; i < j; i++)for(var k = 1; k < n; k++)ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for(; (i++) < j;)for(var k = n - 1; k > 0; k--)ticks.push(pow(i) * k);
                }
                for(i = 0; ticks[i] < u; i++);
                for(j = ticks.length; ticks[j - 1] > v; j--);
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function(n, format) {
            if (!arguments.length) return d3_scale_logFormat;
            if (arguments.length < 2) format = d3_scale_logFormat;
            else if (typeof format !== "function") format = d3.format(format);
            var k = Math.max(1, base * n / scale.ticks().length);
            return function(d) {
                var i = d / pow(Math.round(log(d)));
                if (i * base < base - 0.5) i *= base;
                return i <= k ? format(d) : "";
            };
        };
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
        floor: function(x) {
            return -Math.ceil(-x);
        },
        ceil: function(x) {
            return -Math.floor(-x);
        }
    };
    d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [
            0,
            1
        ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function(x) {
            return powb(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(0.5);
    };
    d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
            t: "range",
            a: [
                []
            ]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
                return start + step * i;
            });
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while(++i < n)if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: "rangeRoundPoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function() {
            return rangeBand;
        };
        scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [
        2062260,
        16744206,
        2924588,
        14034728,
        9725885,
        9197131,
        14907330,
        8355711,
        12369186,
        1556175
    ].map(d3_rgbString);
    var d3_category20 = [
        2062260,
        11454440,
        16744206,
        16759672,
        2924588,
        10018698,
        14034728,
        16750742,
        9725885,
        12955861,
        9197131,
        12885140,
        14907330,
        16234194,
        8355711,
        13092807,
        12369186,
        14408589,
        1556175,
        10410725
    ].map(d3_rgbString);
    var d3_category20b = [
        3750777,
        5395619,
        7040719,
        10264286,
        6519097,
        9216594,
        11915115,
        13556636,
        9202993,
        12426809,
        15186514,
        15190932,
        8666169,
        11356490,
        14049643,
        15177372,
        8077683,
        10834324,
        13528509,
        14589654
    ].map(d3_rgbString);
    var d3_category20c = [
        3244733,
        7057110,
        10406625,
        13032431,
        15095053,
        16616764,
        16625259,
        16634018,
        3253076,
        7652470,
        10607003,
        13101504,
        7695281,
        10394312,
        12369372,
        14342891,
        6513507,
        9868950,
        12434877,
        14277081
    ].map(d3_rgbString);
    d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while(++k < q)thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function() {
            return thresholds;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [
                NaN,
                NaN
            ] : [
                y > 0 ? thresholds[y - 1] : domain[0],
                y < thresholds.length ? thresholds[y] : domain[domain.length - 1]
            ];
        };
        scale.copy = function() {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [
            0,
            1
        ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length) return [
                x0,
                x1
            ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [
                y,
                y + 1 / kx
            ];
        };
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function() {
        return d3_scale_threshold([
            0.5
        ], [
            0,
            1
        ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x) return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
        };
        scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [
                domain[y - 1],
                domain[y]
            ];
        };
        scale.copy = function() {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function() {
        return d3_scale_identity([
            0,
            1
        ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {
    };
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw) p1 *= -1;
                if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else x0 = y0 = 0;
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else x2 = y2 = 0;
            if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 0.001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var rc1 = rc, rc0 = rc;
                if (da < π) {
                    var oc = x3 == null ? [
                        x2,
                        y2
                    ] : x1 == null ? [
                        x0,
                        y0
                    ] : d3_geom_polygonIntersect([
                        x0,
                        y0
                    ], [
                        x3,
                        y3
                    ], [
                        x1,
                        y1
                    ], [
                        x2,
                        y2
                    ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                    rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                    rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
                }
                if (x1 != null) {
                    var t30 = d3_svg_arcCornerTangents(x3 == null ? [
                        x2,
                        y2
                    ] : [
                        x3,
                        y3
                    ], [
                        x0,
                        y0
                    ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([
                        x1,
                        y1
                    ], [
                        x2,
                        y2
                    ], r1, rc1, cw);
                    if (rc === rc1) path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                    else path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                } else path.push("M", x0, ",", y0);
                if (x3 != null) {
                    var t03 = d3_svg_arcCornerTangents([
                        x0,
                        y0
                    ], [
                        x3,
                        y3
                    ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([
                        x2,
                        y2
                    ], x1 == null ? [
                        x0,
                        y0
                    ] : [
                        x1,
                        y1
                    ], r0, -rc0, cw);
                    if (rc === rc0) path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    else path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                } else path.push("L", x2, ",", y2);
            } else {
                path.push("M", x0, ",", y0);
                if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                path.push("L", x2, ",", y2);
                if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
        }
        function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function(v) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function(v) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function(v) {
            if (!arguments.length) return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function(v) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
            return [
                Math.cos(a) * r,
                Math.sin(a) * r
            ];
        };
        return arc;
    };
    var d3_svg_arcAuto = "auto";
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
        return [
            [
                cx0 - ox,
                cy0 - oy
            ],
            [
                cx0 * r1 / r,
                cy0 * r1 / r
            ]
        ];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = 0.7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while(++i < n){
                if (defined.call(this, d = data[i], i)) points.push([
                    +fx.call(this, d, i),
                    +fy.call(this, d, i)
                ]);
                else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
        };
        line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
        };
        line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
        };
        line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function() {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join("L") : points + "Z";
    }
    function d3_svg_lineLinearClosed(points) {
        return points.join("L") + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [
            p[0],
            ",",
            p[1]
        ];
        while(++i < n)path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1) path.push("H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [
            p[0],
            ",",
            p[1]
        ];
        while(++i < n)path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [
            p[0],
            ",",
            p[1]
        ];
        while(++i < n)path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([
            points[points.length - 2]
        ].concat(points, [
            points[1]
        ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) return d3_svg_lineLinear(points);
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for(var i = 2; i < tangents.length; i++, pi++){
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while(++i < n){
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([
                a * (p2[0] - p0[0]),
                a * (p2[1] - p0[1])
            ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3) return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [
            x0,
            x0,
            x0,
            (pi = points[1])[0]
        ], py = [
            y0,
            y0,
            y0,
            pi[1]
        ], path = [
            x0,
            ",",
            y0,
            "L",
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
            ",",
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
        ];
        points.push(points[n - 1]);
        while(++i <= n){
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [
            0
        ], py = [
            0
        ];
        while(++i < 3){
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while(++i < n){
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while(++i < 4){
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
            ",",
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
        ];
        --i;
        while(++i < m){
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while(++i <= n){
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [
        0,
        2 / 3,
        1 / 3,
        0
    ], d3_svg_lineBasisBezier2 = [
        0,
        1 / 3,
        2 / 3,
        0
    ], d3_svg_lineBasisBezier3 = [
        0,
        1 / 6,
        2 / 3,
        1 / 6
    ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while(++i < j)m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while(++i < j){
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ε) m[i] = m[i + 1] = 0;
            else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while(++i <= j){
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([
                s || 0,
                m[i] * s || 0
            ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while(++i < n){
            point = points[i];
            r = point[0];
            a = point[1] - halfπ;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = 0.7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while(++i < n){
                if (defined.call(this, d = data[i], i)) {
                    points0.push([
                        x = +fx0.call(this, d, i),
                        y = +fy0.call(this, d, i)
                    ]);
                    points1.push([
                        +fx1.call(this, d, i),
                        +fy1.call(this, d, i)
                    ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
        };
        area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
        };
        area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
        };
        area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
        };
        area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
        };
        area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function() {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function() {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup1(this, source, d, i), t = subgroup1(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup1(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [
                    r * Math.cos(a0),
                    r * Math.sin(a0)
                ],
                p1: [
                    r * Math.cos(a1),
                    r * Math.sin(a1)
                ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function() {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [
                p0,
                {
                    x: p0.x,
                    y: m
                },
                {
                    x: p3.x,
                    y: m
                },
                p3
            ];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [
            d.x,
            d.y
        ];
    }
    d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
            return [
                r * Math.cos(a),
                r * Math.sin(a)
            ];
        };
    }
    d3.svg.symbol = function() {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return "circle";
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
        };
        for(var j = -1, m = this.length; ++j < m;){
            subgroups.push(subgroup = []);
            for(var group = this[j], i = -1, n = group.length; ++i < n;){
                if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function(name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function() {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
                active.timer.c = null;
                active.timer.t = NaN;
                if (--lock.count) delete lock[activeId];
                else delete this[ns];
                lock.active += 0.5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function(selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for(var j = -1, m = this.length; ++j < m;){
            subgroups.push(subgroup = []);
            for(var group = this[j], i = -1, n = group.length; ++i < n;)if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                if ("__data__" in node) subnode.__data__ = node.__data__;
                d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                subgroup.push(subnode);
            } else subgroup.push(null);
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for(var j = -1, m = this.length; ++j < m;){
            for(var group = this[j], i = -1, n = group.length; ++i < n;)if (node = group[i]) {
                transition = node[ns][id];
                subnodes = selector.call(node, node.__data__, i, j);
                subgroups.push(subgroup = []);
                for(var k = -1, o = subnodes.length; ++k < o;){
                    if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                    subgroup.push(subnode);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for(var j = 0, m = this.length; j < m; j++){
            subgroups.push(subgroup = []);
            for(var group = this[j], i = 0, n = group.length; i < n; i++)if ((node = group[i]) && filter.call(node, node.__data__, i, j)) subgroup.push(node);
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
        } : function(node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
            for(value in nameNS)this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for(priority in name)this.style(priority, name[priority], value);
                return this;
            }
            priority = "";
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function(t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3) priority = "";
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween("style." + name, styleTween);
    };
    d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null) b = "";
        return function() {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].ease;
        if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function(type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function(node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            } finally{
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        } else d3_selection_each(this, function(node) {
            var transition = node[ns][id];
            (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
        });
        return this;
    };
    d3_transitionPrototype.transition = function() {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for(var j = 0, m = this.length; j < m; j++){
            subgroups.push(subgroup = []);
            for(var group = this[j], i = 0, n = group.length; i < n; i++){
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
        }), transition = lock[id], time, timer, duration, ease, tweens;
        function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed) return start(elapsed - delay);
            timer.c = start;
        }
        function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
                active.timer.c = null;
                active.timer.t = NaN;
                --lock.count;
                delete lock[activeId];
                active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for(var cancelId in lock)if (+cancelId < id) {
                var cancel = lock[cancelId];
                cancel.timer.c = null;
                cancel.timer.t = NaN;
                --lock.count;
                delete lock[cancelId];
            }
            timer.c = tick;
            d3_timer(function() {
                if (timer.c && tick(elapsed || 1)) {
                    timer.c = null;
                    timer.t = NaN;
                }
                return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function(key, value) {
                if (value = value.call(node, node.__data__, i)) tweens.push(value);
            });
            ease = transition.ease;
            duration = transition.duration;
        }
        function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while(n > 0)tweens[--n].call(node, e);
            if (t >= 1) {
                transition.event && transition.event.end.call(node, node.__data__, i);
                if (--lock.count) delete lock[id];
                else delete node[ns];
                return 1;
            }
        }
        if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                timer: timer,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
        }
    }
    d3.svg.axis = function() {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [
            10
        ], tickValues = null, tickFormat_;
        function axis(g1) {
            g1.each(function() {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([
                    0
                ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
                tickEnter.append("line");
                tickEnter.append("text");
                var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
                if (orient === "bottom" || orient === "top") {
                    tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                    text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                    pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
                } else {
                    tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                    text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                    pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function(d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) scale0 = scale1;
                else tickExit.call(tickTransform, scale1, scale0);
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
        };
        axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
        };
        axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n) return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function(x) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function(x) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function() {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
    }
    d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [
            0,
            0
        ], yExtent = [
            0,
            0
        ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g2) {
            g2.each(function() {
                var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                var background = g.selectAll(".background").data([
                    0
                ]);
                background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                g.selectAll(".extent").data([
                    0
                ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var resize = g.selectAll(".resize").data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append("g").attr("class", function(d) {
                    return "resize " + d;
                }).style("cursor", function(d) {
                    return d3_svg_brushCursor[d];
                }).append("rect").attr("x", function(d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr("y", function(d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                resize.style("display", brush.empty() ? "none" : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function(g) {
            g.each(function() {
                var event_ = event.of(this, arguments), extent1 = {
                    x: xExtent,
                    y: yExtent,
                    i: xExtentDomain,
                    j: yExtentDomain
                }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) d3.select(this).transition().each("start.brush", function() {
                    xExtentDomain = extent0.i;
                    yExtentDomain = extent0.j;
                    xExtent = extent0.x;
                    yExtent = extent0.y;
                    event_({
                        type: "brushstart"
                    });
                }).tween("brush:brush", function() {
                    var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                    xExtentDomain = yExtentDomain = null;
                    return function(t) {
                        xExtent = extent1.x = xi(t);
                        yExtent = extent1.y = yi(t);
                        event_({
                            type: "brush",
                            mode: "resize"
                        });
                    };
                }).each("end.brush", function() {
                    xExtentDomain = extent1.i;
                    yExtentDomain = extent1.j;
                    event_({
                        type: "brush",
                        mode: "resize"
                    });
                    event_({
                        type: "brushend"
                    });
                });
                else {
                    event_({
                        type: "brushstart"
                    });
                    event_({
                        type: "brush",
                        mode: "resize"
                    });
                    event_({
                        type: "brushend"
                    });
                }
            });
        };
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
                return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
        }
        function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            else w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [
                    xExtent[1 - ex] - origin[0],
                    yExtent[1 - ey] - origin[1]
                ];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
                type: "brushstart"
            });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center) center = [
                            (xExtent[0] + xExtent[1]) / 2,
                            (yExtent[0] + yExtent[1]) / 2
                        ];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: "brush",
                        mode: dragging ? "move" : "resize"
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) max = (min += position) + size;
                else {
                    if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else max = position;
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i) yExtentDomain = null;
                    else xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                d3.select("body").style("cursor", null);
                w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                dragRestore();
                event_({
                    type: "brushend"
                });
            }
        }
        brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function(z) {
            if (!arguments.length) return x && y ? [
                xClamp,
                yClamp
            ] : x ? xClamp : y ? yClamp : null;
            if (x && y) xClamp = !!z[0], yClamp = !!z[1];
            else if (x) xClamp = !!z;
            else if (y) yClamp = !!z;
            return brush;
        };
        brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0) t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0) t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ] : x ? [
                    x0,
                    x1
                ] : y && [
                    y0,
                    y1
                ];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y) x0 = x0[0], x1 = x1[0];
                xExtentDomain = [
                    x0,
                    x1
                ];
                if (x.invert) x0 = x(x0), x1 = x(x1);
                if (x1 < x0) t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [
                    x0,
                    x1
                ];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x) y0 = y0[1], y1 = y1[1];
                yExtentDomain = [
                    y0,
                    y1
                ];
                if (y.invert) y0 = y(y0), y1 = y(y1);
                if (y1 < y0) t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [
                    y0,
                    y1
                ];
            }
            return brush;
        };
        brush.clear = function() {
            if (!brush.empty()) {
                xExtent = [
                    0,
                    0
                ], yExtent = [
                    0,
                    0
                ];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
    };
    var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [
        [
            "n",
            "e",
            "s",
            "w",
            "nw",
            "ne",
            "se",
            "sw"
        ],
        [
            "e",
            "w"
        ],
        [
            "n",
            "s"
        ],
        []
    ];
    var d3_time_format1 = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format1.utc;
    var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format1.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1000) * 1000);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1000);
    }, function(date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 60000) * 60000);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 60000);
    }, function(date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 3600000 - timezone) + timezone) * 3600000);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 3600000);
    }, function(date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function(date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function(x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [
                methods.year,
                d3_scale_linearTickRange(extent.map(function(d) {
                    return d / 31536000000;
                }), count)[2]
            ] : !i ? [
                d3_time_scaleMilliseconds,
                d3_scale_linearTickRange(extent, count)[2]
            ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
            if (method) interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function(date) {
                    while(skipped(date = interval.floor(date)))date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function(date) {
                    while(skipped(date = interval.ceil(date)))date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function(interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [
                {
                    range: interval
                },
                skip
            ];
            if (method) interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
            return format;
        };
        scale.copy = function() {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [
        1000,
        5000,
        15000,
        30000,
        60000,
        300000,
        900000,
        1800000,
        3600000,
        10800000,
        21600000,
        43200000,
        86400000,
        172800000,
        604800000,
        2592000000,
        7776000000,
        31536000000
    ];
    var d3_time_scaleLocalMethods = [
        [
            d3_time.second,
            1
        ],
        [
            d3_time.second,
            5
        ],
        [
            d3_time.second,
            15
        ],
        [
            d3_time.second,
            30
        ],
        [
            d3_time.minute,
            1
        ],
        [
            d3_time.minute,
            5
        ],
        [
            d3_time.minute,
            15
        ],
        [
            d3_time.minute,
            30
        ],
        [
            d3_time.hour,
            1
        ],
        [
            d3_time.hour,
            3
        ],
        [
            d3_time.hour,
            6
        ],
        [
            d3_time.hour,
            12
        ],
        [
            d3_time.day,
            1
        ],
        [
            d3_time.day,
            2
        ],
        [
            d3_time.week,
            1
        ],
        [
            d3_time.month,
            1
        ],
        [
            d3_time.month,
            3
        ],
        [
            d3_time.year,
            1
        ]
    ];
    var d3_time_scaleLocalFormat = d3_time_format1.multi([
        [
            ".%L",
            function(d) {
                return d.getMilliseconds();
            }
        ],
        [
            ":%S",
            function(d) {
                return d.getSeconds();
            }
        ],
        [
            "%I:%M",
            function(d) {
                return d.getMinutes();
            }
        ],
        [
            "%I %p",
            function(d) {
                return d.getHours();
            }
        ],
        [
            "%a %d",
            function(d) {
                return d.getDay() && d.getDate() != 1;
            }
        ],
        [
            "%b %d",
            function(d) {
                return d.getDate() != 1;
            }
        ],
        [
            "%B",
            function(d) {
                return d.getMonth();
            }
        ],
        [
            "%Y",
            d3_true
        ]
    ]);
    var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [
            m[0].utc,
            m[1]
        ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([
        [
            ".%L",
            function(d) {
                return d.getUTCMilliseconds();
            }
        ],
        [
            ":%S",
            function(d) {
                return d.getUTCSeconds();
            }
        ],
        [
            "%I:%M",
            function(d) {
                return d.getUTCMinutes();
            }
        ],
        [
            "%I %p",
            function(d) {
                return d.getUTCHours();
            }
        ],
        [
            "%a %d",
            function(d) {
                return d.getUTCDay() && d.getUTCDate() != 1;
            }
        ],
        [
            "%b %d",
            function(d) {
                return d.getUTCDate() != 1;
            }
        ],
        [
            "%B",
            function(d) {
                return d.getUTCMonth();
            }
        ],
        [
            "%Y",
            d3_true
        ]
    ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function(request) {
        return request.responseText;
    });
    d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
    });
    if (typeof define === "function" && define.amd) this.d3 = d3, define(d3);
    else if (typeof module === "object" && module.exports) module.exports = d3;
    else this.d3 = d3;
}();

},{}]},["9bxEN","iJDgK"], "iJDgK", "parcelRequire5481")

//# sourceMappingURL=index.8eb82e9b.js.map
